# HG changeset patch
# User Vadim.Orel@gmail.com
# Date 1400073016 -10800
#      Wed May 14 16:10:16 2014 +0300
# Node ID 36b66fb9e5965c8641decb411fb6ca626a607bd1
# Parent  bdcd584f357b834ca5b25fdd5b0614197526533d
Add *.h files from NSPR
Add Extern "C"
Some debugger improovements

diff --git a/js/public/CallArgs.h b/js/public/CallArgs.h
--- a/js/public/CallArgs.h
+++ b/js/public/CallArgs.h
@@ -49,17 +49,17 @@ typedef JSBool
  * Compute |this| for the |vp| inside a JSNative, either boxing primitives or
  * replacing with the global object as necessary.
  *
  * This method will go away at some point: instead use |args.thisv()|.  If the
  * value is an object, no further work is required.  If that value is |null| or
  * |undefined|, use |JS_GetGlobalForObject| to compute the global object.  If
  * the value is some other primitive, use |JS_ValueToObject| to box it.
  */
-extern JS_PUBLIC_API(JS::Value)
+extern "C" JS_PUBLIC_API(JS::Value)
 JS_ComputeThis(JSContext *cx, JS::Value *vp);
 
 namespace JS {
 
 extern JS_PUBLIC_DATA(const HandleValue) UndefinedHandleValue;
 
 /*
  * JS::CallReceiver encapsulates access to the callee, |this|, and eventual
diff --git a/js/src/jsapi.cpp b/js/src/jsapi.cpp
--- a/js/src/jsapi.cpp
+++ b/js/src/jsapi.cpp
@@ -6987,16 +6987,22 @@ JS_DescribeScriptedCaller(JSContext *cx,
 static PRStatus
 CallOnce(void *func)
 {
     JSInitCallback init = JS_DATA_TO_FUNC_PTR(JSInitCallback, func);
     return init() ? PR_SUCCESS : PR_FAILURE;
 }
 #endif
 
+JS_PUBLIC_DATA(jsval)
+JS_NumberValue_(double d)
+{
+    return JS_NumberValue(d);
+}
+
 JS_PUBLIC_API(JSBool)
 JS_CallOnce(JSCallOnceType *once, JSInitCallback func)
 {
 #ifdef JS_THREADSAFE
     return PR_CallOnceWithArg(once, CallOnce, JS_FUNC_TO_DATA_PTR(void *, func)) == PR_SUCCESS;
 #else
     if (!*once) {
         *once = true;
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -615,17 +615,17 @@ typedef bool (*IsAcceptableThis)(const V
  * Implements the guts of a method; guaranteed to be provided an acceptable
  * this-value, as determined by a corresponding IsAcceptableThis method.
  */
 typedef bool (*NativeImpl)(JSContext *cx, CallArgs args);
 
 namespace detail {
 
 /* DON'T CALL THIS DIRECTLY.  It's for use only by CallNonGenericMethod! */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 CallMethodIfWrapped(JSContext *cx, IsAcceptableThis test, NativeImpl impl, CallArgs args);
 
 } /* namespace detail */
 
 /*
  * Methods usually act upon |this| objects only from a single global object and
  * compartment.  Sometimes, however, a method must act upon |this| values from
  * multiple global objects or compartments.  In such cases the |this| value a
@@ -1151,16 +1151,18 @@ JS_NumberValue(double d)
 {
     int32_t i;
     d = JS::CanonicalizeNaN(d);
     if (mozilla::DoubleIsInt32(d, &i))
         return INT_TO_JSVAL(i);
     return DOUBLE_TO_JSVAL(d);
 }
 
+extern "C" JS_PUBLIC_DATA(jsval) JS_NumberValue_(double d);
+
 /************************************************************************/
 
 /*
  * A jsid is an identifier for a property or method of an object which is
  * either a 31-bit signed integer, interned string or object.  Also, there is
  * an additional jsid value, JSID_VOID, which does not occur in JS scripts but
  * may be used to indicate the absence of a valid jsid.
  *
@@ -1395,37 +1397,37 @@ class AutoIdRooter : private AutoGCRoote
 /*
  * The first call to JS_CallOnce by any thread in a process will call 'func'.
  * Later calls to JS_CallOnce with the same JSCallOnceType object will be
  * suppressed.
  *
  * Equivalently: each distinct JSCallOnceType object will allow one JS_CallOnce
  * to invoke its JSInitCallback.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_CallOnce(JSCallOnceType *once, JSInitCallback func);
 
 /* Microseconds since the epoch, midnight, January 1, 1970 UTC. */
-extern JS_PUBLIC_API(int64_t)
+extern "C" JS_PUBLIC_API(int64_t)
 JS_Now(void);
 
 /* Don't want to export data, so provide accessors for non-inline jsvals. */
-extern JS_PUBLIC_API(jsval)
+extern "C" JS_PUBLIC_API(jsval)
 JS_GetNaNValue(JSContext *cx);
 
-extern JS_PUBLIC_API(jsval)
+extern "C" JS_PUBLIC_API(jsval)
 JS_GetNegativeInfinityValue(JSContext *cx);
 
-extern JS_PUBLIC_API(jsval)
+extern "C" JS_PUBLIC_API(jsval)
 JS_GetPositiveInfinityValue(JSContext *cx);
 
-extern JS_PUBLIC_API(jsval)
+extern "C" JS_PUBLIC_API(jsval)
 JS_GetEmptyStringValue(JSContext *cx);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_GetEmptyString(JSRuntime *rt);
 
 /*
  * Format is a string of the following characters (spaces are insignificant),
  * specifying the tabulated type conversions:
  *
  *   b      JSBool          Boolean
  *   c      uint16_t/jschar ECMA uint16_t, Unicode char
@@ -1450,58 +1452,58 @@ JS_GetEmptyString(JSRuntime *rt);
  * (so long as the native function is active).
  *
  * Fewer arguments than format specifies may be passed only if there is a /
  * in format after the last required argument specifier and argc is at least
  * the number of required arguments.  More arguments than format specifies
  * may be passed without error; it is up to the caller to deal with trailing
  * unconverted arguments.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ConvertArguments(JSContext *cx, unsigned argc, jsval *argv, const char *format,
                     ...);
 
 #ifdef va_start
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ConvertArgumentsVA(JSContext *cx, unsigned argc, jsval *argv,
                       const char *format, va_list ap);
 #endif
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ConvertValue(JSContext *cx, jsval v, JSType type, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToObject(JSContext *cx, jsval v, JSObject **objp);
 
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_ValueToFunction(JSContext *cx, jsval v);
 
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_ValueToConstructor(JSContext *cx, jsval v);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_ValueToString(JSContext *cx, jsval v);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_ValueToSource(JSContext *cx, jsval v);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToNumber(JSContext *cx, jsval v, double *dp);
 
 namespace js {
 /*
  * DO NOT CALL THIS.  Use JS::ToNumber
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 ToNumberSlow(JSContext *cx, JS::Value v, double *dp);
 
 /*
  * DO NOT CALL THIS. Use JS::ToBoolean
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 ToBooleanSlow(const JS::Value &v);
 } /* namespace js */
 
 namespace JS {
 
 /* ES5 9.3 ToNumber. */
 JS_ALWAYS_INLINE bool
 ToNumber(JSContext *cx, const Value &v, double *out)
@@ -1534,65 +1536,65 @@ ToBoolean(const Value &v)
     }
 
     /* The slow path handles strings and objects. */
     return js::ToBooleanSlow(v);
 }
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DoubleIsInt32(double d, int32_t *ip);
 
-extern JS_PUBLIC_API(int32_t)
+extern "C" JS_PUBLIC_API(int32_t)
 JS_DoubleToInt32(double d);
 
-extern JS_PUBLIC_API(uint32_t)
+extern "C" JS_PUBLIC_API(uint32_t)
 JS_DoubleToUint32(double d);
 
 /*
  * Convert a value to a number, then to an int32_t, according to the ECMA rules
  * for ToInt32.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToECMAInt32(JSContext *cx, jsval v, int32_t *ip);
 
 /*
  * Convert a value to a number, then to an int64_t, according to the WebIDL
  * rules for ToInt64: http://dev.w3.org/2006/webapi/WebIDL/#es-long-long
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToInt64(JSContext *cx, jsval v, int64_t *ip);
 
 /*
  * Convert a value to a number, then to an uint64_t, according to the WebIDL
  * rules for ToUint64: http://dev.w3.org/2006/webapi/WebIDL/#es-unsigned-long-long
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToUint64(JSContext *cx, jsval v, uint64_t *ip);
 
 namespace js {
 /* DO NOT CALL THIS.  Use JS::ToInt16. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 ToUint16Slow(JSContext *cx, const JS::Value &v, uint16_t *out);
 
 /* DO NOT CALL THIS.  Use JS::ToInt32. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 ToInt32Slow(JSContext *cx, const JS::Value &v, int32_t *out);
 
 /* DO NOT CALL THIS.  Use JS::ToUint32. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 ToUint32Slow(JSContext *cx, const JS::Value &v, uint32_t *out);
 
 /* DO NOT CALL THIS. Use JS::ToInt64. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 ToInt64Slow(JSContext *cx, const JS::Value &v, int64_t *out);
 
 /* DO NOT CALL THIS. Use JS::ToUint64. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 ToUint64Slow(JSContext *cx, const JS::Value &v, uint64_t *out);
 } /* namespace js */
 
 namespace JS {
 
 JS_ALWAYS_INLINE bool
 ToUint16(JSContext *cx, const JS::Value &v, uint16_t *out)
 {
@@ -1678,57 +1680,57 @@ ToUint64(JSContext *cx, const JS::Value 
 
 
 } /* namespace JS */
 
 /*
  * Convert a value to a number, then to a uint32_t, according to the ECMA rules
  * for ToUint32.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToECMAUint32(JSContext *cx, jsval v, uint32_t *ip);
 
 /*
  * Convert a value to a number, then to an int32_t if it fits by rounding to
  * nearest; but failing with an error report if the double is out of range
  * or unordered.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToInt32(JSContext *cx, jsval v, int32_t *ip);
 
 /*
  * ECMA ToUint16, for mapping a jsval to a Unicode point.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToUint16(JSContext *cx, jsval v, uint16_t *ip);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToBoolean(JSContext *cx, jsval v, JSBool *bp);
 
-extern JS_PUBLIC_API(JSType)
+extern "C" JS_PUBLIC_API(JSType)
 JS_TypeOfValue(JSContext *cx, jsval v);
 
-extern JS_PUBLIC_API(const char *)
+extern "C" JS_PUBLIC_API(const char *)
 JS_GetTypeName(JSContext *cx, JSType type);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_StrictlyEqual(JSContext *cx, jsval v1, jsval v2, JSBool *equal);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_LooselyEqual(JSContext *cx, jsval v1, jsval v2, JSBool *equal);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SameValue(JSContext *cx, jsval v1, jsval v2, JSBool *same);
 
 /* True iff fun is the global eval function. */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsBuiltinEvalFunction(JSFunction *fun);
 
 /* True iff fun is the Function constructor. */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsBuiltinFunctionConstructor(JSFunction *fun);
 
 /************************************************************************/
 
 /*
  * Initialization, locking, contexts, and memory allocation.
  *
  * It is important that the first runtime and first context be created in a
@@ -1737,41 +1739,41 @@ JS_IsBuiltinFunctionConstructor(JSFuncti
  */
 
 typedef enum JSUseHelperThreads
 {
     JS_NO_HELPER_THREADS,
     JS_USE_HELPER_THREADS
 } JSUseHelperThreads;
 
-extern JS_PUBLIC_API(JSRuntime *)
+extern "C" JS_PUBLIC_API(JSRuntime *)
 JS_NewRuntime(uint32_t maxbytes, JSUseHelperThreads useHelperThreads);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DestroyRuntime(JSRuntime *rt);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ShutDown(void);
 
 JS_PUBLIC_API(void *)
 JS_GetRuntimePrivate(JSRuntime *rt);
 
-extern JS_PUBLIC_API(JSRuntime *)
+extern "C" JS_PUBLIC_API(JSRuntime *)
 JS_GetRuntime(JSContext *cx);
 
 JS_PUBLIC_API(void)
 JS_SetRuntimePrivate(JSRuntime *rt, void *data);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_BeginRequest(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_EndRequest(JSContext *cx);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsInRequest(JSRuntime *rt);
 
 namespace JS {
 
 inline bool
 IsPoisonedId(jsid iden)
 {
     if (JSID_IS_STRING(iden))
@@ -1846,62 +1848,62 @@ class JSAutoCheckRequest
 
   private:
 #if defined JS_THREADSAFE && defined JS_DEBUG
     JSContext *mContext;
 #endif
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-extern JS_PUBLIC_API(JSContextCallback)
+extern "C" JS_PUBLIC_API(JSContextCallback)
 JS_SetContextCallback(JSRuntime *rt, JSContextCallback cxCallback);
 
-extern JS_PUBLIC_API(JSContext *)
+extern "C" JS_PUBLIC_API(JSContext *)
 JS_NewContext(JSRuntime *rt, size_t stackChunkSize);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DestroyContext(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DestroyContextNoGC(JSContext *cx);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_GetContextPrivate(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetContextPrivate(JSContext *cx, void *data);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_GetSecondContextPrivate(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetSecondContextPrivate(JSContext *cx, void *data);
 
-extern JS_PUBLIC_API(JSRuntime *)
+extern "C" JS_PUBLIC_API(JSRuntime *)
 JS_GetRuntime(JSContext *cx);
 
-extern JS_PUBLIC_API(JSContext *)
+extern "C" JS_PUBLIC_API(JSContext *)
 JS_ContextIterator(JSRuntime *rt, JSContext **iterp);
 
-extern JS_PUBLIC_API(JSVersion)
+extern "C" JS_PUBLIC_API(JSVersion)
 JS_GetVersion(JSContext *cx);
 
 // Mutate the version on the compartment. This is generally discouraged, but
 // necessary to support the version mutation in the js and xpc shell command
 // set.
 //
 // It would be nice to put this in jsfriendapi, but the linkage requirements
 // of the shells make that impossible.
 JS_PUBLIC_API(void)
 JS_SetVersionForCompartment(JSCompartment *compartment, JSVersion version);
 
-extern JS_PUBLIC_API(const char *)
+extern "C" JS_PUBLIC_API(const char *)
 JS_VersionToString(JSVersion version);
 
-extern JS_PUBLIC_API(JSVersion)
+extern "C" JS_PUBLIC_API(JSVersion)
 JS_StringToVersion(const char *string);
 
 /*
  * JS options are orthogonal to version, and may be freely composed with one
  * another as well as with version.
  *
  * JSOPTION_VAROBJFIX is recommended -- see the comments associated with the
  * prototypes for JS_ExecuteScript, JS_EvaluateScript, etc.
@@ -1960,74 +1962,74 @@ JS_StringToVersion(const char *string);
                                                    "use strict" annotations. */
 
 #define JSOPTION_ION            JS_BIT(18)      /* IonMonkey */
 
 #define JSOPTION_ASMJS          JS_BIT(19)      /* optimizingasm.js compiler */
 
 #define JSOPTION_MASK           JS_BITMASK(20)
 
-extern JS_PUBLIC_API(uint32_t)
+extern "C" JS_PUBLIC_API(uint32_t)
 JS_GetOptions(JSContext *cx);
 
-extern JS_PUBLIC_API(uint32_t)
+extern "C" JS_PUBLIC_API(uint32_t)
 JS_SetOptions(JSContext *cx, uint32_t options);
 
-extern JS_PUBLIC_API(uint32_t)
+extern "C" JS_PUBLIC_API(uint32_t)
 JS_ToggleOptions(JSContext *cx, uint32_t options);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetJitHardening(JSRuntime *rt, JSBool enabled);
 
-extern JS_PUBLIC_API(const char *)
+extern "C" JS_PUBLIC_API(const char *)
 JS_GetImplementationVersion(void);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetDestroyCompartmentCallback(JSRuntime *rt, JSDestroyCompartmentCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetDestroyZoneCallback(JSRuntime *rt, JSZoneCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetSweepZoneCallback(JSRuntime *rt, JSZoneCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetCompartmentNameCallback(JSRuntime *rt, JSCompartmentNameCallback callback);
 
-extern JS_PUBLIC_API(JSWrapObjectCallback)
+extern "C" JS_PUBLIC_API(JSWrapObjectCallback)
 JS_SetWrapObjectCallbacks(JSRuntime *rt,
                           JSWrapObjectCallback callback,
                           JSSameCompartmentWrapObjectCallback sccallback,
                           JSPreWrapCallback precallback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetCompartmentPrivate(JSCompartment *compartment, void *data);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_GetCompartmentPrivate(JSCompartment *compartment);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetZoneUserData(JS::Zone *zone, void *data);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_GetZoneUserData(JS::Zone *zone);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_WrapObject(JSContext *cx, JSObject **objp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_WrapValue(JSContext *cx, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_WrapId(JSContext *cx, jsid *idp);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_TransplantObject(JSContext *cx, JS::HandleObject origobj, JS::HandleObject target);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_RefreshCrossCompartmentWrappers(JSContext *cx, JSObject *ob);
 
 /*
  * At any time, a JSContext has a current (possibly-NULL) compartment.
  * Compartments are described in:
  *
  *   developer.mozilla.org/en-US/docs/SpiderMonkey/SpiderMonkey_compartments
  *
@@ -2066,136 +2068,136 @@ class JS_PUBLIC_API(JSAutoCompartment)
     JSCompartment *oldCompartment_;
   public:
     JSAutoCompartment(JSContext *cx, JSObject *target);
     JSAutoCompartment(JSContext *cx, JSScript *target);
     ~JSAutoCompartment();
 };
 
 /* NB: This API is infallible; a NULL return value does not indicate error. */
-extern JS_PUBLIC_API(JSCompartment *)
+extern "C" JS_PUBLIC_API(JSCompartment *)
 JS_EnterCompartment(JSContext *cx, JSObject *target);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_LeaveCompartment(JSContext *cx, JSCompartment *oldCompartment);
 
 typedef void (*JSIterateCompartmentCallback)(JSRuntime *rt, void *data, JSCompartment *compartment);
 
 /*
  * This function calls |compartmentCallback| on every compartment.  Beware that
  * there is no guarantee that the compartment will survive after the callback
  * returns.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_IterateCompartments(JSRuntime *rt, void *data,
                        JSIterateCompartmentCallback compartmentCallback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGlobalObject(JSContext *cx, JSObject *obj);
 
 /*
  * Initialize standard JS class constructors, prototypes, and any top-level
  * functions and constants associated with the standard classes (e.g. isNaN
  * for Number).
  *
  * NB: This sets cx's global object to obj if it was null.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_InitStandardClasses(JSContext *cx, JSObject *obj);
 
 /*
  * Resolve id, which must contain either a string or an int, to a standard
  * class name in obj if possible, defining the class's constructor and/or
  * prototype and storing true in *resolved.  If id does not name a standard
  * class or a top-level property induced by initializing a standard class,
  * store false in *resolved and just return true.  Return false on error,
  * as usual for JSBool result-typed API entry points.
  *
  * This API can be called directly from a global object class's resolve op,
  * to define standard classes lazily.  The class's enumerate op should call
  * JS_EnumerateStandardClasses(cx, obj), to define eagerly during for..in
  * loops any classes not yet resolved lazily.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ResolveStandardClass(JSContext *cx, JS::HandleObject obj, JS::HandleId id,
                         JSBool *resolved);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EnumerateStandardClasses(JSContext *cx, JS::HandleObject obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject **objp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetClassPrototype(JSContext *cx, JSProtoKey key, JSObject **objp);
 
-extern JS_PUBLIC_API(JSProtoKey)
+extern "C" JS_PUBLIC_API(JSProtoKey)
 JS_IdentifyClassPrototype(JSContext *cx, JSObject *obj);
 
 /*
  * Returns the original value of |Function.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetFunctionPrototype(JSContext *cx, JSObject *forObj);
 
 /*
  * Returns the original value of |Object.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetObjectPrototype(JSContext *cx, JSObject *forObj);
 
 /*
  * Returns the original value of |Array.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetArrayPrototype(JSContext *cx, JSObject *forObj);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetGlobalForObject(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsGlobalObject(JSObject *obj);
 
 /*
  * May return NULL, if |c| never had a global (e.g. the atoms compartment), or
  * if |c|'s global has been collected.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetGlobalForCompartmentOrNull(JSContext *cx, JSCompartment *c);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetGlobalForScopeChain(JSContext *cx);
 
 /*
  * This method returns the global corresponding to the most recent scripted
  * frame, which may not match the cx's current compartment. This is extremely
  * dangerous, because it can bypass compartment security invariants in subtle
  * ways. To use it safely, the caller must perform a subsequent security
  * check. There is currently only one consumer of this function in Gecko, and
  * it should probably stay that way. If you'd like to use it, please consult
  * the XPConnect module owner first.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetScriptedGlobal(JSContext *cx);
 
 /*
  * Initialize the 'Reflect' object on a global object.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_InitReflect(JSContext *cx, JSObject *global);
 
 #ifdef JS_HAS_CTYPES
 /*
  * Initialize the 'ctypes' object on a global variable 'obj'. The 'ctypes'
  * object will be sealed.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_InitCTypesClass(JSContext *cx, JSObject *global);
 
 /*
  * Convert a unicode string 'source' of length 'slen' to the platform native
  * charset, returning a null-terminated string allocated with JS_malloc. On
  * failure, this function should report an error.
  */
 typedef char *
@@ -2213,58 +2215,58 @@ struct JSCTypesCallbacks {
 typedef struct JSCTypesCallbacks JSCTypesCallbacks;
 
 /*
  * Set the callbacks on the provided 'ctypesObj' object. 'callbacks' should be a
  * pointer to static data that exists for the lifetime of 'ctypesObj', but it
  * may safely be altered after calling this function and without having
  * to call this function again.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetCTypesCallbacks(JSObject *ctypesObj, JSCTypesCallbacks *callbacks);
 #endif
 
 typedef JSBool
 (* JSEnumerateDiagnosticMemoryCallback)(void *ptr, size_t length);
 
 /*
  * Enumerate memory regions that contain diagnostic information
  * intended to be included in crash report minidumps.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_EnumerateDiagnosticMemoryRegions(JSEnumerateDiagnosticMemoryCallback callback);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_malloc(JSContext *cx, size_t nbytes);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_realloc(JSContext *cx, void *p, size_t nbytes);
 
 /*
  * A wrapper for js_free(p) that may delay js_free(p) invocation as a
  * performance optimization.
  * cx may be NULL.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_free(JSContext *cx, void *p);
 
 /*
  * A wrapper for js_free(p) that may delay js_free(p) invocation as a
  * performance optimization as specified by the given JSFreeOp instance.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_freeop(JSFreeOp *fop, void *p);
 
-extern JS_PUBLIC_API(JSFreeOp *)
+extern "C" JS_PUBLIC_API(JSFreeOp *)
 JS_GetDefaultFreeOp(JSRuntime *rt);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_updateMallocCounter(JSContext *cx, size_t nbytes);
 
-extern JS_PUBLIC_API(char *)
+extern "C" JS_PUBLIC_API(char *)
 JS_strdup(JSContext *cx, const char *s);
 
 /* Duplicate a string.  Does not report an error on failure. */
 extern JS_PUBLIC_API(char *)
 JS_strdup(JSRuntime *rt, const char *s);
 
 
 /*
@@ -2287,70 +2289,70 @@ JS_strdup(JSRuntime *rt, const char *s);
  * before some_function() returns.
  *
  * Also, use JS_AddNamed*Root(cx, &structPtr->memberObj, "structPtr->memberObj")
  * in preference to JS_Add*Root(cx, &structPtr->memberObj), in order to identify
  * roots by their source callsites.  This way, you can find the callsite while
  * debugging if you should fail to do JS_Remove*Root(cx, &structPtr->memberObj)
  * before freeing structPtr's memory.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddValueRoot(JSContext *cx, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddStringRoot(JSContext *cx, JSString **rp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddObjectRoot(JSContext *cx, JSObject **rp);
 
 #ifdef NAME_ALL_GC_ROOTS
 #define JS_DEFINE_TO_TOKEN(def) #def
 #define JS_DEFINE_TO_STRING(def) JS_DEFINE_TO_TOKEN(def)
 #define JS_AddValueRoot(cx,vp) JS_AddNamedValueRoot((cx), (vp), (__FILE__ ":" JS_TOKEN_TO_STRING(__LINE__))
 #define JS_AddStringRoot(cx,rp) JS_AddNamedStringRoot((cx), (rp), (__FILE__ ":" JS_TOKEN_TO_STRING(__LINE__))
 #define JS_AddObjectRoot(cx,rp) JS_AddNamedObjectRoot((cx), (rp), (__FILE__ ":" JS_TOKEN_TO_STRING(__LINE__))
 #endif
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddNamedValueRoot(JSContext *cx, jsval *vp, const char *name);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddNamedValueRootRT(JSRuntime *rt, jsval *vp, const char *name);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddNamedStringRoot(JSContext *cx, JSString **rp, const char *name);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddNamedObjectRoot(JSContext *cx, JSObject **rp, const char *name);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddNamedScriptRoot(JSContext *cx, JSScript **rp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveValueRoot(JSContext *cx, jsval *vp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveStringRoot(JSContext *cx, JSString **rp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveObjectRoot(JSContext *cx, JSObject **rp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveScriptRoot(JSContext *cx, JSScript **rp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveValueRootRT(JSRuntime *rt, jsval *vp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveStringRootRT(JSRuntime *rt, JSString **rp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveObjectRootRT(JSRuntime *rt, JSObject **rp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveScriptRootRT(JSRuntime *rt, JSScript **rp);
 
 /* TODO: remove these APIs */
 
 extern JS_FRIEND_API(void)
 js_RemoveRoot(JSRuntime *rt, void *rp);
 
 /*
@@ -2362,21 +2364,21 @@ JS_AnchorPtr(void *p);
 
 /*
  * Register externally maintained GC roots.
  *
  * traceOp: the trace operation. For each root the implementation should call
  *          JS_CallTracer whenever the root contains a traceable thing.
  * data:    the data argument to pass to each invocation of traceOp.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AddExtraGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data);
 
 /* Undo a call to JS_AddExtraGCRootsTracer. */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveExtraGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data);
 
 /*
  * JS_CallTracer API and related macros for implementors of JSTraceOp, to
  * enumerate all references to traceable things reachable via a property or
  * other strong ref identified for debugging purposes by name or index or
  * a naming callback.
  *
@@ -2515,47 +2517,47 @@ struct JSTracer {
  * The argument to JS_Call*Tracer is an in-out param: when the function
  * returns, the garbage collector might have moved the GC thing. In this case,
  * the reference passed to JS_Call*Tracer will be updated to the object's new
  * location. Callers of this method are responsible for updating any state
  * that is dependent on the object's address. For example, if the object's
  * address is used as a key in a hashtable, then the object must be removed
  * and re-inserted with the correct hash.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallValueTracer(JSTracer *trc, JS::Value *valuep, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallIdTracer(JSTracer *trc, jsid *idp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallObjectTracer(JSTracer *trc, JSObject **objp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallStringTracer(JSTracer *trc, JSString **strp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallScriptTracer(JSTracer *trc, JSScript **scriptp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallHeapValueTracer(JSTracer *trc, JS::Heap<JS::Value> *valuep, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallHeapIdTracer(JSTracer *trc, JS::Heap<jsid> *idp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallHeapObjectTracer(JSTracer *trc, JS::Heap<JSObject *> *objp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallHeapStringTracer(JSTracer *trc, JS::Heap<JSString *> *strp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallHeapScriptTracer(JSTracer *trc, JS::Heap<JSScript *> *scriptp, const char *name);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallGenericTracer(JSTracer *trc, void *gcthing, const char *name);
 
 template <typename HashSetEnum>
 inline void
 JS_CallHashSetObjectTracer(JSTracer *trc, HashSetEnum &e, JSObject *const &key, const char *name)
 {
     JSObject *updated = key;
     JS_SET_TRACING_LOCATION(trc, reinterpret_cast<void *>(&const_cast<JSObject *&>(key)));
@@ -2565,36 +2567,36 @@ JS_CallHashSetObjectTracer(JSTracer *trc
 }
 
 /*
  * The JS_CallMaskedObjectTracer variant traces a JSObject* that is stored
  * with flags embedded in the low bits of the word. The flagMask parameter
  * expects |*objp & flagMask| to yield the flags with the pointer value
  * stripped and |*objp & ~flagMask| to yield a valid GC pointer.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_CallMaskedObjectTracer(JSTracer *trc, uintptr_t *objp, uintptr_t flagMask, const char *name);
 
 /*
  * API for JSTraceCallback implementations.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_TracerInit(JSTracer *trc, JSRuntime *rt, JSTraceCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_TraceChildren(JSTracer *trc, void *thing, JSGCTraceKind kind);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_TraceRuntime(JSTracer *trc);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_GetTraceThingInfo(char *buf, size_t bufsize, JSTracer *trc,
                      void *thing, JSGCTraceKind kind, JSBool includeDetails);
 
-extern JS_PUBLIC_API(const char *)
+extern "C" JS_PUBLIC_API(const char *)
 JS_GetTraceEdgeName(JSTracer *trc, char *buffer, int bufferSize);
 
 #ifdef JS_DEBUG
 
 /*
  * Debug-only method to dump the object graph of heap-allocated things.
  *
  * fp:              file for the dump output.
@@ -2604,38 +2606,38 @@ JS_GetTraceEdgeName(JSTracer *trc, char 
  * startKind:       trace kind of start if start is not null. Must be
  *                  JSTRACE_OBJECT when start is null.
  * thingToFind:     dump only paths in the object graph leading to thingToFind
  *                  when non-null.
  * maxDepth:        the upper bound on the number of edges to descend from the
  *                  graph roots.
  * thingToIgnore:   thing to ignore during the graph traversal when non-null.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DumpHeap(JSRuntime *rt, FILE *fp, void* startThing, JSGCTraceKind kind,
             void *thingToFind, size_t maxDepth, void *thingToIgnore);
 
 #endif
 
 /*
  * Garbage collector API.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_GC(JSRuntime *rt);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_MaybeGC(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGCCallback(JSRuntime *rt, JSGCCallback cb);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetFinalizeCallback(JSRuntime *rt, JSFinalizeCallback cb);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsGCMarkingTracer(JSTracer *trc);
 
 /*
  * JS_IsAboutToBeFinalized checks if the given object is going to be finalized
  * at the end of the current GC. When called outside of the context of a GC,
  * this function will return false. Typically this function is used on weak
  * references, where the reference should be nulled out or destroyed if the
  * given object is about to be finalized.
@@ -2644,17 +2646,17 @@ JS_IsGCMarkingTracer(JSTracer *trc);
  * function returns false, the object being referenced is still alive, but the
  * garbage collector might have moved it. In this case, the reference passed
  * to JS_IsAboutToBeFinalized will be updated to the object's new location.
  * Callers of this method are responsible for updating any state that is
  * dependent on the object's address. For example, if the object's address is
  * used as a key in a hashtable, then the object must be removed and
  * re-inserted with the correct hash.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsAboutToBeFinalized(JSObject **obj);
 
 typedef enum JSGCParamKey {
     /* Maximum nominal heap before last ditch GC. */
     JSGC_MAX_BYTES          = 0,
 
     /* Number of JS_malloc bytes before last ditch GC. */
     JSGC_MAX_MALLOC_BYTES   = 1,
@@ -2736,55 +2738,55 @@ typedef enum JSGCMode {
 
     /*
      * Collect in short time slices rather than all at once. Implies
      * JSGC_MODE_COMPARTMENT.
      */
     JSGC_MODE_INCREMENTAL = 2
 } JSGCMode;
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32_t value);
 
-extern JS_PUBLIC_API(uint32_t)
+extern "C" JS_PUBLIC_API(uint32_t)
 JS_GetGCParameter(JSRuntime *rt, JSGCParamKey key);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGCParameterForThread(JSContext *cx, JSGCParamKey key, uint32_t value);
 
-extern JS_PUBLIC_API(uint32_t)
+extern "C" JS_PUBLIC_API(uint32_t)
 JS_GetGCParameterForThread(JSContext *cx, JSGCParamKey key);
 
 /*
  * Create a new JSString whose chars member refers to external memory, i.e.,
  * memory requiring application-specific finalization.
  */
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_NewExternalString(JSContext *cx, const jschar *chars, size_t length,
                      const JSStringFinalizer *fin);
 
 /*
  * Return whether 'str' was created with JS_NewExternalString or
  * JS_NewExternalStringWithClosure.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsExternalString(JSString *str);
 
 /*
  * Return the 'closure' arg passed to JS_NewExternalStringWithClosure or NULL
  * if the external string was created via JS_NewExternalString.
  */
-extern JS_PUBLIC_API(const JSStringFinalizer *)
+extern "C" JS_PUBLIC_API(const JSStringFinalizer *)
 JS_GetExternalStringFinalizer(JSString *str);
 
 /*
  * Set the size of the native stack that should not be exceed. To disable
  * stack size checking pass 0.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetNativeStackQuota(JSRuntime *cx, size_t stackSize);
 
 /************************************************************************/
 
 /*
  * Classes, objects, and properties.
  */
 typedef void (*JSClassInternal)();
@@ -2894,23 +2896,23 @@ struct JSClass {
                                          (((clasp)->flags                     \
                                            >> JSCLASS_CACHED_PROTO_SHIFT)     \
                                           & JSCLASS_CACHED_PROTO_MASK))
 
 /* Initializer for unused members of statically initialized JSClass structs. */
 #define JSCLASS_NO_INTERNAL_MEMBERS     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
 #define JSCLASS_NO_OPTIONAL_MEMBERS     0,0,0,0,0,JSCLASS_NO_INTERNAL_MEMBERS
 
-extern JS_PUBLIC_API(int)
+extern "C" JS_PUBLIC_API(int)
 JS_IdArrayLength(JSContext *cx, JSIdArray *ida);
 
-extern JS_PUBLIC_API(jsid)
+extern "C" JS_PUBLIC_API(jsid)
 JS_IdArrayGet(JSContext *cx, JSIdArray *ida, int index);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DestroyIdArray(JSContext *cx, JSIdArray *ida);
 
 namespace JS {
 
 class AutoIdArray : private AutoGCRooter
 {
   public:
     AutoIdArray(JSContext *cx, JSIdArray *ida
@@ -2953,55 +2955,55 @@ class AutoIdArray : private AutoGCRooter
 
     /* No copy or assignment semantics. */
     AutoIdArray(AutoIdArray &ida) MOZ_DELETE;
     void operator=(AutoIdArray &ida) MOZ_DELETE;
 };
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ValueToId(JSContext *cx, jsval v, jsid *idp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IdToValue(JSContext *cx, jsid id, jsval *vp);
 
 /*
  * JSNewResolveOp flag bits.
  */
 #define JSRESOLVE_ASSIGNING     0x01    /* resolve on the left of assignment */
 
 /*
  * Invoke the [[DefaultValue]] hook (see ES5 8.6.2) with the provided hint on
  * the specified object, computing a primitive default value for the object.
  * The hint must be JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_VOID (no hint).  On
  * success the resulting value is stored in *vp.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_PropertyStub(JSContext *cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id,
                 JS::MutableHandle<JS::Value> vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_StrictPropertyStub(JSContext *cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JSBool strict,
                       JS::MutableHandle<JS::Value> vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeletePropertyStub(JSContext *cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id,
                       JSBool *succeeded);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EnumerateStub(JSContext *cx, JS::Handle<JSObject*> obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ResolveStub(JSContext *cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ConvertStub(JSContext *cx, JS::Handle<JSObject*> obj, JSType type,
                JS::MutableHandle<JS::Value> vp);
 
 struct JSConstDoubleSpec {
     double          dval;
     const char      *name;
     uint8_t         flags;
     uint8_t         spare[3];
@@ -3107,69 +3109,69 @@ struct JSFunctionSpec {
  */
 #define JS_FS(name,call,nargs,flags)                                          \
     {name, JSOP_WRAPPER(call), nargs, flags}
 #define JS_FN(name,call,nargs,flags)                                          \
     {name, JSOP_WRAPPER(call), nargs, (flags) | JSFUN_STUB_GSOPS}
 #define JS_FNINFO(name,call,info,nargs,flags)                                 \
     {name,{call,info},nargs,flags}
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
              JSClass *clasp, JSNative constructor, unsigned nargs,
              const JSPropertySpec *ps, const JSFunctionSpec *fs,
              const JSPropertySpec *static_ps, const JSFunctionSpec *static_fs);
 
 /*
  * Set up ctor.prototype = proto and proto.constructor = ctor with the
  * right property flags.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_LinkConstructorAndPrototype(JSContext *cx, JSObject *ctor, JSObject *proto);
 
-extern JS_PUBLIC_API(JSClass *)
+extern "C" JS_PUBLIC_API(JSClass *)
 JS_GetClass(JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_InstanceOf(JSContext *cx, JSObject *obj, JSClass *clasp, jsval *argv);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_GetPrivate(JSObject *obj);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetPrivate(JSObject *obj, void *data);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_GetInstancePrivate(JSContext *cx, JSObject *obj, JSClass *clasp,
                       jsval *argv);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPrototype(JSContext *cx, JSObject *obj, JSObject **protop);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetPrototype(JSContext *cx, JSObject *obj, JSObject *proto);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetParent(JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetParent(JSContext *cx, JSObject *obj, JSObject *parent);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetConstructor(JSContext *cx, JSObject *proto);
 
 /*
  * Get a unique identifier for obj, good for the lifetime of obj (even if it
  * is moved by a copying GC).  Return false on failure (likely out of memory),
  * and true with *idp containing the unique id on success.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetObjectId(JSContext *cx, JSObject *obj, jsid *idp);
 
 namespace JS {
 
 enum {
     FreshZone,
     SystemZone,
     SpecificZones
@@ -3195,152 +3197,152 @@ struct JS_PUBLIC_API(CompartmentOptions)
     {}
 
     CompartmentOptions &setZone(ZoneSpecifier spec) { zoneSpec = spec; return *this; }
     CompartmentOptions &setVersion(JSVersion version_) { hasVersion = true; version = version_; return *this; }
 };
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewGlobalObject(JSContext *cx, JSClass *clasp, JSPrincipals *principals,
                    const JS::CompartmentOptions &options = JS::CompartmentOptions());
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent);
 
 /* Queries the [[Extensible]] property of the object. */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsExtensible(JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsNative(JSObject *obj);
 
-extern JS_PUBLIC_API(JSRuntime *)
+extern "C" JS_PUBLIC_API(JSRuntime *)
 JS_GetObjectRuntime(JSObject *obj);
 
 /*
  * Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
  * proto if proto's actual parameter value is null.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewObjectWithGivenProto(JSContext *cx, JSClass *clasp, JSObject *proto,
                            JSObject *parent);
 
 /*
  * Freeze obj, and all objects it refers to, recursively. This will not recurse
  * through non-extensible objects, on the assumption that those are already
  * deep-frozen.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeepFreezeObject(JSContext *cx, JSObject *obj);
 
 /*
  * Freezes an object; see ES5's Object.freeze(obj) method.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_FreezeObject(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_PreventExtensions(JSContext *cx, JS::HandleObject obj);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_New(JSContext *cx, JSObject *ctor, unsigned argc, jsval *argv);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_DefineObject(JSContext *cx, JSObject *obj, const char *name, JSClass *clasp,
                 JSObject *proto, unsigned attrs);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineConstDoubles(JSContext *cx, JSObject *obj, const JSConstDoubleSpec *cds);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineProperties(JSContext *cx, JSObject *obj, const JSPropertySpec *ps);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
                   JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
                       JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id, jsval descriptor, JSBool *bp);
 
 /*
  * Determine the attributes (JSPROP_* flags) of a property on a given object.
  *
  * If the object does not have a property by that name, *foundp will be
  * JS_FALSE and the value of *attrsp is undefined.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
                          unsigned *attrsp, JSBool *foundp);
 
 /*
  * The same, but if the property is native, return its getter and setter via
  * *getterp and *setterp, respectively (and only if the out parameter pointer
  * is not null).
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
                                    const char *name,
                                    unsigned *attrsp, JSBool *foundp,
                                    JSPropertyOp *getterp,
                                    JSStrictPropertyOp *setterp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPropertyAttrsGetterAndSetterById(JSContext *cx, JSObject *obj,
                                        jsid id,
                                        unsigned *attrsp, JSBool *foundp,
                                        JSPropertyOp *getterp,
                                        JSStrictPropertyOp *setterp);
 
 /*
  * Set the attributes of a property on a given object.
  *
  * If the object does not have a property by that name, *foundp will be
  * JS_FALSE and nothing will be altered.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
                          unsigned attrs, JSBool *foundp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefinePropertyWithTinyId(JSContext *cx, JSObject *obj, const char *name,
                             int8_t tinyid, jsval value,
                             JSPropertyOp getter, JSStrictPropertyOp setter,
                             unsigned attrs);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AlreadyHasOwnProperty(JSContext *cx, JSObject *obj, const char *name,
                          JSBool *foundp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *obj, jsid id,
                              JSBool *foundp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_HasProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_HasPropertyById(JSContext *cx, JSObject *obj, jsid id, JSBool *foundp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_LookupProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, const char *name,
                            unsigned flags, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *obj, jsid id,
                                unsigned flags, JSObject **objp, jsval *vp);
 
 struct JSPropertyDescriptor {
     JSObject           *obj;
     unsigned           attrs;
     unsigned           shortid;
     JSPropertyOp       getter;
@@ -3457,182 +3459,182 @@ class MutableHandleBase<JSPropertyDescri
 
 } /* namespace js */
 
 /*
  * Like JS_GetPropertyAttrsGetterAndSetterById but will return a property on
  * an object on the prototype chain (returned in objp). If data->obj is null,
  * then this property was not found on the prototype chain.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPropertyDescriptorById(JSContext *cx, JSObject *obj, jsid id, unsigned flags,
                              JSPropertyDescriptor *desc);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPropertyDefault(JSContext *cx, JSObject *obj, const char *name, jsval def, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPropertyByIdDefault(JSContext *cx, JSObject *obj, jsid id, jsval def, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ForwardGetPropertyTo(JSContext *cx, JSObject *obj, jsid id, JSObject *onBehalfOf, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeleteProperty(JSContext *cx, JSObject *obj, const char *name);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeleteProperty2(JSContext *cx, JSObject *obj, const char *name,
                    jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeletePropertyById(JSContext *cx, JSObject *obj, jsid id);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeletePropertyById2(JSContext *cx, JSObject *obj, jsid id, jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineUCProperty(JSContext *cx, JSObject *obj,
                     const jschar *name, size_t namelen, jsval value,
                     JSPropertyOp getter, JSStrictPropertyOp setter,
                     unsigned attrs);
 
 /*
  * Determine the attributes (JSPROP_* flags) of a property on a given object.
  *
  * If the object does not have a property by that name, *foundp will be
  * JS_FALSE and the value of *attrsp is undefined.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetUCPropertyAttributes(JSContext *cx, JSObject *obj,
                            const jschar *name, size_t namelen,
                            unsigned *attrsp, JSBool *foundp);
 
 /*
  * The same, but if the property is native, return its getter and setter via
  * *getterp and *setterp, respectively (and only if the out parameter pointer
  * is not null).
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetUCPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
                                      const jschar *name, size_t namelen,
                                      unsigned *attrsp, JSBool *foundp,
                                      JSPropertyOp *getterp,
                                      JSStrictPropertyOp *setterp);
 
 /*
  * Set the attributes of a property on a given object.
  *
  * If the object does not have a property by that name, *foundp will be
  * JS_FALSE and nothing will be altered.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetUCPropertyAttributes(JSContext *cx, JSObject *obj,
                            const jschar *name, size_t namelen,
                            unsigned attrs, JSBool *foundp);
 
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineUCPropertyWithTinyId(JSContext *cx, JSObject *obj,
                               const jschar *name, size_t namelen,
                               int8_t tinyid, jsval value,
                               JSPropertyOp getter, JSStrictPropertyOp setter,
                               unsigned attrs);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AlreadyHasOwnUCProperty(JSContext *cx, JSObject *obj, const jschar *name,
                            size_t namelen, JSBool *foundp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_HasUCProperty(JSContext *cx, JSObject *obj,
                  const jschar *name, size_t namelen,
                  JSBool *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_LookupUCProperty(JSContext *cx, JSObject *obj,
                     const jschar *name, size_t namelen,
                     jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetUCProperty(JSContext *cx, JSObject *obj,
                  const jschar *name, size_t namelen,
                  jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetUCProperty(JSContext *cx, JSObject *obj,
                  const jschar *name, size_t namelen,
                  jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeleteUCProperty2(JSContext *cx, JSObject *obj,
                      const jschar *name, size_t namelen,
                      jsval *rval);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewArrayObject(JSContext *cx, int length, jsval *vector);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsArrayObject(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetArrayLength(JSContext *cx, JSObject *obj, uint32_t *lengthp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetArrayLength(JSContext *cx, JSObject *obj, uint32_t length);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineElement(JSContext *cx, JSObject *obj, uint32_t index, jsval value,
                  JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AlreadyHasOwnElement(JSContext *cx, JSObject *obj, uint32_t index, JSBool *foundp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_HasElement(JSContext *cx, JSObject *obj, uint32_t index, JSBool *foundp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_LookupElement(JSContext *cx, JSObject *obj, uint32_t index, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetElement(JSContext *cx, JSObject *obj, uint32_t index, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ForwardGetElementTo(JSContext *cx, JSObject *obj, uint32_t index, JSObject *onBehalfOf,
                        jsval *vp);
 
 /*
  * Get the property with name given by |index|, if it has one.  If
  * not, |*present| will be set to false and the value of |vp| must not
  * be relied on.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetElementIfPresent(JSContext *cx, JSObject *obj, uint32_t index, JSObject *onBehalfOf,
                        jsval *vp, JSBool* present);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetElement(JSContext *cx, JSObject *obj, uint32_t index, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeleteElement(JSContext *cx, JSObject *obj, uint32_t index);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DeleteElement2(JSContext *cx, JSObject *obj, uint32_t index, jsval *rval);
 
 /*
  * Remove all configurable properties from the given (non-global) object and
  * assign undefined to all writable data properties.
  */
 JS_PUBLIC_API(void)
 JS_ClearNonGlobalObject(JSContext *cx, JSObject *objArg);
@@ -3645,88 +3647,88 @@ JS_PUBLIC_API(void)
 JS_SetAllNonReservedSlotsToUndefined(JSContext *cx, JSObject *objArg);
 
 /*
  * Create a new array buffer with the given contents, which must have been
  * returned by JS_AllocateArrayBufferContents or JS_StealArrayBufferContents.
  * The new array buffer takes ownership. After calling this function, do not
  * free |contents| or use |contents| from another thread.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewArrayBufferWithContents(JSContext *cx, void *contents);
 
 /*
  * Steal the contents of the given array buffer. The array buffer has its
  * length set to 0 and its contents array cleared. The caller takes ownership
  * of |*contents| and must free it or transfer ownership via
  * JS_NewArrayBufferWithContents when done using it.
  * To free |*contents|, call free().
  * A pointer to the buffer's data is returned in |*data|. This pointer can
  * be used until |*contents| is freed or has its ownership transferred.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_StealArrayBufferContents(JSContext *cx, JSObject *obj, void **contents,
                             uint8_t **data);
 
 /*
  * Allocate memory that may be eventually passed to
  * JS_NewArrayBufferWithContents. |nbytes| is the number of payload bytes
  * required. The pointer to pass to JS_NewArrayBufferWithContents is returned
  * in |contents|. The pointer to the |nbytes| of usable memory is returned in
  * |data|. (*|contents| will contain a header before |data|.) The only legal
  * operations on *|contents| is to free it, or pass it to
  * JS_NewArrayBufferWithContents or JS_ReallocateArrayBufferContents.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_AllocateArrayBufferContents(JSContext *cx, uint32_t nbytes, void **contents, uint8_t **data);
 
 /*
  * Reallocate memory allocated by JS_AllocateArrayBufferContents, growing or shrinking it
  * as appropriate.  The new data pointer will be returned in data.  If *contents is NULL,
  * behaves like JS_AllocateArrayBufferContents.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ReallocateArrayBufferContents(JSContext *cx, uint32_t nbytes, void **contents, uint8_t **data);
 
-extern JS_PUBLIC_API(JSIdArray *)
+extern "C" JS_PUBLIC_API(JSIdArray *)
 JS_Enumerate(JSContext *cx, JSObject *obj);
 
 /*
  * Create an object to iterate over enumerable properties of obj, in arbitrary
  * property definition order.  NB: This differs from longstanding for..in loop
  * order, which uses order of property definition in obj.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewPropertyIterator(JSContext *cx, JSObject *obj);
 
 /*
  * Return true on success with *idp containing the id of the next enumerable
  * property to visit using iterobj, or JSID_IS_VOID if there is no such property
  * left to visit.  Return false on error.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_NextProperty(JSContext *cx, JSObject *iterobj, jsid *idp);
 
 /*
  * A JSNative that creates and returns a new iterator that iterates over the
  * elements of |this|, up to |this.length|, in index order. This can be used to
  * make any array-like object iterable. Just give the object an obj.iterator()
  * method using this JSNative as the implementation.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ArrayIterator(JSContext *cx, unsigned argc, jsval *vp);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
                jsval *vp, unsigned *attrsp);
 
-extern JS_PUBLIC_API(jsval)
+extern "C" JS_PUBLIC_API(jsval)
 JS_GetReservedSlot(JSObject *obj, uint32_t index);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetReservedSlot(JSObject *obj, uint32_t index, jsval v);
 
 /************************************************************************/
 
 /*
  * Security protocol.
  */
 struct JSPrincipals {
@@ -3746,200 +3748,200 @@ struct JSPrincipals {
 
     /*
      * This is not defined by the JS engine but should be provided by the
      * embedding.
      */
     JS_PUBLIC_API(void) dump();
 };
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_HoldPrincipals(JSPrincipals *principals);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DropPrincipals(JSRuntime *rt, JSPrincipals *principals);
 
 struct JSSecurityCallbacks {
     JSCheckAccessOp            checkObjectAccess;
     JSCSPEvalChecker           contentSecurityPolicyAllows;
 };
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetSecurityCallbacks(JSRuntime *rt, const JSSecurityCallbacks *callbacks);
 
-extern JS_PUBLIC_API(const JSSecurityCallbacks *)
+extern "C" JS_PUBLIC_API(const JSSecurityCallbacks *)
 JS_GetSecurityCallbacks(JSRuntime *rt);
 
 /*
  * Code running with "trusted" principals will be given a deeper stack
  * allocation than ordinary scripts. This allows trusted script to run after
  * untrusted script has exhausted the stack. This function sets the
  * runtime-wide trusted principal.
  *
  * This principals is not held (via JS_HoldPrincipals/JS_DropPrincipals) since
  * there is no available JSContext. Instead, the caller must ensure that the
  * given principals stays valid for as long as 'rt' may point to it. If the
  * principals would be destroyed before 'rt', JS_SetTrustedPrincipals must be
  * called again, passing NULL for 'prin'.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetTrustedPrincipals(JSRuntime *rt, JSPrincipals *prin);
 
 /*
  * Initialize the callback that is called to destroy JSPrincipals instance
  * when its reference counter drops to zero. The initialization can be done
  * only once per JS runtime.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_InitDestroyPrincipalsCallback(JSRuntime *rt, JSDestroyPrincipalsOp destroyPrincipals);
 
 /************************************************************************/
 
 /*
  * Functions and scripts.
  */
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_NewFunction(JSContext *cx, JSNative call, unsigned nargs, unsigned flags,
                JSObject *parent, const char *name);
 
 /*
  * Create the function with the name given by the id. JSID_IS_STRING(id) must
  * be true.
  */
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_NewFunctionById(JSContext *cx, JSNative call, unsigned nargs, unsigned flags,
                    JSObject *parent, jsid id);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetFunctionObject(JSFunction *fun);
 
 /*
  * Return the function's identifier as a JSString, or null if fun is unnamed.
  * The returned string lives as long as fun, so you don't need to root a saved
  * reference to it if fun is well-connected or rooted, and provided you bound
  * the use of the saved reference by fun's lifetime.
  */
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_GetFunctionId(JSFunction *fun);
 
 /*
  * Return a function's display name. This is the defined name if one was given
  * where the function was defined, or it could be an inferred name by the JS
  * engine in the case that the function was defined to be anonymous. This can
  * still return NULL if a useful display name could not be inferred. The same
  * restrictions on rooting as those in JS_GetFunctionId apply.
  */
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_GetFunctionDisplayId(JSFunction *fun);
 
 /*
  * Return the arity (length) of fun.
  */
-extern JS_PUBLIC_API(uint16_t)
+extern "C" JS_PUBLIC_API(uint16_t)
 JS_GetFunctionArity(JSFunction *fun);
 
 /*
  * Infallible predicate to test whether obj is a function object (faster than
  * comparing obj's class name to "Function", but equivalent unless someone has
  * overwritten the "Function" identifier with a different constructor and then
  * created instances using that constructor that might be passed in as obj).
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ObjectIsFunction(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ObjectIsCallable(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsNativeFunction(JSObject *funobj, JSNative call);
 
 /* Return whether the given function is a valid constructor. */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsConstructor(JSFunction *fun);
 
 /*
  * Bind the given callable to use the given object as "this".
  *
  * If |callable| is not callable, will throw and return NULL.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_BindCallable(JSContext *cx, JSObject *callable, JSObject *newThis);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineFunctions(JSContext *cx, JSObject *obj, const JSFunctionSpec *fs);
 
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_DefineFunction(JSContext *cx, JSObject *obj, const char *name, JSNative call,
                   unsigned nargs, unsigned attrs);
 
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_DefineUCFunction(JSContext *cx, JSObject *obj,
                     const jschar *name, size_t namelen, JSNative call,
                     unsigned nargs, unsigned attrs);
 
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_DefineFunctionById(JSContext *cx, JSObject *obj, jsid id, JSNative call,
                       unsigned nargs, unsigned attrs);
 
 /*
  * Clone a top-level function into a new scope. This function will dynamically
  * fail if funobj was lexically nested inside some other function.
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_CloneFunctionObject(JSContext *cx, JSObject *funobj, JSObject *parent);
 
 /*
  * Given a buffer, return JS_FALSE if the buffer might become a valid
  * javascript statement with the addition of more lines.  Otherwise return
  * JS_TRUE.  The intent is to support interactive compilation - accumulate
  * lines in a buffer until JS_BufferIsCompilableUnit is true, then pass it to
  * the compiler.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_BufferIsCompilableUnit(JSContext *cx, JSObject *obj, const char *utf8, size_t length);
 
-extern JS_PUBLIC_API(JSScript *)
+extern "C" JS_PUBLIC_API(JSScript *)
 JS_CompileScript(JSContext *cx, JSObject *obj,
                  const char *ascii, size_t length,
                  const char *filename, unsigned lineno);
 
-extern JS_PUBLIC_API(JSScript *)
+extern "C" JS_PUBLIC_API(JSScript *)
 JS_CompileScriptForPrincipals(JSContext *cx, JSObject *obj,
                               JSPrincipals *principals,
                               const char *ascii, size_t length,
                               const char *filename, unsigned lineno);
 
-extern JS_PUBLIC_API(JSScript *)
+extern "C" JS_PUBLIC_API(JSScript *)
 JS_CompileUCScript(JSContext *cx, JSObject *obj,
                    const jschar *chars, size_t length,
                    const char *filename, unsigned lineno);
 
-extern JS_PUBLIC_API(JSScript *)
+extern "C" JS_PUBLIC_API(JSScript *)
 JS_CompileUCScriptForPrincipals(JSContext *cx, JSObject *obj,
                                 JSPrincipals *principals,
                                 const jschar *chars, size_t length,
                                 const char *filename, unsigned lineno);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetGlobalFromScript(JSScript *script);
 
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_CompileFunction(JSContext *cx, JSObject *obj, const char *name,
                    unsigned nargs, const char **argnames,
                    const char *bytes, size_t length,
                    const char *filename, unsigned lineno);
 
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_CompileFunctionForPrincipals(JSContext *cx, JSObject *obj,
                                 JSPrincipals *principals, const char *name,
                                 unsigned nargs, const char **argnames,
                                 const char *bytes, size_t length,
                                 const char *filename, unsigned lineno);
 
-extern JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_CompileUCFunction(JSContext *cx, JSObject *obj, const char *name,
                      unsigned nargs, const char **argnames,
                      const jschar *chars, size_t length,
                      const char *filename, unsigned lineno);
 
 namespace JS {
 
 /* Options for JavaScript compilation. */
@@ -4003,29 +4005,29 @@ CompileFunction(JSContext *cx, JS::Handl
 
 extern JS_PUBLIC_API(JSFunction *)
 CompileFunction(JSContext *cx, JS::Handle<JSObject*> obj, CompileOptions options,
                 const char *name, unsigned nargs, const char **argnames,
                 const jschar *chars, size_t length);
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_DecompileScript(JSContext *cx, JSScript *script, const char *name, unsigned indent);
 
 /*
  * API extension: OR this into indent to avoid pretty-printing the decompiled
  * source resulting from JS_DecompileFunction{,Body}.
  */
 #define JS_DONT_PRETTY_PRINT    ((unsigned)0x8000)
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_DecompileFunction(JSContext *cx, JSFunction *fun, unsigned indent);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_DecompileFunctionBody(JSContext *cx, JSFunction *fun, unsigned indent);
 
 /*
  * NB: JS_ExecuteScript and the JS_Evaluate*Script* quadruplets use the obj
  * parameter as the initial scope chain header, the 'this' keyword value, and
  * the variables object (ECMA parlance for where 'var' and 'function' bind
  * names) of the execution context for script.
  *
@@ -4053,78 +4055,78 @@ JS_DecompileFunctionBody(JSContext *cx, 
  * Why a runtime option?  The alternative is to add six or so new API entry
  * points with signatures matching the following six, and that doesn't seem
  * worth the code bloat cost.  Such new entry points would probably have less
  * obvious names, too, so would not tend to be used.  The JS_SetOption call,
  * OTOH, can be more easily hacked into existing code that does not depend on
  * the bug; such code can continue to use the familiar JS_EvaluateScript,
  * etc., entry points.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ExecuteScript(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ExecuteScriptVersion(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval,
                         JSVersion version);
 
 /*
  * Execute either the function-defining prolog of a script, or the script's
  * main body, but not both.
  */
 typedef enum JSExecPart { JSEXEC_PROLOG, JSEXEC_MAIN } JSExecPart;
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EvaluateScript(JSContext *cx, JSObject *obj,
                   const char *bytes, unsigned length,
                   const char *filename, unsigned lineno,
                   jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EvaluateScriptForPrincipals(JSContext *cx, JSObject *obj,
                                JSPrincipals *principals,
                                const char *bytes, unsigned length,
                                const char *filename, unsigned lineno,
                                jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EvaluateScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
                                       JSPrincipals *principals,
                                       const char *bytes, unsigned length,
                                       const char *filename, unsigned lineno,
                                       jsval *rval, JSVersion version);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EvaluateUCScript(JSContext *cx, JSObject *obj,
                     const jschar *chars, unsigned length,
                     const char *filename, unsigned lineno,
                     jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EvaluateUCScriptForPrincipals(JSContext *cx, JSObject *obj,
                                  JSPrincipals *principals,
                                  const jschar *chars, unsigned length,
                                  const char *filename, unsigned lineno,
                                  jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EvaluateUCScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
                                         JSPrincipals *principals,
                                         const jschar *chars, unsigned length,
                                         const char *filename, unsigned lineno,
                                         jsval *rval, JSVersion version);
 
 /*
  * JSAPI clients may optionally specify the 'originPrincipals' of a script.
  * A script's originPrincipals may be retrieved through the debug API (via
  * JS_GetScriptOriginPrincipals) and the originPrincipals are transitively
  * assigned to any nested scripts (including scripts dynamically created via
  * eval and the Function constructor). If originPrincipals is null, then the
  * value of principals is used as origin principals for the script.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_EvaluateUCScriptForPrincipalsVersionOrigin(JSContext *cx, JSObject *obj,
                                               JSPrincipals *principals,
                                               JSPrincipals *originPrincipals,
                                               const jschar *chars, unsigned length,
                                               const char *filename, unsigned lineno,
                                               jsval *rval, JSVersion version);
 
 namespace JS {
@@ -4138,25 +4140,25 @@ Evaluate(JSContext *cx, JS::Handle<JSObj
          const char *bytes, size_t length, jsval *rval);
 
 extern JS_PUBLIC_API(bool)
 Evaluate(JSContext *cx, JS::Handle<JSObject*> obj, CompileOptions options,
          const char *filename, jsval *rval);
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_CallFunction(JSContext *cx, JSObject *obj, JSFunction *fun, unsigned argc,
                 jsval *argv, jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_CallFunctionName(JSContext *cx, JSObject *obj, const char *name, unsigned argc,
                     jsval *argv, jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_CallFunctionValue(JSContext *cx, JSObject *obj, jsval fval, unsigned argc,
                      jsval *argv, jsval *rval);
 
 namespace JS {
 
 static inline bool
 Call(JSContext *cx, JSObject *thisObj, JSFunction *fun, unsigned argc, jsval *argv, jsval *rval) {
     return !!JS_CallFunction(cx, thisObj, fun, argc, argv, rval);
@@ -4167,17 +4169,17 @@ Call(JSContext *cx, JSObject *thisObj, c
     return !!JS_CallFunctionName(cx, thisObj, name, argc, argv, rval);
 }
 
 static inline bool
 Call(JSContext *cx, JSObject *thisObj, jsval fun, unsigned argc, jsval *argv, jsval *rval) {
     return !!JS_CallFunctionValue(cx, thisObj, fun, argc, argv, rval);
 }
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 Call(JSContext *cx, jsval thisv, jsval fun, unsigned argc, jsval *argv, jsval *rval);
 
 static inline bool
 Call(JSContext *cx, jsval thisv, JSObject *funObj, unsigned argc, jsval *argv, jsval *rval) {
     return Call(cx, thisv, OBJECT_TO_JSVAL(funObj), argc, argv, rval);
 }
 
 } /* namespace JS */
@@ -4190,113 +4192,113 @@ Call(JSContext *cx, jsval thisv, JSObjec
  * To schedule the GC and for other activities the engine internally triggers
  * operation callbacks. The embedding should thus not rely on callbacks being
  * triggered through the external API only.
  *
  * Important note: Additional callbacks can occur inside the callback handler
  * if it re-enters the JS engine. The embedding must ensure that the callback
  * is disconnected before attempting such re-entry.
  */
-extern JS_PUBLIC_API(JSOperationCallback)
+extern "C" JS_PUBLIC_API(JSOperationCallback)
 JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback);
 
-extern JS_PUBLIC_API(JSOperationCallback)
+extern "C" JS_PUBLIC_API(JSOperationCallback)
 JS_GetOperationCallback(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_TriggerOperationCallback(JSRuntime *rt);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsRunning(JSContext *cx);
 
 /*
  * Saving and restoring frame chains.
  *
  * These two functions are used to set aside cx's call stack while that stack
  * is inactive. After a call to JS_SaveFrameChain, it looks as if there is no
  * code running on cx. Before calling JS_RestoreFrameChain, cx's call stack
  * must be balanced and all nested calls to JS_SaveFrameChain must have had
  * matching JS_RestoreFrameChain calls.
  *
  * JS_SaveFrameChain deals with cx not having any code running on it.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SaveFrameChain(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RestoreFrameChain(JSContext *cx);
 
 #ifdef MOZ_TRACE_JSCALLS
 /*
  * The callback is expected to be quick and noninvasive. It should not
  * trigger interrupts, turn on debugging, or produce uncaught JS
  * exceptions. The state of the stack and registers in the context
  * cannot be relied upon, since this callback may be invoked directly
  * from either JIT. The 'entering' field means we are entering a
  * function if it is positive, leaving a function if it is zero or
  * negative.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetFunctionCallback(JSContext *cx, JSFunctionCallback fcb);
 
-extern JS_PUBLIC_API(JSFunctionCallback)
+extern "C" JS_PUBLIC_API(JSFunctionCallback)
 JS_GetFunctionCallback(JSContext *cx);
 #endif /* MOZ_TRACE_JSCALLS */
 
 /************************************************************************/
 
 /*
  * Strings.
  *
  * NB: JS_NewUCString takes ownership of bytes on success, avoiding a copy;
  * but on error (signified by null return), it leaves chars owned by the
  * caller. So the caller must free bytes in the error case, if it has no use
  * for them. In contrast, all the JS_New*StringCopy* functions do not take
  * ownership of the character memory passed to them -- they copy it.
  */
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_NewStringCopyN(JSContext *cx, const char *s, size_t n);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_NewStringCopyZ(JSContext *cx, const char *s);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_InternJSString(JSContext *cx, JSString *str);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_InternStringN(JSContext *cx, const char *s, size_t length);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_InternString(JSContext *cx, const char *s);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_NewUCString(JSContext *cx, jschar *chars, size_t length);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_NewUCStringCopyN(JSContext *cx, const jschar *s, size_t n);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_NewUCStringCopyZ(JSContext *cx, const jschar *s);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_InternUCStringN(JSContext *cx, const jschar *s, size_t length);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_InternUCString(JSContext *cx, const jschar *s);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_CompareStrings(JSContext *cx, JSString *str1, JSString *str2, int32_t *result);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_StringEqualsAscii(JSContext *cx, JSString *str, const char *asciiBytes, JSBool *match);
 
-extern JS_PUBLIC_API(size_t)
+extern "C" JS_PUBLIC_API(size_t)
 JS_PutEscapedString(JSContext *cx, char *buffer, size_t size, JSString *str, char quote);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_FileEscapedString(FILE *fp, JSString *str, char quote);
 
 /*
  * Extracting string characters and length.
  *
  * While getting the length of a string is infallible, getting the chars can
  * fail. As indicated by the lack of a JSContext parameter, there are two
  * special cases where getting the chars is infallible:
@@ -4324,38 +4326,38 @@ JS_FileEscapedString(FILE *fp, JSString 
  *
  * The CharsZ APIs guarantee that the returned array has a null character at
  * chars[length]. This can require additional copying so clients should prefer
  * APIs without CharsZ if possible. The infallible functions also return
  * null-terminated arrays. (There is no additional cost or non-Z alternative
  * for the infallible functions, so 'Z' is left out of the identifier.)
  */
 
-extern JS_PUBLIC_API(size_t)
+extern "C" JS_PUBLIC_API(size_t)
 JS_GetStringLength(JSString *str);
 
-extern JS_PUBLIC_API(const jschar *)
+extern "C" JS_PUBLIC_API(const jschar *)
 JS_GetStringCharsAndLength(JSContext *cx, JSString *str, size_t *length);
 
-extern JS_PUBLIC_API(const jschar *)
+extern "C" JS_PUBLIC_API(const jschar *)
 JS_GetInternedStringChars(JSString *str);
 
-extern JS_PUBLIC_API(const jschar *)
+extern "C" JS_PUBLIC_API(const jschar *)
 JS_GetInternedStringCharsAndLength(JSString *str, size_t *length);
 
-extern JS_PUBLIC_API(const jschar *)
+extern "C" JS_PUBLIC_API(const jschar *)
 JS_GetStringCharsZ(JSContext *cx, JSString *str);
 
-extern JS_PUBLIC_API(const jschar *)
+extern "C" JS_PUBLIC_API(const jschar *)
 JS_GetStringCharsZAndLength(JSContext *cx, JSString *str, size_t *length);
 
-extern JS_PUBLIC_API(JSFlatString *)
+extern "C" JS_PUBLIC_API(JSFlatString *)
 JS_FlattenString(JSContext *cx, JSString *str);
 
-extern JS_PUBLIC_API(const jschar *)
+extern "C" JS_PUBLIC_API(const jschar *)
 JS_GetFlatStringChars(JSFlatString *str);
 
 static JS_ALWAYS_INLINE JSFlatString *
 JSID_TO_FLAT_STRING(jsid id)
 {
     JS_ASSERT(JSID_IS_STRING(id));
     return (JSFlatString *)(JSID_BITS(id));
 }
@@ -4372,43 +4374,43 @@ JS_FORGET_STRING_FLATNESS(JSFlatString *
 {
     return (JSString *)fstr;
 }
 
 /*
  * Additional APIs that avoid fallibility when given a flat string.
  */
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_FlatStringEqualsAscii(JSFlatString *str, const char *asciiBytes);
 
-extern JS_PUBLIC_API(size_t)
+extern "C" JS_PUBLIC_API(size_t)
 JS_PutEscapedFlatString(char *buffer, size_t size, JSFlatString *str, char quote);
 
 /*
  * This function is now obsolete and behaves the same as JS_NewUCString.  Use
  * JS_NewUCString instead.
  */
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_NewGrowableString(JSContext *cx, jschar *chars, size_t length);
 
 /*
  * Create a dependent string, i.e., a string that owns no character storage,
  * but that refers to a slice of another string's chars.  Dependent strings
  * are mutable by definition, so the thread safety comments above apply.
  */
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_NewDependentString(JSContext *cx, JSString *str, size_t start,
                       size_t length);
 
 /*
  * Concatenate two strings, possibly resulting in a rope.
  * See above for thread safety comments.
  */
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_ConcatStrings(JSContext *cx, JSString *left, JSString *right);
 
 /*
  * For JS_DecodeBytes, set *dstlenp to the size of the destination buffer before
  * the call; on return, *dstlenp contains the number of jschars actually stored.
  * To determine the necessary destination buffer size, make a sizing call that
  * passes NULL for dst.
  *
@@ -4528,30 +4530,30 @@ class JSAutoByteString
 /*
  * JSON functions
  */
 typedef JSBool (* JSONWriteCallback)(const jschar *buf, uint32_t len, void *data);
 
 /*
  * JSON.stringify as specified by ES5.
  */
-JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_Stringify(JSContext *cx, jsval *vp, JSObject *replacer, jsval space,
              JSONWriteCallback callback, void *data);
 
 /*
  * JSON.parse as specified by ES5.
  */
-JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ParseJSON(JSContext *cx, const jschar *chars, uint32_t len, JS::MutableHandle<JS::Value> vp);
 
 JS_PUBLIC_API(JSBool)
 JS_ParseJSONWithReviver(JSContext *cx, const jschar *chars, uint32_t len, jsval reviver,
                         jsval *vp);
-
+					
 /************************************************************************/
 
 /* API for the HTML5 internal structured cloning algorithm. */
 
 /* The maximum supported structured-clone serialization format version. */
 #define JS_STRUCTURED_CLONE_VERSION 2
 
 struct JSStructuredCloneCallbacks {
@@ -4679,23 +4681,23 @@ JS_WriteTypedArray(JSStructuredCloneWrit
 
 /*
  * The default locale for the ECMAScript Internationalization API
  * (Intl.Collator, Intl.NumberFormat, Intl.DateTimeFormat).
  * Note that the Internationalization API encourages clients to
  * specify their own locales.
  * The locale string remains owned by the caller.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetDefaultLocale(JSRuntime *rt, const char *locale);
 
 /*
  * Reset the default locale to OS defaults.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ResetDefaultLocale(JSRuntime *rt);
 
 /*
  * Locale specific string conversion and error message callbacks.
  */
 struct JSLocaleCallbacks {
     JSLocaleToUpperCase     localeToUpperCase;
     JSLocaleToLowerCase     localeToLowerCase;
@@ -4703,94 +4705,94 @@ struct JSLocaleCallbacks {
     JSLocaleToUnicode       localeToUnicode;
     JSErrorCallback         localeGetErrorMessage;
 };
 
 /*
  * Establish locale callbacks. The pointer must persist as long as the
  * JSRuntime.  Passing NULL restores the default behaviour.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetLocaleCallbacks(JSRuntime *rt, JSLocaleCallbacks *callbacks);
 
 /*
  * Return the address of the current locale callbacks struct, which may
  * be NULL.
  */
-extern JS_PUBLIC_API(JSLocaleCallbacks *)
+extern "C" JS_PUBLIC_API(JSLocaleCallbacks *)
 JS_GetLocaleCallbacks(JSRuntime *rt);
 
 /************************************************************************/
 
 /*
  * Error reporting.
  */
 
 /*
  * Report an exception represented by the sprintf-like conversion of format
  * and its arguments.  This exception message string is passed to a pre-set
  * JSErrorReporter function (set by JS_SetErrorReporter).
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportError(JSContext *cx, const char *format, ...);
 
 /*
  * Use an errorNumber to retrieve the format string, args are char *
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumber(JSContext *cx, JSErrorCallback errorCallback,
                      void *userRef, const unsigned errorNumber, ...);
 
 #ifdef va_start
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberVA(JSContext *cx, JSErrorCallback errorCallback,
                        void *userRef, const unsigned errorNumber, va_list ap);
 #endif
 
 /*
  * Use an errorNumber to retrieve the format string, args are jschar *
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberUC(JSContext *cx, JSErrorCallback errorCallback,
                      void *userRef, const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberUCArray(JSContext *cx, JSErrorCallback errorCallback,
                             void *userRef, const unsigned errorNumber,
                             const jschar **args);
 
 /*
  * As above, but report a warning instead (JSREPORT_IS_WARNING(report.flags)).
  * Return true if there was no error trying to issue the warning, and if the
  * warning was not converted into an error due to the JSOPTION_WERROR option
  * being set, false otherwise.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ReportWarning(JSContext *cx, const char *format, ...);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ReportErrorFlagsAndNumber(JSContext *cx, unsigned flags,
                              JSErrorCallback errorCallback, void *userRef,
                              const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ReportErrorFlagsAndNumberUC(JSContext *cx, unsigned flags,
                                JSErrorCallback errorCallback, void *userRef,
                                const unsigned errorNumber, ...);
 
 /*
  * Complain when out of memory.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportOutOfMemory(JSContext *cx);
 
 /*
  * Complain when an allocation size overflows the maximum supported limit.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportAllocationOverflow(JSContext *cx);
 
 struct JSErrorReport {
     const char      *filename;      /* source file name, URL, etc., or null */
     JSPrincipals    *originPrincipals; /* see 'originPrincipals' comment above */
     unsigned        lineno;         /* source line number */
     const char      *linebuf;       /* offending source line without final \n */
     const char      *tokenptr;      /* pointer to error token in linebuf */
@@ -4828,156 +4830,156 @@ struct JSErrorReport {
  * JS_ExecuteScript returns failure, and signal or propagate the exception, as
  * appropriate.
  */
 #define JSREPORT_IS_WARNING(flags)      (((flags) & JSREPORT_WARNING) != 0)
 #define JSREPORT_IS_EXCEPTION(flags)    (((flags) & JSREPORT_EXCEPTION) != 0)
 #define JSREPORT_IS_STRICT(flags)       (((flags) & JSREPORT_STRICT) != 0)
 #define JSREPORT_IS_STRICT_MODE_ERROR(flags) (((flags) &                      \
                                               JSREPORT_STRICT_MODE_ERROR) != 0)
-extern JS_PUBLIC_API(JSErrorReporter)
+extern "C" JS_PUBLIC_API(JSErrorReporter)
 JS_GetErrorReporter(JSContext *cx);
 
-extern JS_PUBLIC_API(JSErrorReporter)
+extern "C" JS_PUBLIC_API(JSErrorReporter)
 JS_SetErrorReporter(JSContext *cx, JSErrorReporter er);
 
 /************************************************************************/
 
 /*
  * Dates.
  */
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewDateObject(JSContext *cx, int year, int mon, int mday, int hour, int min, int sec);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewDateObjectMsec(JSContext *cx, double msec);
 
 /*
  * Infallible predicate to test whether obj is a date object.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ObjectIsDate(JSContext *cx, JSObject *obj);
 
 /*
  * Clears the cache of calculated local time from each Date object.
  * Call to propagate a system timezone change.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ClearDateCaches(JSContext *cx);
 
 /************************************************************************/
 
 /*
  * Regular Expressions.
  */
 #define JSREG_FOLD      0x01    /* fold uppercase to lowercase */
 #define JSREG_GLOB      0x02    /* global exec, creates array of matches */
 #define JSREG_MULTILINE 0x04    /* treat ^ and $ as begin and end of line */
 #define JSREG_STICKY    0x08    /* only match starting at lastIndex */
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewRegExpObject(JSContext *cx, JSObject *obj, char *bytes, size_t length, unsigned flags);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewUCRegExpObject(JSContext *cx, JSObject *obj, jschar *chars, size_t length, unsigned flags);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetRegExpInput(JSContext *cx, JSObject *obj, JSString *input, JSBool multiline);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ClearRegExpStatics(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ExecuteRegExp(JSContext *cx, JSObject *obj, JSObject *reobj, jschar *chars, size_t length,
                  size_t *indexp, JSBool test, jsval *rval);
 
 /* RegExp interface for clients without a global object. */
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewRegExpObjectNoStatics(JSContext *cx, char *bytes, size_t length, unsigned flags);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewUCRegExpObjectNoStatics(JSContext *cx, jschar *chars, size_t length, unsigned flags);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ExecuteRegExpNoStatics(JSContext *cx, JSObject *reobj, jschar *chars, size_t length,
                           size_t *indexp, JSBool test, jsval *rval);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ObjectIsRegExp(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(unsigned)
+extern "C" JS_PUBLIC_API(unsigned)
 JS_GetRegExpFlags(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_GetRegExpSource(JSContext *cx, JSObject *obj);
 
 /************************************************************************/
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsExceptionPending(JSContext *cx);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPendingException(JSContext *cx, jsval *vp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetPendingException(JSContext *cx, jsval v);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ClearPendingException(JSContext *cx);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ReportPendingException(JSContext *cx);
 
 /*
  * Save the current exception state.  This takes a snapshot of cx's current
  * exception state without making any change to that state.
  *
  * The returned state pointer MUST be passed later to JS_RestoreExceptionState
  * (to restore that saved state, overriding any more recent state) or else to
  * JS_DropExceptionState (to free the state struct in case it is not correct
  * or desirable to restore it).  Both Restore and Drop free the state struct,
  * so callers must stop using the pointer returned from Save after calling the
  * Release or Drop API.
  */
-extern JS_PUBLIC_API(JSExceptionState *)
+extern "C" JS_PUBLIC_API(JSExceptionState *)
 JS_SaveExceptionState(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RestoreExceptionState(JSContext *cx, JSExceptionState *state);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DropExceptionState(JSContext *cx, JSExceptionState *state);
 
 /*
  * If the given value is an exception object that originated from an error,
  * the exception will contain an error report struct, and this API will return
  * the address of that struct.  Otherwise, it returns NULL.  The lifetime of
  * the error report struct that might be returned is the same as the lifetime
  * of the exception object.
  */
-extern JS_PUBLIC_API(JSErrorReport *)
+extern "C" JS_PUBLIC_API(JSErrorReport *)
 JS_ErrorFromException(JSContext *cx, jsval v);
 
 /*
  * Given a reported error's message and JSErrorReport struct pointer, throw
  * the corresponding exception on cx.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ThrowReportedError(JSContext *cx, const char *message,
                       JSErrorReport *reportp);
 
 /*
  * Throws a StopIteration exception on cx.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ThrowStopIteration(JSContext *cx);
 
-extern JS_PUBLIC_API(intptr_t)
+extern "C" JS_PUBLIC_API(intptr_t)
 JS_GetCurrentThread();
 
 /*
  * A JS runtime always has an "owner thread". The owner thread is set when the
  * runtime is created (to the current thread) and practically all entry points
  * into the JS engine check that a runtime (or anything contained in the
  * runtime: context, compartment, object, etc) is only touched by its owner
  * thread. Embeddings may check this invariant outside the JS engine by calling
@@ -4986,23 +4988,23 @@ JS_GetCurrentThread();
  *
  * It is possible to "move" a runtime between threads. This is accomplished by
  * calling JS_ClearRuntimeThread on a runtime's owner thread and then calling
  * JS_SetRuntimeThread on the new owner thread. The runtime must not be
  * accessed between JS_ClearRuntimeThread and JS_SetRuntimeThread. Also, the
  * caller is responsible for synchronizing the calls to Set/Clear.
  */
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_AbortIfWrongThread(JSRuntime *rt);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ClearRuntimeThread(JSRuntime *rt);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetRuntimeThread(JSRuntime *rt);
 
 class JSAutoSetRuntimeThread
 {
     JSRuntime *runtime_;
 
   public:
     JSAutoSetRuntimeThread(JSRuntime *runtime) : runtime_(runtime) {
@@ -5041,86 +5043,86 @@ JS_IsConstructing(JSContext *cx, const j
     return JSVAL_IS_MAGIC_IMPL(JSVAL_TO_IMPL(vp[1]));
 }
 
 /*
  * A constructor can request that the JS engine create a default new 'this'
  * object of the given class, using the callee to determine parentage and
  * [[Prototype]].
  */
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_NewObjectForConstructor(JSContext *cx, JSClass *clasp, const jsval *vp);
 
 /************************************************************************/
 
 #ifdef JS_GC_ZEAL
 #define JS_DEFAULT_ZEAL_FREQ 100
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGCZeal(JSContext *cx, uint8_t zeal, uint32_t frequency);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ScheduleGC(JSContext *cx, uint32_t count);
 #endif
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetParallelCompilationEnabled(JSContext *cx, bool enabled);
 
 typedef enum JSCompilerOption {
     JSCOMPILER_BASELINE_USECOUNT_TRIGGER,
     JSCOMPILER_ION_USECOUNT_TRIGGER,
     JSCOMPILER_PJS_ENABLE
 } JSCompilerOption;
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGlobalCompilerOption(JSContext *cx, JSCompilerOption opt, uint32_t value);
 
 /*
  * Convert a uint32_t index into a jsid.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IndexToId(JSContext *cx, uint32_t index, jsid *id);
 
 /*
  * Convert chars into a jsid.
  *
  * |chars| may not be an index.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_CharsToId(JSContext* cx, JS::TwoByteChars chars, jsid *idp);
 
 /*
  *  Test if the given string is a valid ECMAScript identifier
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_IsIdentifier(JSContext *cx, JSString *str, JSBool *isIdentifier);
 
 /*
  * Return the current script and line number of the most currently running
  * frame. Returns true if a scripted frame was found, false otherwise.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DescribeScriptedCaller(JSContext *cx, JSScript **script, unsigned *lineno);
 
 
 /*
  * Encode/Decode interpreted scripts and functions to/from memory.
  */
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_EncodeScript(JSContext *cx, JSScript *script, uint32_t *lengthp);
 
-extern JS_PUBLIC_API(void *)
+extern "C" JS_PUBLIC_API(void *)
 JS_EncodeInterpretedFunction(JSContext *cx, JSObject *funobj, uint32_t *lengthp);
 
-extern JS_PUBLIC_API(JSScript *)
+extern "C" JS_PUBLIC_API(JSScript *)
 JS_DecodeScript(JSContext *cx, const void *data, uint32_t length,
                 JSPrincipals *principals, JSPrincipals *originPrincipals);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_DecodeInterpretedFunction(JSContext *cx, const void *data, uint32_t length,
                              JSPrincipals *principals, JSPrincipals *originPrincipals);
 
 namespace JS {
 
 extern JS_PUBLIC_DATA(const HandleValue) NullHandleValue;
 extern JS_PUBLIC_DATA(const HandleValue) UndefinedHandleValue;
 
diff --git a/js/src/jsdbgapi.cpp b/js/src/jsdbgapi.cpp
--- a/js/src/jsdbgapi.cpp
+++ b/js/src/jsdbgapi.cpp
@@ -579,16 +579,22 @@ JS_GetScriptFilename(JSContext *cx, JSSc
 JS_PUBLIC_API(const jschar *)
 JS_GetScriptSourceMap(JSContext *cx, JSScript *script)
 {
     ScriptSource *source = script->scriptSource();
     JS_ASSERT(source);
     return source->hasSourceMap() ? source->sourceMap() : NULL;
 }
 
+JS_PUBLIC_API(void *)
+JS_GetScriptSource(JSContext *cx, JSScript *script)
+{
+    return script->scriptSource();
+}
+
 JS_PUBLIC_API(unsigned)
 JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script)
 {
     return script->lineno;
 }
 
 JS_PUBLIC_API(unsigned)
 JS_GetScriptLineExtent(JSContext *cx, JSScript *script)
@@ -668,24 +674,24 @@ GetPropertyDesc(JSContext *cx, JSObject 
     pd->alias = JSVAL_VOID;
 
     return JS_TRUE;
 }
 
 JS_PUBLIC_API(JSBool)
 JS_GetPropertyDescArray(JSContext *cx, JSObject *obj_, JSPropertyDescArray *pda)
 {
-    RootedObject obj(cx, obj_);
+	RootedObject obj(cx, obj_);
 
     assertSameCompartment(cx, obj);
     uint32_t i = 0;
     JSPropertyDesc *pd = NULL;
 
-    if (obj->is<DebugScopeObject>()) {
-        AutoIdVector props(cx);
+	if (obj->is<DebugScopeObject>()) {
+		AutoIdVector props(cx);
         if (!Proxy::enumerate(cx, obj, props))
             return false;
 
         pd = cx->pod_calloc<JSPropertyDesc>(props.length());
         if (!pd)
             return false;
 
         for (i = 0; i < props.length(); ++i) {
@@ -698,29 +704,28 @@ JS_GetPropertyDescArray(JSContext *cx, J
                 goto bad;
             if (!Proxy::get(cx, obj, obj, props.handleAt(i), MutableHandleValue::fromMarkedLocation(&pd[i].value)))
                 goto bad;
         }
 
         pda->length = props.length();
         pda->array = pd;
         return true;
-    }
-
-    Class *clasp;
+    }else {
+/*    Class *clasp;
     clasp = obj->getClass();
     if (!obj->isNative() || (clasp->flags & JSCLASS_NEW_ENUMERATE)) {
         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
                              JSMSG_CANT_DESCRIBE_PROPS, clasp->name);
         return false;
-    }
-    if (!clasp->enumerate(cx, obj))
+    } 
+	if (!clasp->enumerate(cx, obj))
         return false;
 
-    /* Return an empty pda early if obj has no own properties. */
+    /* Return an empty pda early if obj has no own properties. * /
     if (obj->nativeEmpty()) {
         pda->length = 0;
         pda->array = NULL;
         return true;
     }
 
     pd = cx->pod_malloc<JSPropertyDesc>(obj->propertyCount());
     if (!pd)
@@ -745,17 +750,67 @@ JS_GetPropertyDescArray(JSContext *cx, J
             if (++i == obj->propertyCount())
                 break;
         }
     }
 
     pda->length = i;
     pda->array = pd;
     return true;
+*/
+///
+    AutoIdVector keys(cx);
+    if (!GetPropertyNames(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &keys))
+        return false; 
 
+    /* Return an empty pda early if obj has no own properties. */
+    if (keys.length()==0) {
+        pda->length = 0;
+        pda->array = NULL;
+        return true;
+    }
+
+    pd = cx->pod_malloc<JSPropertyDesc>(keys.length());
+    if (!pd)
+        return false;
+
+    {
+        for (i = 0; i < keys.length(); i++) {
+			pd[i].id = IdToJsval(keys[i]);
+
+			JSBool wasThrowing = cx->isExceptionPending();
+			RootedValue lastException(cx, UndefinedValue());
+			if (wasThrowing)
+				lastException = cx->getPendingException();
+			cx->clearPendingException();
+
+			Rooted<jsid> id(cx, keys[i]);
+			RootedValue value(cx);
+			if (!baseops::GetProperty(cx, obj, id, &value)) {
+				if (!cx->isExceptionPending()) {
+					pd[i].flags = JSPD_ERROR;
+					pd[i].value = JSVAL_VOID;
+				} else {
+					pd[i].flags = JSPD_EXCEPTION;
+					pd[i].value = cx->getPendingException();
+				}
+			} else {
+				pd[i].flags = 0;
+				pd[i].value = value;
+			}
+			if (wasThrowing)
+				cx->setPendingException(lastException);
+        }
+    }
+
+    pda->length = keys.length();
+    pda->array = pd;
+    return true;
+	}
+///
 bad:
     pda->length = i + 1;
     pda->array = pd;
     JS_PutPropertyDescArray(cx, pda);
     return false;
 }
 
 JS_PUBLIC_API(void)
@@ -985,16 +1040,66 @@ JS::DescribeStack(JSContext *cx, unsigne
 
 JS_PUBLIC_API(void)
 JS::FreeStackDescription(JSContext *cx, JS::StackDescription *desc)
 {
     js_delete(desc->frames);
     js_delete(desc);
 }
 
+JS_PUBLIC_API(JS::StackDescriptionEx *)
+JS::DescribeStackEx(JSContext *cx, unsigned maxFrames)
+{
+    Vector<FrameDescriptionEx> frames(cx);
+
+    for (NonBuiltinScriptFrameIter i(cx); !i.done(); ++i) {
+        FrameDescriptionEx desc;
+        desc.script = i.script();
+        desc.lineno = PCToLineNumber(i.script(), i.pc());
+        desc.fun = i.maybeCallee();
+
+		JSAbstractFramePtr frame(Jsvalify(i.abstractFramePtr()));
+        desc.callObject = frame.callObject(cx);
+		
+        desc.thisVal = i.thisv();
+		desc.raw = frame.raw();
+
+        if (!frames.append(desc))
+            return NULL;
+        if (frames.length() == maxFrames)
+            break;
+    }
+
+    JS::StackDescriptionEx *desc = js_new<JS::StackDescriptionEx>();
+    if (!desc)
+        return NULL;
+
+    desc->nframes = frames.length();
+    desc->frames = frames.extractRawBuffer();
+    return desc;
+}
+
+JS_PUBLIC_API(void)
+JS::FreeStackDescriptionEx(JSContext *cx, JS::StackDescriptionEx *desc)
+{
+    js_delete(desc->frames);
+    js_delete(desc);
+}
+
+JS_PUBLIC_API(bool)
+JS::JS_evaluateUCInStackFrame(JSContext *cx, uintptr_t raw, const jschar *chars, unsigned length, const char *filename, unsigned lineno, MutableHandleValue rval)
+{
+    for (NonBuiltinScriptFrameIter i(cx); !i.done(); ++i) {
+		JSAbstractFramePtr frame(Jsvalify(i.abstractFramePtr()));
+		if (frame.raw()==raw)
+        return frame.evaluateUCInStackFrame(cx, chars, length, filename, lineno, rval); 
+    }
+  return false;
+}
+
 class AutoPropertyDescArray
 {
     JSContext *cx_;
     JSPropertyDescArray descArray_;
 
   public:
     AutoPropertyDescArray(JSContext *cx)
       : cx_(cx)
diff --git a/js/src/jsdbgapi.h b/js/src/jsdbgapi.h
--- a/js/src/jsdbgapi.h
+++ b/js/src/jsdbgapi.h
@@ -5,79 +5,105 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef jsdbgapi_h
 #define jsdbgapi_h
 /*
  * JS debugger API.
  */
 #include "jsprvtd.h"
+class JSAbstractFramePtr;
 
 namespace JS {
 
 struct FrameDescription
 {
     JSScript *script;
     unsigned lineno;
     JSFunction *fun;
 };
 
 struct StackDescription
 {
     unsigned nframes;
     FrameDescription *frames;
 };
 
-extern JS_PUBLIC_API(StackDescription *)
+extern "C" JS_PUBLIC_API(StackDescription *)
 DescribeStack(JSContext *cx, unsigned maxFrames);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 FreeStackDescription(JSContext *cx, StackDescription *desc);
 
-extern JS_PUBLIC_API(char *)
+extern "C" JS_PUBLIC_API(char *)
 FormatStackDump(JSContext *cx, char *buf,
                     JSBool showArgs, JSBool showLocals,
                     JSBool showThisProps);
 
+
+struct FrameDescriptionEx
+{
+    JSScript *script;
+    unsigned lineno;
+    JSFunction *fun;
+    JSObject *callObject;
+    jsval thisVal;
+	uintptr_t raw;
+};
+
+struct StackDescriptionEx
+{
+    unsigned nframes;
+    FrameDescriptionEx *frames;
+};
+
+extern "C" JS_PUBLIC_API(StackDescriptionEx *)
+DescribeStackEx(JSContext *cx, unsigned maxFrames);
+
+extern "C" JS_PUBLIC_API(void)
+FreeStackDescriptionEx(JSContext *cx, StackDescriptionEx *desc);
+
+extern "C" JS_PUBLIC_API(bool)
+JS_evaluateUCInStackFrame(JSContext *cx, uintptr_t raw, const jschar *chars, unsigned length, const char *filename, unsigned lineno, MutableHandleValue rval);
 }
 
 # ifdef JS_DEBUG
 JS_FRIEND_API(void) js_DumpValue(const js::Value &val);
 JS_FRIEND_API(void) js_DumpId(jsid id);
 JS_FRIEND_API(void) js_DumpStackFrame(JSContext *cx, js::StackFrame *start = NULL);
 # endif
 
 JS_FRIEND_API(void)
 js_DumpBacktrace(JSContext *cx);
 
-extern JS_PUBLIC_API(JSCompartment *)
+extern "C" JS_PUBLIC_API(JSCompartment *)
 JS_EnterCompartmentOfScript(JSContext *cx, JSScript *target);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_DecompileScript(JSContext *cx, JSScript *script, const char *name, unsigned indent);
 
 /*
  * Currently, we only support runtime-wide debugging. In the future, we should
  * be able to support compartment-wide debugging.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetRuntimeDebugMode(JSRuntime *rt, JSBool debug);
 
 /*
  * Debug mode is a compartment-wide mode that enables a debugger to attach
  * to and interact with running methodjit-ed frames. In particular, it causes
  * every function to be compiled as if an eval was present (so eval-in-frame)
  * can work, and it ensures that functions can be re-JITed for other debug
  * features. In general, it is not safe to interact with frames that were live
  * before debug mode was enabled. For this reason, it is also not safe to
  * enable debug mode while frames are live.
  */
 
 /* Get current state of debugging mode. */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetDebugMode(JSContext *cx);
 
 /*
  * Turn on/off debugging mode for all compartments. This returns false if any code
  * from any of the runtime's compartments is running or on the stack.
  */
 JS_FRIEND_API(JSBool)
 JS_SetDebugModeForAllCompartments(JSContext *cx, JSBool debug);
@@ -88,163 +114,166 @@ JS_SetDebugModeForAllCompartments(JSCont
  * thread.
  */
 JS_FRIEND_API(JSBool)
 JS_SetDebugModeForCompartment(JSContext *cx, JSCompartment *comp, JSBool debug);
 
 /*
  * Turn on/off debugging mode for a context's compartment.
  */
-JS_FRIEND_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetDebugMode(JSContext *cx, JSBool debug);
 
 /* Turn on single step mode. */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetSingleStepMode(JSContext *cx, JSScript *script, JSBool singleStep);
 
 /* The closure argument will be marked. */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
            JSTrapHandler handler, jsval closure);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ClearTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
              JSTrapHandler *handlerp, jsval *closurep);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ClearScriptTraps(JSRuntime *rt, JSScript *script);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ClearAllTrapsForCompartment(JSContext *cx);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetInterrupt(JSRuntime *rt, JSInterruptHook handler, void *closure);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ClearInterrupt(JSRuntime *rt, JSInterruptHook *handlerp, void **closurep);
 
 /************************************************************************/
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetWatchPoint(JSContext *cx, JSObject *obj, jsid id,
                  JSWatchPointHandler handler, JSObject *closure);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ClearWatchPoint(JSContext *cx, JSObject *obj, jsid id,
                    JSWatchPointHandler *handlerp, JSObject **closurep);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ClearWatchPointsForObject(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_ClearAllWatchPoints(JSContext *cx);
 
 /************************************************************************/
 
 // Raw JSScript* because this needs to be callable from a signal handler.
-extern JS_PUBLIC_API(unsigned)
+extern "C" JS_PUBLIC_API(unsigned)
 JS_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc);
 
-extern JS_PUBLIC_API(jsbytecode *)
+extern "C" JS_PUBLIC_API(jsbytecode *)
 JS_LineNumberToPC(JSContext *cx, JSScript *script, unsigned lineno);
 
-extern JS_PUBLIC_API(jsbytecode *)
+extern "C" JS_PUBLIC_API(jsbytecode *)
 JS_EndPC(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetLinePCs(JSContext *cx, JSScript *script,
               unsigned startLine, unsigned maxLines,
               unsigned* count, unsigned** lines, jsbytecode*** pcs);
 
-extern JS_PUBLIC_API(unsigned)
+extern "C" JS_PUBLIC_API(unsigned)
 JS_GetFunctionArgumentCount(JSContext *cx, JSFunction *fun);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_FunctionHasLocalNames(JSContext *cx, JSFunction *fun);
 
 /*
  * N.B. The mark is in the context temp pool and thus the caller must take care
  * to call JS_ReleaseFunctionLocalNameArray in a LIFO manner (wrt to any other
  * call that may use the temp pool.
  */
-extern JS_PUBLIC_API(uintptr_t *)
+extern "C" JS_PUBLIC_API(uintptr_t *)
 JS_GetFunctionLocalNameArray(JSContext *cx, JSFunction *fun, void **markp);
 
-extern JS_PUBLIC_API(JSAtom *)
+extern "C" JS_PUBLIC_API(JSAtom *)
 JS_LocalNameToAtom(uintptr_t w);
 
-extern JS_PUBLIC_API(JSString *)
+extern "C" JS_PUBLIC_API(JSString *)
 JS_AtomKey(JSAtom *atom);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReleaseFunctionLocalNameArray(JSContext *cx, void *mark);
 
-extern JS_PUBLIC_API(JSScript *)
+extern "C" JS_PUBLIC_API(JSScript *)
 JS_GetFunctionScript(JSContext *cx, JSFunction *fun);
 
-extern JS_PUBLIC_API(JSNative)
+extern "C" JS_PUBLIC_API(JSNative)
 JS_GetFunctionNative(JSContext *cx, JSFunction *fun);
 
-extern JS_PUBLIC_API(JSPrincipals *)
+extern "C" JS_PUBLIC_API(JSPrincipals *)
 JS_GetScriptPrincipals(JSScript *script);
 
-extern JS_PUBLIC_API(JSPrincipals *)
+extern "C" JS_PUBLIC_API(JSPrincipals *)
 JS_GetScriptOriginPrincipals(JSScript *script);
 
-JS_PUBLIC_API(JSFunction *)
+extern "C" JS_PUBLIC_API(JSFunction *)
 JS_GetScriptFunction(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(JSObject *)
+extern "C" JS_PUBLIC_API(JSObject *)
 JS_GetParentOrScopeChain(JSContext *cx, JSObject *obj);
 
 /************************************************************************/
 
 /*
  * This is almost JS_GetClass(obj)->name except that certain debug-only
  * proxies are made transparent. In particular, this function turns the class
  * of any scope (returned via JS_GetFrameScopeChain or JS_GetFrameCalleeObject)
  * from "Proxy" to "Call", "Block", "With" etc.
  */
-extern JS_PUBLIC_API(const char *)
+extern "C" JS_PUBLIC_API(const char *)
 JS_GetDebugClassName(JSObject *obj);
 
 /************************************************************************/
 
-extern JS_PUBLIC_API(const char *)
+extern "C" JS_PUBLIC_API(const char *)
 JS_GetScriptFilename(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(const jschar *)
+extern "C" JS_PUBLIC_API(const jschar *)
 JS_GetScriptSourceMap(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(unsigned)
+extern "C" JS_PUBLIC_API(void *)
+JS_GetScriptSource(JSContext *cx, JSScript *script);
+
+extern "C" JS_PUBLIC_API(unsigned)
 JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(unsigned)
+extern "C" JS_PUBLIC_API(unsigned)
 JS_GetScriptLineExtent(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(JSVersion)
+extern "C" JS_PUBLIC_API(JSVersion)
 JS_GetScriptVersion(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetScriptIsSelfHosted(JSScript *script);
 
 /************************************************************************/
 
 /*
  * Hook setters for script creation and destruction, see jsprvtd.h for the
  * typedefs.  These macros provide binary compatibility and newer, shorter
  * synonyms.
  */
 #define JS_SetNewScriptHook     JS_SetNewScriptHookProc
 #define JS_SetDestroyScriptHook JS_SetDestroyScriptHookProc
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetNewScriptHook(JSRuntime *rt, JSNewScriptHook hook, void *callerdata);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetDestroyScriptHook(JSRuntime *rt, JSDestroyScriptHook hook,
                         void *callerdata);
 
 /************************************************************************/
 
 typedef struct JSPropertyDesc {
     jsval           id;         /* primary id, atomized string, or int */
     jsval           value;      /* property value */
@@ -264,20 +293,20 @@ typedef struct JSPropertyDesc {
 
 typedef struct JSPropertyDescArray {
     uint32_t        length;     /* number of elements in array */
     JSPropertyDesc  *array;     /* alloc'd by Get, freed by Put */
 } JSPropertyDescArray;
 
 typedef struct JSScopeProperty JSScopeProperty;
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_GetPropertyDescArray(JSContext *cx, JSObject *obj, JSPropertyDescArray *pda);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_PutPropertyDescArray(JSContext *cx, JSPropertyDescArray *pda);
 
 /************************************************************************/
 
 /*
  * JSAbstractFramePtr is the public version of AbstractFramePtr, a pointer to a
  * StackFrame or baseline JIT frame.
  */
@@ -401,58 +430,58 @@ typedef struct JSDebugHooks {
     JSThrowHook         throwHook;
     void                *throwHookData;
     JSDebugErrorHook    debugErrorHook;
     void                *debugErrorHookData;
 } JSDebugHooks;
 
 /************************************************************************/
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetDebuggerHandler(JSRuntime *rt, JSDebuggerHandler hook, void *closure);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetSourceHandler(JSRuntime *rt, JSSourceHandler handler, void *closure);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetExecuteHook(JSRuntime *rt, JSInterpreterHook hook, void *closure);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetCallHook(JSRuntime *rt, JSInterpreterHook hook, void *closure);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetThrowHook(JSRuntime *rt, JSThrowHook hook, void *closure);
 
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_SetDebugErrorHook(JSRuntime *rt, JSDebugErrorHook hook, void *closure);
 
 /************************************************************************/
 
-extern JS_PUBLIC_API(const JSDebugHooks *)
+extern "C" JS_PUBLIC_API(const JSDebugHooks *)
 JS_GetGlobalDebugHooks(JSRuntime *rt);
 
 /**
  * Add various profiling-related functions as properties of the given object.
  */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineProfilingFunctions(JSContext *cx, JSObject *obj);
 
 /* Defined in vm/Debugger.cpp. */
-extern JS_PUBLIC_API(JSBool)
+extern "C" JS_PUBLIC_API(JSBool)
 JS_DefineDebuggerObject(JSContext *cx, JSObject *obj);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DumpBytecode(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DumpCompartmentBytecode(JSContext *cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DumpPCCounts(JSContext *cx, JSScript *script);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DumpCompartmentPCCounts(JSContext *cx);
 
 /* Call the context debug handler on the topmost scripted frame. */
 extern JS_FRIEND_API(JSBool)
 js_CallContextDebugHandler(JSContext *cx);
 
 #endif /* jsdbgapi_h */
diff --git a/js/src/jsfriendapi.h b/js/src/jsfriendapi.h
--- a/js/src/jsfriendapi.h
+++ b/js/src/jsfriendapi.h
@@ -1154,301 +1154,301 @@ protected:
 typedef js::ArrayBufferView::ViewType JSArrayBufferViewType;
 
 /*
  * Create a new typed array with nelements elements.
  *
  * These functions (except the WithBuffer variants) fill in the array with zeros.
  */
 
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt8Array(JSContext *cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint8Array(JSContext *cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint8ClampedArray(JSContext *cx, uint32_t nelements);
 
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt16Array(JSContext *cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint16Array(JSContext *cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt32Array(JSContext *cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint32Array(JSContext *cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewFloat32Array(JSContext *cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewFloat64Array(JSContext *cx, uint32_t nelements);
 
 /*
  * Create a new typed array and copy in values from the given object. The
  * object is used as if it were an array; that is, the new array (if
  * successfully created) will have length given by array.length, and its
  * elements will be those specified by array[0], array[1], and so on, after
  * conversion to the typed array element type.
  */
 
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt8ArrayFromArray(JSContext *cx, JSObject *array);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint8ArrayFromArray(JSContext *cx, JSObject *array);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint8ClampedArrayFromArray(JSContext *cx, JSObject *array);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt16ArrayFromArray(JSContext *cx, JSObject *array);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint16ArrayFromArray(JSContext *cx, JSObject *array);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt32ArrayFromArray(JSContext *cx, JSObject *array);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint32ArrayFromArray(JSContext *cx, JSObject *array);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewFloat32ArrayFromArray(JSContext *cx, JSObject *array);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewFloat64ArrayFromArray(JSContext *cx, JSObject *array);
 
 /*
  * Create a new typed array using the given ArrayBuffer for storage.  The
  * length value is optional; if -1 is passed, enough elements to use up the
  * remainder of the byte array is used as the default value.
  */
 
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt8ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                           uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint8ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                            uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint8ClampedArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                                   uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt16ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                            uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint16ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                             uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewInt32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                            uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewUint32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                             uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewFloat32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                              uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewFloat64ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
                              uint32_t byteOffset, int32_t length);
 
 /*
  * Create a new ArrayBuffer with the given byte length.
  */
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_NewArrayBuffer(JSContext *cx, uint32_t nbytes);
 
 /*
  * Check whether obj supports JS_GetTypedArray* APIs. Note that this may return
  * false if a security wrapper is encountered that denies the unwrapping. If
  * this test or one of the JS_Is*Array tests succeeds, then it is safe to call
  * the various accessor JSAPI calls defined below.
  */
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsTypedArrayObject(JSObject *obj);
 
 /*
  * Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may
  * return false if a security wrapper is encountered that denies the
  * unwrapping. If this test or one of the more specific tests succeeds, then it
  * is safe to call the various ArrayBufferView accessor JSAPI calls defined
  * below.
  */
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsArrayBufferViewObject(JSObject *obj);
 
 /*
  * Test for specific typed array types (ArrayBufferView subtypes)
  */
 
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsInt8Array(JSObject *obj);
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsUint8Array(JSObject *obj);
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsUint8ClampedArray(JSObject *obj);
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsInt16Array(JSObject *obj);
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsUint16Array(JSObject *obj);
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsInt32Array(JSObject *obj);
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsUint32Array(JSObject *obj);
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsFloat32Array(JSObject *obj);
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsFloat64Array(JSObject *obj);
 
 /*
  * Unwrap Typed arrays all at once. Return NULL without throwing if the object
  * cannot be viewed as the correct typed array, or the typed array object on
  * success, filling both outparameters.
  */
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsInt8Array(JSObject *obj, uint32_t *length, int8_t **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsUint8Array(JSObject *obj, uint32_t *length, uint8_t **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsUint8ClampedArray(JSObject *obj, uint32_t *length, uint8_t **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsInt16Array(JSObject *obj, uint32_t *length, int16_t **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsUint16Array(JSObject *obj, uint32_t *length, uint16_t **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsInt32Array(JSObject *obj, uint32_t *length, int32_t **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsUint32Array(JSObject *obj, uint32_t *length, uint32_t **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsFloat32Array(JSObject *obj, uint32_t *length, float **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsFloat64Array(JSObject *obj, uint32_t *length, double **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsArrayBufferView(JSObject *obj, uint32_t *length, uint8_t **data);
-extern JS_FRIEND_API(JSObject *)
+extern "C" JS_FRIEND_API(JSObject *)
 JS_GetObjectAsArrayBuffer(JSObject *obj, uint32_t *length, uint8_t **data);
 
 /*
  * Get the type of elements in a typed array, or TYPE_DATAVIEW if a DataView.
  *
  * |obj| must have passed a JS_IsArrayBufferView/JS_Is*Array test, or somehow
  * be known that it would pass such a test: it is an ArrayBufferView or a
  * wrapper of an ArrayBufferView, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(JSArrayBufferViewType)
+extern "C" JS_FRIEND_API(JSArrayBufferViewType)
 JS_GetArrayBufferViewType(JSObject *obj);
 
 /*
  * Check whether obj supports the JS_GetArrayBuffer* APIs. Note that this may
  * return false if a security wrapper is encountered that denies the
  * unwrapping. If this test succeeds, then it is safe to call the various
  * accessor JSAPI calls defined below.
  */
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsArrayBufferObject(JSObject *obj);
 
 /*
  * Return the available byte length of an array buffer.
  *
  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
  * ArrayBuffer, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetArrayBufferByteLength(JSObject *obj);
 
 /*
  * Return a pointer to an array buffer's data. The buffer is still owned by the
  * array buffer object, and should not be modified on another thread. The
  * returned pointer is stable across GCs.
  *
  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
  * ArrayBuffer, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint8_t *)
+extern "C" JS_FRIEND_API(uint8_t *)
 JS_GetArrayBufferData(JSObject *obj);
 
 /*
  * Return the number of elements in a typed array.
  *
  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetTypedArrayLength(JSObject *obj);
 
 /*
  * Return the byte offset from the start of an array buffer to the start of a
  * typed array view.
  *
  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetTypedArrayByteOffset(JSObject *obj);
 
 /*
  * Return the byte length of a typed array.
  *
  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetTypedArrayByteLength(JSObject *obj);
 
 /*
  * Check whether obj supports JS_ArrayBufferView* APIs. Note that this may
  * return false if a security wrapper is encountered that denies the
  * unwrapping.
  */
-extern JS_FRIEND_API(JSBool)
+extern "C" JS_FRIEND_API(JSBool)
 JS_IsArrayBufferViewObject(JSObject *obj);
 
 /*
  * More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetArrayBufferViewByteLength(JSObject *obj);
 
 /*
  * Return a pointer to the start of the data referenced by a typed array. The
  * data is still owned by the typed array, and should not be modified on
  * another thread.
  *
  * |obj| must have passed a JS_Is*Array test, or somehow be known that it would
  * pass such a test: it is a typed array or a wrapper of a typed array, and the
  * unwrapping will succeed.
  */
 
-extern JS_FRIEND_API(int8_t *)
+extern "C" JS_FRIEND_API(int8_t *)
 JS_GetInt8ArrayData(JSObject *obj);
-extern JS_FRIEND_API(uint8_t *)
+extern "C" JS_FRIEND_API(uint8_t *)
 JS_GetUint8ArrayData(JSObject *obj);
-extern JS_FRIEND_API(uint8_t *)
+extern "C" JS_FRIEND_API(uint8_t *)
 JS_GetUint8ClampedArrayData(JSObject *obj);
-extern JS_FRIEND_API(int16_t *)
+extern "C" JS_FRIEND_API(int16_t *)
 JS_GetInt16ArrayData(JSObject *obj);
-extern JS_FRIEND_API(uint16_t *)
+extern "C" JS_FRIEND_API(uint16_t *)
 JS_GetUint16ArrayData(JSObject *obj);
-extern JS_FRIEND_API(int32_t *)
+extern "C" JS_FRIEND_API(int32_t *)
 JS_GetInt32ArrayData(JSObject *obj);
-extern JS_FRIEND_API(uint32_t *)
+extern "C" JS_FRIEND_API(uint32_t *)
 JS_GetUint32ArrayData(JSObject *obj);
-extern JS_FRIEND_API(float *)
+extern "C" JS_FRIEND_API(float *)
 JS_GetFloat32ArrayData(JSObject *obj);
-extern JS_FRIEND_API(double *)
+extern "C" JS_FRIEND_API(double *)
 JS_GetFloat64ArrayData(JSObject *obj);
 
 /*
  * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
  * versions when possible.
  */
-extern JS_FRIEND_API(void *)
+extern "C" JS_FRIEND_API(void *)
 JS_GetArrayBufferViewData(JSObject *obj);
 
 /*
  * Return the ArrayBuffer underlying an ArrayBufferView. If the buffer has been
  * neutered, this will still return the neutered buffer. |obj| must be an
  * object that would return true for JS_IsArrayBufferViewObject().
  */
-extern JS_FRIEND_API(JSObject *)
+extern "C"  JS_FRIEND_API(JSObject *)
 JS_GetArrayBufferViewBuffer(JSObject *obj);
 
 /*
  * Check whether obj supports JS_GetDataView* APIs.
  */
 JS_FRIEND_API(JSBool)
 JS_IsDataViewObject(JSObject *obj);
 
diff --git a/js/src/md/_win95.cfg b/js/src/md/_win95.cfg
new file mode 100644
--- /dev/null
+++ b/js/src/md/_win95.cfg
@@ -0,0 +1,272 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nspr_cpucfg___
+#define nspr_cpucfg___
+
+#ifndef XP_PC
+#define XP_PC
+#endif
+
+#ifndef WIN32
+#define WIN32
+#endif
+
+#ifndef WIN95
+#define WIN95
+#endif
+
+#define PR_AF_INET6 23  /* same as AF_INET6 */
+
+#if defined(_M_IX86) || defined(_X86_)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_WORD	4
+#define PR_BYTES_PER_DWORD	8
+#define PR_BYTES_PER_DOUBLE 8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_WORD	32
+#define PR_BITS_PER_DWORD	64
+#define PR_BITS_PER_DOUBLE  64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_WORD_LOG2	5
+#define PR_BITS_PER_DWORD_LOG2	6
+#define PR_BITS_PER_DOUBLE_LOG2 6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_WORD	4
+#define PR_ALIGN_OF_DWORD	8
+#define PR_ALIGN_OF_DOUBLE  4
+#define PR_ALIGN_OF_POINTER 4
+
+#define PR_BYTES_PER_WORD_LOG2	2
+#define PR_BYTES_PER_DWORD_LOG2	3
+
+#elif defined(_M_X64) || defined(_M_AMD64) || defined(_AMD64_)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+#define IS_64
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_WORD	8
+#define PR_BYTES_PER_DWORD	8
+#define PR_BYTES_PER_DOUBLE 8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_WORD	64
+#define PR_BITS_PER_DWORD	64
+#define PR_BITS_PER_DOUBLE  64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_WORD_LOG2	6
+#define PR_BITS_PER_DWORD_LOG2	6
+#define PR_BITS_PER_DOUBLE_LOG2 6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_WORD	8
+#define PR_ALIGN_OF_DWORD	8
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 8
+
+#define PR_BYTES_PER_WORD_LOG2	3
+#define PR_BYTES_PER_DWORD_LOG2	3
+
+#elif defined(_M_IA64) || defined(_IA64_)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+#define IS_64
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_WORD	8
+#define PR_BYTES_PER_DWORD	8
+#define PR_BYTES_PER_DOUBLE 8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_WORD	64
+#define PR_BITS_PER_DWORD	64
+#define PR_BITS_PER_DOUBLE  64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_WORD_LOG2	6
+#define PR_BITS_PER_DWORD_LOG2	6
+#define PR_BITS_PER_DOUBLE_LOG2 6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_WORD	8
+#define PR_ALIGN_OF_DWORD	8
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 8
+
+#define PR_BYTES_PER_WORD_LOG2	3
+#define PR_BYTES_PER_DWORD_LOG2	3
+
+#elif defined(_M_ARM) || defined(_ARM_)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+#define PR_BYTES_PER_DOUBLE 8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_WORD    32
+#define PR_BITS_PER_DWORD   64
+#define PR_BITS_PER_DOUBLE  64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_WORD_LOG2   5
+#define PR_BITS_PER_DWORD_LOG2  6
+#define PR_BITS_PER_DOUBLE_LOG2 6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_WORD    4
+#define PR_ALIGN_OF_DWORD   8
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 4
+
+#define PR_BYTES_PER_WORD_LOG2  2
+#define PR_BYTES_PER_DWORD_LOG2 3
+
+#else /* defined(_M_IX86) || defined(_X86_) */
+
+#error unknown processor architecture
+
+#endif /* defined(_M_IX86) || defined(_X86_) */
+
+#ifndef HAVE_LONG_LONG
+#define HAVE_LONG_LONG
+#endif
+
+#ifndef NO_NSPR_10_SUPPORT
+
+#define BYTES_PER_BYTE      PR_BYTES_PER_BYTE
+#define BYTES_PER_SHORT     PR_BYTES_PER_SHORT
+#define BYTES_PER_INT       PR_BYTES_PER_INT
+#define BYTES_PER_INT64     PR_BYTES_PER_INT64
+#define BYTES_PER_LONG      PR_BYTES_PER_LONG
+#define BYTES_PER_FLOAT     PR_BYTES_PER_FLOAT
+#define BYTES_PER_DOUBLE    PR_BYTES_PER_DOUBLE
+#define BYTES_PER_WORD      PR_BYTES_PER_WORD
+#define BYTES_PER_DWORD     PR_BYTES_PER_DWORD
+
+#define BITS_PER_BYTE       PR_BITS_PER_BYTE
+#define BITS_PER_SHORT      PR_BITS_PER_SHORT
+#define BITS_PER_INT        PR_BITS_PER_INT
+#define BITS_PER_INT64      PR_BITS_PER_INT64
+#define BITS_PER_LONG       PR_BITS_PER_LONG
+#define BITS_PER_FLOAT      PR_BITS_PER_FLOAT
+#define BITS_PER_DOUBLE     PR_BITS_PER_DOUBLE
+#define BITS_PER_WORD       PR_BITS_PER_WORD
+
+#define BITS_PER_BYTE_LOG2  PR_BITS_PER_BYTE_LOG2
+#define BITS_PER_SHORT_LOG2 PR_BITS_PER_SHORT_LOG2
+#define BITS_PER_INT_LOG2   PR_BITS_PER_INT_LOG2
+#define BITS_PER_INT64_LOG2 PR_BITS_PER_INT64_LOG2
+#define BITS_PER_LONG_LOG2  PR_BITS_PER_LONG_LOG2
+#define BITS_PER_FLOAT_LOG2 PR_BITS_PER_FLOAT_LOG2
+#define BITS_PER_DOUBLE_LOG2    PR_BITS_PER_DOUBLE_LOG2
+#define BITS_PER_WORD_LOG2  PR_BITS_PER_WORD_LOG2
+
+#define ALIGN_OF_SHORT      PR_ALIGN_OF_SHORT
+#define ALIGN_OF_INT        PR_ALIGN_OF_INT
+#define ALIGN_OF_LONG       PR_ALIGN_OF_LONG
+#define ALIGN_OF_INT64      PR_ALIGN_OF_INT64
+#define ALIGN_OF_FLOAT      PR_ALIGN_OF_FLOAT
+#define ALIGN_OF_DOUBLE     PR_ALIGN_OF_DOUBLE
+#define ALIGN_OF_POINTER    PR_ALIGN_OF_POINTER
+#define ALIGN_OF_WORD       PR_ALIGN_OF_WORD
+
+#define BYTES_PER_WORD_LOG2		PR_BYTES_PER_WORD_LOG2
+#define BYTES_PER_DWORD_LOG2    PR_BYTES_PER_DWORD_LOG2
+#define WORDS_PER_DWORD_LOG2    PR_WORDS_PER_DWORD_LOG2
+
+#endif /* NO_NSPR_10_SUPPORT */
+
+#endif /* nspr_cpucfg___ */
diff --git a/js/src/pratom.h b/js/src/pratom.h
new file mode 100644
--- /dev/null
+++ b/js/src/pratom.h
@@ -0,0 +1,199 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/* GLOBAL FUNCTIONS:
+** DESCRIPTION:
+**     PR Atomic operations
+*/
+
+#ifndef pratom_h___
+#define pratom_h___
+
+#include "prtypes.h"
+#include "prlock.h"
+
+PR_BEGIN_EXTERN_C
+
+/*
+** FUNCTION: PR_AtomicIncrement
+** DESCRIPTION:
+**    Atomically increment a 32 bit value.
+** INPUTS:
+**    val:  a pointer to the value to increment
+** RETURN:
+**    the returned value is the result of the increment
+*/
+NSPR_API(PRInt32)	PR_AtomicIncrement(PRInt32 *val);
+
+/*
+** FUNCTION: PR_AtomicDecrement
+** DESCRIPTION:
+**    Atomically decrement a 32 bit value.
+** INPUTS:
+**    val:  a pointer to the value to decrement
+** RETURN:
+**    the returned value is the result of the decrement
+*/
+NSPR_API(PRInt32)	PR_AtomicDecrement(PRInt32 *val);
+
+/*
+** FUNCTION: PR_AtomicSet
+** DESCRIPTION:
+**    Atomically set a 32 bit value.
+** INPUTS:
+**    val: A pointer to a 32 bit value to be set
+**    newval: The newvalue to assign to val
+** RETURN:
+**    Returns the prior value
+*/
+NSPR_API(PRInt32) PR_AtomicSet(PRInt32 *val, PRInt32 newval);
+
+/*
+** FUNCTION: PR_AtomicAdd
+** DESCRIPTION:
+**    Atomically add a 32 bit value.
+** INPUTS:
+**    ptr:  a pointer to the value to increment
+**	  val:  value to be added
+** RETURN:
+**    the returned value is the result of the addition
+*/
+NSPR_API(PRInt32)	PR_AtomicAdd(PRInt32 *ptr, PRInt32 val);
+
+/*
+** MACRO: PR_ATOMIC_INCREMENT
+** MACRO: PR_ATOMIC_DECREMENT
+** MACRO: PR_ATOMIC_SET
+** MACRO: PR_ATOMIC_ADD
+** DESCRIPTION:
+**    Macro versions of the atomic operations.  They may be implemented
+**    as compiler intrinsics.
+**
+** IMPORTANT NOTE TO NSPR MAINTAINERS:
+**    Implement these macros with compiler intrinsics only on platforms
+**    where the PR_AtomicXXX functions are truly atomic (i.e., where the
+**    configuration macro _PR_HAVE_ATOMIC_OPS is defined).  Otherwise,
+**    the macros and functions won't be compatible and can't be used
+**    interchangeably.
+*/
+#if defined(_WIN32) && !defined(_WIN32_WCE) && \
+    (!defined(_MSC_VER) || (_MSC_VER >= 1310))
+
+long __cdecl _InterlockedIncrement(long volatile *Addend);
+long __cdecl _InterlockedDecrement(long volatile *Addend);
+long __cdecl _InterlockedExchange(long volatile *Target, long Value);
+long __cdecl _InterlockedExchangeAdd(long volatile *Addend, long Value);
+
+#ifdef _MSC_VER
+#pragma intrinsic(_InterlockedIncrement)
+#pragma intrinsic(_InterlockedDecrement)
+#pragma intrinsic(_InterlockedExchange)
+#pragma intrinsic(_InterlockedExchangeAdd)
+#endif
+
+#define PR_ATOMIC_INCREMENT(val) _InterlockedIncrement((long volatile *)(val))
+#define PR_ATOMIC_DECREMENT(val) _InterlockedDecrement((long volatile *)(val))
+#define PR_ATOMIC_SET(val, newval) \
+        _InterlockedExchange((long volatile *)(val), (long)(newval))
+#define PR_ATOMIC_ADD(ptr, val) \
+        (_InterlockedExchangeAdd((long volatile *)(ptr), (long)(val)) + (val))
+
+#elif ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)) && \
+      ((defined(__APPLE__) && \
+           (defined(__ppc__) || defined(__i386__) || defined(__x86_64__))) || \
+       (defined(__linux__) && \
+           ((defined(__i386__) && \
+           defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)) || \
+           defined(__ia64__) || defined(__x86_64__) || \
+           (defined(__powerpc__) && !defined(__powerpc64__)) || \
+           (defined(__arm__) && \
+           defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)) || \
+           defined(__aarch64__) || defined(__alpha))))
+
+/*
+ * Because the GCC manual warns that some processors may support
+ * reduced functionality of __sync_lock_test_and_set, we test for the
+ * processors that we believe support a full atomic exchange operation.
+ */
+
+#define PR_ATOMIC_INCREMENT(val) __sync_add_and_fetch(val, 1)
+#define PR_ATOMIC_DECREMENT(val) __sync_sub_and_fetch(val, 1)
+#define PR_ATOMIC_SET(val, newval) __sync_lock_test_and_set(val, newval)
+#define PR_ATOMIC_ADD(ptr, val) __sync_add_and_fetch(ptr, val)
+
+#else
+
+#define PR_ATOMIC_INCREMENT(val) PR_AtomicIncrement(val)
+#define PR_ATOMIC_DECREMENT(val) PR_AtomicDecrement(val)
+#define PR_ATOMIC_SET(val, newval) PR_AtomicSet(val, newval)
+#define PR_ATOMIC_ADD(ptr, val) PR_AtomicAdd(ptr, val)
+
+#endif
+
+/*
+** LIFO linked-list (stack)
+*/
+typedef struct PRStackElemStr PRStackElem;
+
+struct PRStackElemStr {
+    PRStackElem	*prstk_elem_next;	/* next pointer MUST be at offset 0;
+									  assembly language code relies on this */
+};
+
+typedef struct PRStackStr PRStack;
+
+/*
+** FUNCTION: PR_CreateStack
+** DESCRIPTION:
+**    Create a stack, a LIFO linked list
+** INPUTS:
+**    stack_name:  a pointer to string containing the name of the stack
+** RETURN:
+**    A pointer to the created stack, if successful, else NULL.
+*/
+NSPR_API(PRStack *)	PR_CreateStack(const char *stack_name);
+
+/*
+** FUNCTION: PR_StackPush
+** DESCRIPTION:
+**    Push an element on the top of the stack
+** INPUTS:
+**    stack:		pointer to the stack
+**    stack_elem:	pointer to the stack element
+** RETURN:
+**    None
+*/
+NSPR_API(void)			PR_StackPush(PRStack *stack, PRStackElem *stack_elem);
+
+/*
+** FUNCTION: PR_StackPop
+** DESCRIPTION:
+**    Remove the element on the top of the stack
+** INPUTS:
+**    stack:		pointer to the stack
+** RETURN:
+**    A pointer to the stack element removed from the top of the stack,
+**	  if non-empty,
+**    else NULL
+*/
+NSPR_API(PRStackElem *)	PR_StackPop(PRStack *stack);
+
+/*
+** FUNCTION: PR_DestroyStack
+** DESCRIPTION:
+**    Destroy the stack
+** INPUTS:
+**    stack:		pointer to the stack
+** RETURN:
+**    PR_SUCCESS - if successfully deleted
+**	  PR_FAILURE - if the stack is not empty
+**					PR_GetError will return
+**						PR_INVALID_STATE_ERROR - stack is not empty
+*/
+NSPR_API(PRStatus)		PR_DestroyStack(PRStack *stack);
+
+PR_END_EXTERN_C
+
+#endif /* pratom_h___ */
diff --git a/js/src/prcpucfg.h b/js/src/prcpucfg.h
new file mode 100644
--- /dev/null
+++ b/js/src/prcpucfg.h
@@ -0,0 +1,46 @@
+    /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+    /* ***** BEGIN LICENSE BLOCK *****
+     * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+     *
+     * The contents of this file are subject to the Mozilla Public License Version
+     * 1.1 (the "License"); you may not use this file except in compliance with
+     * the License. You may obtain a copy of the License at
+     * http://www.mozilla.org/MPL/
+     *
+     * Software distributed under the License is distributed on an "AS IS" basis,
+     * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+     * for the specific language governing rights and limitations under the
+     * License.
+     *
+     * The Original Code is the Netscape Portable Runtime (NSPR).
+     *
+     * The Initial Developer of the Original Code is
+     * Netscape Communications Corporation.
+     * Portions created by the Initial Developer are Copyright (C) 1998-2000
+     * the Initial Developer. All Rights Reserved.
+     *
+     * Contributor(s):
+     *
+     * Alternatively, the contents of this file may be used under the terms of
+     * either the GNU General Public License Version 2 or later (the "GPL"), or
+     * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+     * in which case the provisions of the GPL or the LGPL are applicable instead
+     * of those above. If you wish to allow use of your version of this file only
+     * under the terms of either the GPL or the LGPL, and not to allow others to
+     * use your version of this file under the terms of the MPL, indicate your
+     * decision by deleting the provisions above and replace them with the notice
+     * and other provisions required by the GPL or the LGPL. If you do not delete
+     * the provisions above, a recipient may use your version of this file under
+     * the terms of any one of the MPL, the GPL or the LGPL.
+     *
+     * ***** END LICENSE BLOCK ***** */
+
+    #if defined(_WIN32)
+    #include "md/_win95.cfg"
+    #elif defined(__APPLE__)
+    #include "md/_darwin.cfg"
+    #elif defined(__linux__)
+    #include "md/_linux.cfg"
+    #else
+    #error Add a case for your platform
+    #endif
\ No newline at end of file
diff --git a/js/src/prcvar.h b/js/src/prcvar.h
new file mode 100644
--- /dev/null
+++ b/js/src/prcvar.h
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef prcvar_h___
+#define prcvar_h___
+
+#include "prlock.h"
+#include "prinrval.h"
+
+PR_BEGIN_EXTERN_C
+
+typedef struct PRCondVar PRCondVar;
+
+/*
+** Create a new condition variable.
+**
+** 	"lock" is the lock used to protect the condition variable.
+**
+** Condition variables are synchronization objects that threads can use
+** to wait for some condition to occur.
+**
+** This may fail if memory is tight or if some operating system resource
+** is low. In such cases, a NULL will be returned.
+*/
+NSPR_API(PRCondVar*) PR_NewCondVar(PRLock *lock);
+
+/*
+** Destroy a condition variable. There must be no thread
+** waiting on the condvar. The caller is responsible for guaranteeing
+** that the condvar is no longer in use.
+**
+*/
+NSPR_API(void) PR_DestroyCondVar(PRCondVar *cvar);
+
+/*
+** The thread that waits on a condition is blocked in a "waiting on
+** condition" state until another thread notifies the condition or a
+** caller specified amount of time expires. The lock associated with
+** the condition variable will be released, which must have be held
+** prior to the call to wait.
+**
+** Logically a notified thread is moved from the "waiting on condition"
+** state and made "ready." When scheduled, it will attempt to reacquire
+** the lock that it held when wait was called.
+**
+** The timeout has two well known values, PR_INTERVAL_NO_TIMEOUT and
+** PR_INTERVAL_NO_WAIT. The former value requires that a condition be
+** notified (or the thread interrupted) before it will resume from the
+** wait. If the timeout has a value of PR_INTERVAL_NO_WAIT, the effect
+** is to release the lock, possibly causing a rescheduling within the
+** runtime, then immediately attempting to reacquire the lock and resume.
+**
+** Any other value for timeout will cause the thread to be rescheduled
+** either due to explicit notification or an expired interval. The latter
+** must be determined by treating time as one part of the monitored data
+** being protected by the lock and tested explicitly for an expired
+** interval.
+**
+** Returns PR_FAILURE if the caller has not locked the lock associated
+** with the condition variable or the thread was interrupted (PR_Interrupt()).
+** The particular reason can be extracted with PR_GetError().
+*/
+NSPR_API(PRStatus) PR_WaitCondVar(PRCondVar *cvar, PRIntervalTime timeout);
+
+/*
+** Notify ONE thread that is currently waiting on 'cvar'. Which thread is
+** dependent on the implementation of the runtime. Common sense would dictate
+** that all threads waiting on a single condition have identical semantics,
+** therefore which one gets notified is not significant. 
+**
+** The calling thead must hold the lock that protects the condition, as
+** well as the invariants that are tightly bound to the condition, when
+** notify is called.
+**
+** Returns PR_FAILURE if the caller has not locked the lock associated
+** with the condition variable.
+*/
+NSPR_API(PRStatus) PR_NotifyCondVar(PRCondVar *cvar);
+
+/*
+** Notify all of the threads waiting on the condition variable. The order
+** that the threads are notified is indeterminant. The lock that protects
+** the condition must be held.
+**
+** Returns PR_FAILURE if the caller has not locked the lock associated
+** with the condition variable.
+*/
+NSPR_API(PRStatus) PR_NotifyAllCondVar(PRCondVar *cvar);
+
+PR_END_EXTERN_C
+
+#endif /* prcvar_h___ */
diff --git a/js/src/prinet.h b/js/src/prinet.h
new file mode 100644
--- /dev/null
+++ b/js/src/prinet.h
@@ -0,0 +1,99 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ * File:		prinet.h
+ * Description:
+ *     Header file used to find the system header files for socket support[1].
+ *     This file serves the following purposes:
+ *     - A cross-platform, "get-everything" socket header file.  On
+ *       Unix, socket support is scattered in several header files,
+ *       while Windows has a "get-everything" socket header file[2].
+ *     - NSPR needs the following macro definitions and function
+ *       prototype declarations from these header files:
+ *           AF_INET
+ *           INADDR_ANY, INADDR_LOOPBACK, INADDR_BROADCAST
+ *           ntohl(), ntohs(), htonl(), ntons().
+ *       NSPR does not define its own versions of these macros and
+ *       functions.  It simply uses the native versions, which have
+ *       the same names on all supported platforms.
+ *     This file is intended to be included by NSPR public header
+ *     files, such as prio.h.  One should not include this file directly.
+ *
+ * Notes:
+ *     1. This file should have been an internal header.  Please do not
+ *        depend on it to pull in the system header files you need.
+ *     2. WARNING: This file is no longer cross-platform as it is a no-op
+ *        for WIN32!  See the comment in the WIN32 section for details.
+ */
+
+#ifndef prinet_h__
+#define prinet_h__
+
+#if defined(XP_UNIX) || defined(XP_OS2) || defined(XP_BEOS)
+#include <sys/types.h>
+#include <sys/socket.h>		/* AF_INET */
+#include <netinet/in.h>         /* INADDR_ANY, ..., ntohl(), ... */
+#ifdef XP_OS2
+#include <sys/ioctl.h>
+#endif
+#ifdef XP_UNIX
+#ifdef AIX
+/*
+ * On AIX 4.3, the header <arpa/inet.h> refers to struct
+ * ether_addr and struct sockaddr_dl that are not declared.
+ * The following struct declarations eliminate the compiler
+ * warnings.
+ */
+struct ether_addr;
+struct sockaddr_dl;
+#endif /* AIX */
+#include <arpa/inet.h>
+#endif /* XP_UNIX */
+#include <netdb.h>
+
+#if defined(FREEBSD) || defined(BSDI) || defined(QNX)
+#include <rpc/types.h> /* the only place that defines INADDR_LOOPBACK */
+#endif
+
+/*
+ * OS/2 hack.  For some reason INADDR_LOOPBACK is not defined in the
+ * socket headers.
+ */
+#if defined(OS2) && !defined(INADDR_LOOPBACK)
+#define INADDR_LOOPBACK 0x7f000001
+#endif
+
+/*
+ * Prototypes of ntohl() etc. are declared in <machine/endian.h>
+ * on these platforms.
+ */
+#if defined(BSDI) || defined(OSF1)
+#include <machine/endian.h>
+#endif
+
+/* On Android, ntohl() etc. are declared in <sys/endian.h>. */
+#ifdef __ANDROID__
+#include <sys/endian.h>
+#endif
+
+#elif defined(WIN32)
+
+/*
+ * Do not include any system header files.
+ *
+ * Originally we were including <windows.h>.  It slowed down the
+ * compilation of files that included NSPR headers, so we removed
+ * the <windows.h> inclusion at customer's request, which created
+ * an unfortunate inconsistency with other platforms.
+ */
+
+#else
+
+#error Unknown platform
+
+#endif
+
+#endif /* prinet_h__ */
diff --git a/js/src/prinit.h b/js/src/prinit.h
new file mode 100644
--- /dev/null
+++ b/js/src/prinit.h
@@ -0,0 +1,215 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef prinit_h___
+#define prinit_h___
+
+#include "prthread.h"
+#include "prtypes.h"
+#include "prwin16.h"
+#include <stdio.h>
+
+PR_BEGIN_EXTERN_C
+
+/************************************************************************/
+/**************************IDENTITY AND VERSIONING***********************/
+/************************************************************************/
+
+/*
+** NSPR's name, this should persist until at least the turn of the
+** century.
+*/
+#define PR_NAME     "NSPR"
+
+/*
+** NSPR's version is used to determine the likelihood that the version you
+** used to build your component is anywhere close to being compatible with
+** what is in the underlying library.
+**
+** The format of the version string is
+**     "<major version>.<minor version>[.<patch level>] [<Beta>]"
+*/
+#define PR_VERSION  "4.10.4 Beta"
+#define PR_VMAJOR   4
+#define PR_VMINOR   10
+#define PR_VPATCH   4
+#define PR_BETA     PR_TRUE
+
+/*
+** PRVersionCheck
+**
+** The basic signature of the function that is called to provide version
+** checking. The result will be a boolean that indicates the likelihood
+** that the underling library will perform as the caller expects.
+**
+** The only argument is a string, which should be the verson identifier
+** of the library in question. That string will be compared against an
+** equivalent string that represents the actual build version of the
+** exporting library.
+**
+** The result will be the logical union of the directly called library
+** and all dependent libraries.
+*/
+
+typedef PRBool (*PRVersionCheck)(const char*);
+
+/*
+** PR_VersionCheck
+**
+** NSPR's existance proof of the version check function.
+**
+** Note that NSPR has no cooperating dependencies.
+*/
+
+NSPR_API(PRBool) PR_VersionCheck(const char *importedVersion);
+
+/*
+ * Returns a const string of the NSPR library version.
+ */
+NSPR_API(const char*) PR_GetVersion(void);
+
+
+/************************************************************************/
+/*******************************INITIALIZATION***************************/
+/************************************************************************/
+
+/*
+** Initialize the runtime. Attach a thread object to the currently
+** executing native thread of type "type".
+**
+** The specificaiton of 'maxPTDs' is ignored.
+*/
+NSPR_API(void) PR_Init(
+    PRThreadType type, PRThreadPriority priority, PRUintn maxPTDs);
+
+/*
+** And alternate form of initialization, one that may become the default if
+** not the only mechanism, provides a method to get the NSPR runtime init-
+** ialized and place NSPR between the caller and the runtime library. This
+** allows main() to be treated as any other thread root function, signalling
+** its compeletion by returning and allowing the runtime to coordinate the
+** completion of the other threads of the runtime.
+**
+** The priority of the main (or primordial) thread will be PR_PRIORITY_NORMAL.
+** The thread may adjust its own priority by using PR_SetPriority(), though
+** at this time the support for priorities is somewhat weak.
+**
+** The specificaiton of 'maxPTDs' is ignored.
+**
+** The value returned by PR_Initialize is the value returned from the root
+** function, 'prmain'.
+*/
+
+typedef PRIntn (PR_CALLBACK *PRPrimordialFn)(PRIntn argc, char **argv);
+
+NSPR_API(PRIntn) PR_Initialize(
+    PRPrimordialFn prmain, PRIntn argc, char **argv, PRUintn maxPTDs);
+
+/*
+** Return PR_TRUE if PR_Init has already been called.
+*/
+NSPR_API(PRBool) PR_Initialized(void);
+
+/*
+ * Perform a graceful shutdown of NSPR.  PR_Cleanup() may be called by
+ * the primordial thread near the end of the main() function.
+ *
+ * PR_Cleanup() attempts to synchronize the natural termination of
+ * process.  It does that by blocking the caller, if and only if it is
+ * the primordial thread, until the number of user threads has dropped
+ * to zero.  When the primordial thread returns from main(), the process
+ * will immediately and silently exit.  That is, it will (if necessary)
+ * forcibly terminate any existing threads and exit without significant
+ * blocking and there will be no error messages or core files.
+ *
+ * PR_Cleanup() returns PR_SUCCESS if NSPR is successfully shutdown,
+ * or PR_FAILURE if the calling thread of this function is not the
+ * primordial thread.
+ */
+NSPR_API(PRStatus) PR_Cleanup(void);
+
+/*
+** Disable Interrupts
+**		Disables timer signals used for pre-emptive scheduling.
+*/
+NSPR_API(void) PR_DisableClockInterrupts(void);
+
+/*
+** Enables Interrupts
+**		Enables timer signals used for pre-emptive scheduling.
+*/
+NSPR_API(void) PR_EnableClockInterrupts(void);
+
+/*
+** Block Interrupts
+**		Blocks the timer signal used for pre-emptive scheduling
+*/
+NSPR_API(void) PR_BlockClockInterrupts(void);
+
+/*
+** Unblock Interrupts
+**		Unblocks the timer signal used for pre-emptive scheduling
+*/
+NSPR_API(void) PR_UnblockClockInterrupts(void);
+
+/*
+** Create extra virtual processor threads. Generally used with MP systems.
+*/
+NSPR_API(void) PR_SetConcurrency(PRUintn numCPUs);
+
+/*
+** Control the method and size of the file descriptor (PRFileDesc*)
+** cache used by the runtime. Setting 'high' to zero is for performance,
+** any other value probably for debugging (see memo on FD caching).
+*/
+NSPR_API(PRStatus) PR_SetFDCacheSize(PRIntn low, PRIntn high);
+
+/*
+ * Cause an immediate, nongraceful, forced termination of the process.
+ * It takes a PRIntn argument, which is the exit status code of the
+ * process.
+ */
+NSPR_API(void) PR_ProcessExit(PRIntn status);
+
+/*
+** Abort the process in a non-graceful manner. This will cause a core file,
+** call to the debugger or other moral equivalent as well as causing the
+** entire process to stop.
+*/
+NSPR_API(void) PR_Abort(void);
+
+/*
+ ****************************************************************
+ *
+ * Module initialization:
+ *
+ ****************************************************************
+ */
+
+typedef struct PRCallOnceType {
+    PRIntn initialized;
+    PRInt32 inProgress;
+    PRStatus status;
+} PRCallOnceType;
+
+typedef PRStatus (PR_CALLBACK *PRCallOnceFN)(void);
+
+typedef PRStatus (PR_CALLBACK *PRCallOnceWithArgFN)(void *arg);
+
+NSPR_API(PRStatus) PR_CallOnce(
+    PRCallOnceType *once,
+    PRCallOnceFN    func
+);
+
+NSPR_API(PRStatus) PR_CallOnceWithArg(
+    PRCallOnceType      *once,
+    PRCallOnceWithArgFN  func,
+    void                *arg
+);
+
+
+PR_END_EXTERN_C
+
+#endif /* prinit_h___ */
diff --git a/js/src/prinrval.h b/js/src/prinrval.h
new file mode 100644
--- /dev/null
+++ b/js/src/prinrval.h
@@ -0,0 +1,146 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+** File:		prinrval.h
+** Description:	API to interval timing functions of NSPR.
+**
+**
+** NSPR provides interval times that are independent of network time
+** of day values. Interval times are (in theory) accurate regardless
+** of host processing requirements and also very cheap to acquire. It
+** is expected that getting an interval time while in a synchronized
+** function (holding one's lock).
+**/
+
+#if !defined(prinrval_h)
+#define prinrval_h
+
+#include "prtypes.h"
+
+PR_BEGIN_EXTERN_C
+
+/**********************************************************************/
+/************************* TYPES AND CONSTANTS ************************/
+/**********************************************************************/
+
+typedef PRUint32 PRIntervalTime;
+
+/***********************************************************************
+** DEFINES:     PR_INTERVAL_MIN
+**              PR_INTERVAL_MAX
+** DESCRIPTION:
+**  These two constants define the range (in ticks / second) of the
+**  platform dependent type, PRIntervalTime. These constants bound both
+**  the period and the resolution of a PRIntervalTime. 
+***********************************************************************/
+#define PR_INTERVAL_MIN 1000UL
+#define PR_INTERVAL_MAX 100000UL
+
+/***********************************************************************
+** DEFINES:     PR_INTERVAL_NO_WAIT
+**              PR_INTERVAL_NO_TIMEOUT
+** DESCRIPTION:
+**  Two reserved constants are defined in the PRIntervalTime namespace.
+**  They are used to indicate that the process should wait no time (return
+**  immediately) or wait forever (never time out), respectively.
+**  Note: PR_INTERVAL_NO_TIMEOUT passed as input to PR_Connect is 
+**  interpreted as use the OS's connect timeout.
+**  
+***********************************************************************/
+#define PR_INTERVAL_NO_WAIT 0UL
+#define PR_INTERVAL_NO_TIMEOUT 0xffffffffUL
+
+/**********************************************************************/
+/****************************** FUNCTIONS *****************************/
+/**********************************************************************/
+
+/***********************************************************************
+** FUNCTION:    PR_IntervalNow
+** DESCRIPTION:
+**  Return the value of NSPR's free running interval timer. That timer
+**  can be used to establish epochs and determine intervals (be computing
+**  the difference between two times).
+** INPUTS:      void
+** OUTPUTS:     void
+** RETURN:      PRIntervalTime
+**  
+** SIDE EFFECTS:
+**  None
+** RESTRICTIONS:
+**  The units of PRIntervalTime are platform dependent. They are chosen
+**  such that they are appropriate for the host OS, yet provide sufficient
+**  resolution and period to be useful to clients. 
+** MEMORY:      N/A
+** ALGORITHM:   Platform dependent
+***********************************************************************/
+NSPR_API(PRIntervalTime) PR_IntervalNow(void);
+
+/***********************************************************************
+** FUNCTION:    PR_TicksPerSecond
+** DESCRIPTION:
+**  Return the number of ticks per second for PR_IntervalNow's clock.
+**  The value will be in the range [PR_INTERVAL_MIN..PR_INTERVAL_MAX].
+** INPUTS:      void
+** OUTPUTS:     void
+** RETURN:      PRUint32
+**  
+** SIDE EFFECTS:
+**  None
+** RESTRICTIONS:
+**  None
+** MEMORY:      N/A
+** ALGORITHM:   N/A
+***********************************************************************/
+NSPR_API(PRUint32) PR_TicksPerSecond(void);
+
+/***********************************************************************
+** FUNCTION:    PR_SecondsToInterval
+**              PR_MillisecondsToInterval
+**              PR_MicrosecondsToInterval
+** DESCRIPTION:
+**  Convert standard clock units to platform dependent intervals.
+** INPUTS:      PRUint32
+** OUTPUTS:     void
+** RETURN:      PRIntervalTime
+**  
+** SIDE EFFECTS:
+**  None
+** RESTRICTIONS:
+**  Conversion may cause overflow, which is not reported.
+** MEMORY:      N/A
+** ALGORITHM:   N/A
+***********************************************************************/
+NSPR_API(PRIntervalTime) PR_SecondsToInterval(PRUint32 seconds);
+NSPR_API(PRIntervalTime) PR_MillisecondsToInterval(PRUint32 milli);
+NSPR_API(PRIntervalTime) PR_MicrosecondsToInterval(PRUint32 micro);
+
+/***********************************************************************
+** FUNCTION:    PR_IntervalToSeconds
+**              PR_IntervalToMilliseconds
+**              PR_IntervalToMicroseconds
+** DESCRIPTION:
+**  Convert platform dependent intervals to standard clock units.
+** INPUTS:      PRIntervalTime
+** OUTPUTS:     void
+** RETURN:      PRUint32
+**  
+** SIDE EFFECTS:
+**  None
+** RESTRICTIONS:
+**  Conversion may cause overflow, which is not reported.
+** MEMORY:      N/A
+** ALGORITHM:   N/A
+***********************************************************************/
+NSPR_API(PRUint32) PR_IntervalToSeconds(PRIntervalTime ticks);
+NSPR_API(PRUint32) PR_IntervalToMilliseconds(PRIntervalTime ticks);
+NSPR_API(PRUint32) PR_IntervalToMicroseconds(PRIntervalTime ticks);
+
+PR_END_EXTERN_C
+
+
+#endif /* !defined(prinrval_h) */
+
+/* prinrval.h */
diff --git a/js/src/prio.h b/js/src/prio.h
new file mode 100644
--- /dev/null
+++ b/js/src/prio.h
@@ -0,0 +1,2018 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ * File:     prio.h
+ *
+ * Description:    PR i/o related stuff, such as file system access, file
+ *         i/o, socket i/o, etc.
+ */
+
+#ifndef prio_h___
+#define prio_h___
+
+#include "prlong.h"
+#include "prtime.h"
+#include "prinrval.h"
+#include "prinet.h"
+
+PR_BEGIN_EXTERN_C
+
+/* Typedefs */
+typedef struct PRDir            PRDir;
+typedef struct PRDirEntry       PRDirEntry;
+#ifdef MOZ_UNICODE
+typedef struct PRDirUTF16       PRDirUTF16;
+typedef struct PRDirEntryUTF16  PRDirEntryUTF16;
+#endif /* MOZ_UNICODE */
+typedef struct PRFileDesc       PRFileDesc;
+typedef struct PRFileInfo       PRFileInfo;
+typedef struct PRFileInfo64     PRFileInfo64;
+typedef union  PRNetAddr        PRNetAddr;
+typedef struct PRIOMethods      PRIOMethods;
+typedef struct PRPollDesc       PRPollDesc;
+typedef struct PRFilePrivate    PRFilePrivate;
+typedef struct PRSendFileData   PRSendFileData;
+
+/*
+***************************************************************************
+** The file descriptor.
+** This is the primary structure to represent any active open socket,
+** whether it be a normal file or a network connection. Such objects
+** are stackable (or layerable). Each layer may have its own set of
+** method pointers and context private to that layer. All each layer
+** knows about its neighbors is how to get to their method table.
+***************************************************************************
+*/
+
+typedef PRIntn PRDescIdentity;          /* see: Layering file descriptors */
+
+struct PRFileDesc {
+    const PRIOMethods *methods;         /* the I/O methods table */
+    PRFilePrivate *secret;              /* layer dependent data */
+    PRFileDesc *lower, *higher;         /* pointers to adjacent layers */
+    void (PR_CALLBACK *dtor)(PRFileDesc *fd);
+                                        /* A destructor function for layer */
+    PRDescIdentity identity;            /* Identity of this particular layer  */
+};
+
+/*
+***************************************************************************
+** PRTransmitFileFlags
+**
+** Flags for PR_TransmitFile.  Pass PR_TRANSMITFILE_CLOSE_SOCKET to
+** PR_TransmitFile if the connection should be closed after the file
+** is transmitted.
+***************************************************************************
+*/
+typedef enum PRTransmitFileFlags {
+    PR_TRANSMITFILE_KEEP_OPEN = 0,    /* socket is left open after file
+                                       * is transmitted. */
+    PR_TRANSMITFILE_CLOSE_SOCKET = 1  /* socket is closed after file
+                                       * is transmitted. */
+} PRTransmitFileFlags;
+
+/*
+**************************************************************************
+** Macros for PRNetAddr
+**
+** Address families: PR_AF_INET, PR_AF_INET6, PR_AF_LOCAL
+** IP addresses: PR_INADDR_ANY, PR_INADDR_LOOPBACK, PR_INADDR_BROADCAST
+**************************************************************************
+*/
+
+#ifdef WIN32
+
+#define PR_AF_INET 2
+#define PR_AF_LOCAL 1
+#define PR_INADDR_ANY (unsigned long)0x00000000
+#define PR_INADDR_LOOPBACK 0x7f000001
+#define PR_INADDR_BROADCAST (unsigned long)0xffffffff
+
+#else /* WIN32 */
+
+#define PR_AF_INET AF_INET
+#define PR_AF_LOCAL AF_UNIX
+#define PR_INADDR_ANY INADDR_ANY
+#define PR_INADDR_LOOPBACK INADDR_LOOPBACK
+#define PR_INADDR_BROADCAST INADDR_BROADCAST
+
+#endif /* WIN32 */
+
+/*
+** Define PR_AF_INET6 in prcpucfg.h with the same
+** value as AF_INET6 on platforms with IPv6 support.
+** Otherwise define it here.
+*/
+#ifndef PR_AF_INET6
+#define PR_AF_INET6 100
+#endif
+
+#define PR_AF_INET_SDP 101
+#define PR_AF_INET6_SDP 102
+
+#ifndef PR_AF_UNSPEC
+#define PR_AF_UNSPEC 0
+#endif
+
+/*
+**************************************************************************
+** A network address
+**
+** Only Internet Protocol (IPv4 and IPv6) addresses are supported.
+** The address family must always represent IPv4 (AF_INET, probably == 2)
+** or IPv6 (AF_INET6).
+**************************************************************************
+*************************************************************************/
+
+struct PRIPv6Addr {
+	union {
+		PRUint8  _S6_u8[16];
+		PRUint16 _S6_u16[8];
+		PRUint32 _S6_u32[4];
+		PRUint64 _S6_u64[2];
+	} _S6_un;
+};
+#define pr_s6_addr		_S6_un._S6_u8
+#define pr_s6_addr16	_S6_un._S6_u16
+#define pr_s6_addr32	_S6_un._S6_u32
+#define pr_s6_addr64 	_S6_un._S6_u64
+
+typedef struct PRIPv6Addr PRIPv6Addr;
+
+union PRNetAddr {
+    struct {
+        PRUint16 family;                /* address family (0x00ff maskable) */
+#ifdef XP_BEOS
+        char data[10];                  /* Be has a smaller structure */
+#else
+        char data[14];                  /* raw address data */
+#endif
+    } raw;
+    struct {
+        PRUint16 family;                /* address family (AF_INET) */
+        PRUint16 port;                  /* port number */
+        PRUint32 ip;                    /* The actual 32 bits of address */
+#ifdef XP_BEOS
+        char pad[4];                    /* Be has a smaller structure */
+#else
+        char pad[8];
+#endif
+    } inet;
+    struct {
+        PRUint16 family;                /* address family (AF_INET6) */
+        PRUint16 port;                  /* port number */
+        PRUint32 flowinfo;              /* routing information */
+        PRIPv6Addr ip;                  /* the actual 128 bits of address */
+        PRUint32 scope_id;              /* set of interfaces for a scope */
+    } ipv6;
+#if defined(XP_UNIX) || defined(XP_OS2)
+    struct {                            /* Unix domain socket address */
+        PRUint16 family;                /* address family (AF_UNIX) */
+#ifdef XP_OS2
+        char path[108];                 /* null-terminated pathname */
+                                        /* bind fails if size is not 108. */
+#else
+        char path[104];                 /* null-terminated pathname */
+#endif
+    } local;
+#endif
+};
+
+/*
+***************************************************************************
+** PRSockOption
+**
+** The file descriptors can have predefined options set after they file
+** descriptor is created to change their behavior. Only the options in
+** the following enumeration are supported.
+***************************************************************************
+*/
+typedef enum PRSockOption
+{
+    PR_SockOpt_Nonblocking,     /* nonblocking io */
+    PR_SockOpt_Linger,          /* linger on close if data present */
+    PR_SockOpt_Reuseaddr,       /* allow local address reuse */
+    PR_SockOpt_Keepalive,       /* keep connections alive */
+    PR_SockOpt_RecvBufferSize,  /* send buffer size */
+    PR_SockOpt_SendBufferSize,  /* receive buffer size */
+
+    PR_SockOpt_IpTimeToLive,    /* time to live */
+    PR_SockOpt_IpTypeOfService, /* type of service and precedence */
+
+    PR_SockOpt_AddMember,       /* add an IP group membership */
+    PR_SockOpt_DropMember,      /* drop an IP group membership */
+    PR_SockOpt_McastInterface,  /* multicast interface address */
+    PR_SockOpt_McastTimeToLive, /* multicast timetolive */
+    PR_SockOpt_McastLoopback,   /* multicast loopback */
+
+    PR_SockOpt_NoDelay,         /* don't delay send to coalesce packets */
+    PR_SockOpt_MaxSegment,      /* maximum segment size */
+    PR_SockOpt_Broadcast,       /* enable broadcast */
+    PR_SockOpt_Last
+} PRSockOption;
+
+typedef struct PRLinger {
+	PRBool polarity;		    /* Polarity of the option's setting */
+	PRIntervalTime linger;	    /* Time to linger before closing */
+} PRLinger;
+
+typedef struct PRMcastRequest {
+	PRNetAddr mcaddr;			/* IP multicast address of group */
+	PRNetAddr ifaddr;			/* local IP address of interface */
+} PRMcastRequest;
+
+typedef struct PRSocketOptionData
+{
+    PRSockOption option;
+    union
+    {
+        PRUintn ip_ttl;             /* IP time to live */
+        PRUintn mcast_ttl;          /* IP multicast time to live */
+        PRUintn tos;                /* IP type of service and precedence */
+        PRBool non_blocking;        /* Non-blocking (network) I/O */
+        PRBool reuse_addr;          /* Allow local address reuse */
+        PRBool keep_alive;          /* Keep connections alive */
+        PRBool mcast_loopback;      /* IP multicast loopback */
+        PRBool no_delay;            /* Don't delay send to coalesce packets */
+        PRBool broadcast;           /* Enable broadcast */
+        PRSize max_segment;         /* Maximum segment size */
+        PRSize recv_buffer_size;    /* Receive buffer size */
+        PRSize send_buffer_size;    /* Send buffer size */
+        PRLinger linger;            /* Time to linger on close if data present */
+        PRMcastRequest add_member;  /* add an IP group membership */
+        PRMcastRequest drop_member; /* Drop an IP group membership */
+        PRNetAddr mcast_if;         /* multicast interface address */
+    } value;
+} PRSocketOptionData;
+
+/*
+***************************************************************************
+** PRIOVec
+**
+** The I/O vector is used by the write vector method to describe the areas
+** that are affected by the ouput operation.
+***************************************************************************
+*/
+typedef struct PRIOVec {
+    char *iov_base;
+    int iov_len;
+} PRIOVec;
+
+/*
+***************************************************************************
+** Discover what type of socket is being described by the file descriptor.
+***************************************************************************
+*/
+typedef enum PRDescType
+{
+    PR_DESC_FILE = 1,
+    PR_DESC_SOCKET_TCP = 2,
+    PR_DESC_SOCKET_UDP = 3,
+    PR_DESC_LAYERED = 4,
+    PR_DESC_PIPE = 5
+} PRDescType;
+
+typedef enum PRSeekWhence {
+    PR_SEEK_SET = 0,
+    PR_SEEK_CUR = 1,
+    PR_SEEK_END = 2
+} PRSeekWhence;
+
+NSPR_API(PRDescType) PR_GetDescType(PRFileDesc *file);
+
+/*
+***************************************************************************
+** PRIOMethods
+**
+** The I/O methods table provides procedural access to the functions of
+** the file descriptor. It is the responsibility of a layer implementor
+** to provide suitable functions at every entry point. If a layer provides
+** no functionality, it should call the next lower(higher) function of the
+** same name (e.g., return fd->lower->method->close(fd->lower));
+**
+** Not all functions are implemented for all types of files. In cases where
+** that is true, the function will return a error indication with an error
+** code of PR_INVALID_METHOD_ERROR.
+***************************************************************************
+*/
+
+typedef PRStatus (PR_CALLBACK *PRCloseFN)(PRFileDesc *fd);
+typedef PRInt32 (PR_CALLBACK *PRReadFN)(PRFileDesc *fd, void *buf, PRInt32 amount);
+typedef PRInt32 (PR_CALLBACK *PRWriteFN)(PRFileDesc *fd, const void *buf, PRInt32 amount);
+typedef PRInt32 (PR_CALLBACK *PRAvailableFN)(PRFileDesc *fd);
+typedef PRInt64 (PR_CALLBACK *PRAvailable64FN)(PRFileDesc *fd);
+typedef PRStatus (PR_CALLBACK *PRFsyncFN)(PRFileDesc *fd);
+typedef PROffset32 (PR_CALLBACK *PRSeekFN)(PRFileDesc *fd, PROffset32 offset, PRSeekWhence how);
+typedef PROffset64 (PR_CALLBACK *PRSeek64FN)(PRFileDesc *fd, PROffset64 offset, PRSeekWhence how);
+typedef PRStatus (PR_CALLBACK *PRFileInfoFN)(PRFileDesc *fd, PRFileInfo *info);
+typedef PRStatus (PR_CALLBACK *PRFileInfo64FN)(PRFileDesc *fd, PRFileInfo64 *info);
+typedef PRInt32 (PR_CALLBACK *PRWritevFN)(
+    PRFileDesc *fd, const PRIOVec *iov, PRInt32 iov_size,
+    PRIntervalTime timeout);
+typedef PRStatus (PR_CALLBACK *PRConnectFN)(
+    PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout);
+typedef PRFileDesc* (PR_CALLBACK *PRAcceptFN) (
+    PRFileDesc *fd, PRNetAddr *addr, PRIntervalTime timeout);
+typedef PRStatus (PR_CALLBACK *PRBindFN)(PRFileDesc *fd, const PRNetAddr *addr);
+typedef PRStatus (PR_CALLBACK *PRListenFN)(PRFileDesc *fd, PRIntn backlog);
+typedef PRStatus (PR_CALLBACK *PRShutdownFN)(PRFileDesc *fd, PRIntn how);
+typedef PRInt32 (PR_CALLBACK *PRRecvFN)(
+    PRFileDesc *fd, void *buf, PRInt32 amount,
+    PRIntn flags, PRIntervalTime timeout);
+typedef PRInt32 (PR_CALLBACK *PRSendFN) (
+    PRFileDesc *fd, const void *buf, PRInt32 amount,
+    PRIntn flags, PRIntervalTime timeout);
+typedef PRInt32 (PR_CALLBACK *PRRecvfromFN)(
+    PRFileDesc *fd, void *buf, PRInt32 amount,
+    PRIntn flags, PRNetAddr *addr, PRIntervalTime timeout);
+typedef PRInt32 (PR_CALLBACK *PRSendtoFN)(
+    PRFileDesc *fd, const void *buf, PRInt32 amount,
+    PRIntn flags, const PRNetAddr *addr, PRIntervalTime timeout);
+typedef PRInt16 (PR_CALLBACK *PRPollFN)(
+    PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags);
+typedef PRInt32 (PR_CALLBACK *PRAcceptreadFN)(
+    PRFileDesc *sd, PRFileDesc **nd, PRNetAddr **raddr,
+    void *buf, PRInt32 amount, PRIntervalTime t);
+typedef PRInt32 (PR_CALLBACK *PRTransmitfileFN)(
+     PRFileDesc *sd, PRFileDesc *fd, const void *headers,
+     PRInt32 hlen, PRTransmitFileFlags flags, PRIntervalTime t);
+typedef PRStatus (PR_CALLBACK *PRGetsocknameFN)(PRFileDesc *fd, PRNetAddr *addr);
+typedef PRStatus (PR_CALLBACK *PRGetpeernameFN)(PRFileDesc *fd, PRNetAddr *addr);
+typedef PRStatus (PR_CALLBACK *PRGetsocketoptionFN)(
+    PRFileDesc *fd, PRSocketOptionData *data);
+typedef PRStatus (PR_CALLBACK *PRSetsocketoptionFN)(
+    PRFileDesc *fd, const PRSocketOptionData *data);
+typedef PRInt32 (PR_CALLBACK *PRSendfileFN)(
+	PRFileDesc *networkSocket, PRSendFileData *sendData,
+	PRTransmitFileFlags flags, PRIntervalTime timeout);
+typedef PRStatus (PR_CALLBACK *PRConnectcontinueFN)(
+    PRFileDesc *fd, PRInt16 out_flags);
+typedef PRIntn (PR_CALLBACK *PRReservedFN)(PRFileDesc *fd);
+
+struct PRIOMethods {
+    PRDescType file_type;           /* Type of file represented (tos)           */
+    PRCloseFN close;                /* close file and destroy descriptor        */
+    PRReadFN read;                  /* read up to specified bytes into buffer   */
+    PRWriteFN write;                /* write specified bytes from buffer        */
+    PRAvailableFN available;        /* determine number of bytes available      */
+    PRAvailable64FN available64;    /*          ditto, 64 bit                   */
+    PRFsyncFN fsync;                /* flush all buffers to permanent store     */
+    PRSeekFN seek;                  /* position the file to the desired place   */
+    PRSeek64FN seek64;              /*           ditto, 64 bit                  */
+    PRFileInfoFN fileInfo;          /* Get information about an open file       */
+    PRFileInfo64FN fileInfo64;      /*           ditto, 64 bit                  */
+    PRWritevFN writev;              /* Write segments as described by iovector  */
+    PRConnectFN connect;            /* Connect to the specified (net) address   */
+    PRAcceptFN accept;              /* Accept a connection for a (net) peer     */
+    PRBindFN bind;                  /* Associate a (net) address with the fd    */
+    PRListenFN listen;              /* Prepare to listen for (net) connections  */
+    PRShutdownFN shutdown;          /* Shutdown a (net) connection              */
+    PRRecvFN recv;                  /* Solicit up the the specified bytes       */
+    PRSendFN send;                  /* Send all the bytes specified             */
+    PRRecvfromFN recvfrom;          /* Solicit (net) bytes and report source    */
+    PRSendtoFN sendto;              /* Send bytes to (net) address specified    */
+    PRPollFN poll;                  /* Test the fd to see if it is ready        */
+    PRAcceptreadFN acceptread;      /* Accept and read on a new (net) fd        */
+    PRTransmitfileFN transmitfile;  /* Transmit at entire file                  */
+    PRGetsocknameFN getsockname;    /* Get (net) address associated with fd     */
+    PRGetpeernameFN getpeername;    /* Get peer's (net) address                 */
+    PRReservedFN reserved_fn_6;     /* reserved for future use */
+    PRReservedFN reserved_fn_5;     /* reserved for future use */
+    PRGetsocketoptionFN getsocketoption;
+                                    /* Get current setting of specified option  */
+    PRSetsocketoptionFN setsocketoption;
+                                    /* Set value of specified option            */
+    PRSendfileFN sendfile;			/* Send a (partial) file with header/trailer*/
+    PRConnectcontinueFN connectcontinue;
+                                    /* Continue a nonblocking connect */
+    PRReservedFN reserved_fn_3;		/* reserved for future use */
+    PRReservedFN reserved_fn_2;		/* reserved for future use */
+    PRReservedFN reserved_fn_1;		/* reserved for future use */
+    PRReservedFN reserved_fn_0;		/* reserved for future use */
+};
+
+/*
+ **************************************************************************
+ * FUNCTION: PR_GetSpecialFD
+ * DESCRIPTION: Get the file descriptor that represents the standard input,
+ *              output, or error stream.
+ * INPUTS:
+ *     PRSpecialFD id
+ *         A value indicating the type of stream desired:
+ *             PR_StandardInput: standard input
+ *             PR_StandardOuput: standard output
+ *             PR_StandardError: standard error
+ * OUTPUTS: none
+ * RETURNS: PRFileDesc *
+ *     If the argument is valid, PR_GetSpecialFD returns a file descriptor
+ *     that represents the corresponding standard I/O stream.  Otherwise,
+ *     PR_GetSpecialFD returns NULL and sets error PR_INVALID_ARGUMENT_ERROR.
+ **************************************************************************
+ */
+
+typedef enum PRSpecialFD
+{
+    PR_StandardInput,          /* standard input */
+    PR_StandardOutput,         /* standard output */
+    PR_StandardError           /* standard error */
+} PRSpecialFD;
+
+NSPR_API(PRFileDesc*) PR_GetSpecialFD(PRSpecialFD id);
+
+#define PR_STDIN	PR_GetSpecialFD(PR_StandardInput)
+#define PR_STDOUT	PR_GetSpecialFD(PR_StandardOutput)
+#define PR_STDERR	PR_GetSpecialFD(PR_StandardError)
+
+/*
+ **************************************************************************
+ * Layering file descriptors
+ *
+ * File descriptors may be layered. Each layer has it's own identity.
+ * Identities are allocated by the runtime and are to be associated
+ * (by the layer implementor) with all layers that are of that type.
+ * It is then possible to scan the chain of layers and find a layer
+ * that one recongizes and therefore predict that it will implement
+ * a desired protocol.
+ *
+ * There are three well-known identities:
+ *      PR_INVALID_IO_LAYER => an invalid layer identity, for error return
+ *      PR_TOP_IO_LAYER     => the identity of the top of the stack
+ *      PR_NSPR_IO_LAYER    => the identity used by NSPR proper
+ * PR_TOP_IO_LAYER may be used as a shorthand for identifying the topmost
+ * layer of an existing stack. Ie., the following two constructs are
+ * equivalent.
+ *
+ *      rv = PR_PushIOLayer(stack, PR_TOP_IO_LAYER, my_layer);
+ *      rv = PR_PushIOLayer(stack, PR_GetLayersIdentity(stack), my_layer)
+ *
+ * A string may be associated with the creation of the identity. It
+ * will be copied by the runtime. If queried the runtime will return
+ * a reference to that copied string (not yet another copy). There
+ * is no facility for deleting an identity.
+ **************************************************************************
+ */
+
+#define PR_IO_LAYER_HEAD (PRDescIdentity)-3
+#define PR_INVALID_IO_LAYER (PRDescIdentity)-1
+#define PR_TOP_IO_LAYER (PRDescIdentity)-2
+#define PR_NSPR_IO_LAYER (PRDescIdentity)0
+
+NSPR_API(PRDescIdentity) PR_GetUniqueIdentity(const char *layer_name);
+NSPR_API(const char*) PR_GetNameForIdentity(PRDescIdentity ident);
+NSPR_API(PRDescIdentity) PR_GetLayersIdentity(PRFileDesc* fd);
+NSPR_API(PRFileDesc*) PR_GetIdentitiesLayer(PRFileDesc* fd_stack, PRDescIdentity id);
+
+/*
+ **************************************************************************
+ * PR_GetDefaultIOMethods: Accessing the default methods table.
+ * You may get a pointer to the default methods table by calling this function.
+ * You may then select any elements from that table with which to build your
+ * layer's methods table. You may NOT modify the table directly.
+ **************************************************************************
+ */
+NSPR_API(const PRIOMethods *) PR_GetDefaultIOMethods(void);
+
+/*
+ **************************************************************************
+ * Creating a layer
+ *
+ * A new layer may be allocated by calling PR_CreateIOLayerStub(). The
+ * file descriptor returned will contain the pointer to the methods table
+ * provided. The runtime will not modify the table nor test its correctness.
+ **************************************************************************
+ */
+NSPR_API(PRFileDesc*) PR_CreateIOLayerStub(
+    PRDescIdentity ident, const PRIOMethods *methods);
+
+/*
+ **************************************************************************
+ * Creating a layer
+ *
+ * A new stack may be created by calling PR_CreateIOLayer(). The
+ * file descriptor returned will point to the top of the stack, which has
+ * the layer 'fd' as the topmost layer.
+ * 
+ * NOTE: This function creates a new style stack, which has a fixed, dummy
+ * header. The old style stack, created by a call to PR_PushIOLayer,
+ * results in modifying contents of the top layer of the stack, when
+ * pushing and popping layers of the stack.
+ **************************************************************************
+ */
+NSPR_API(PRFileDesc*) PR_CreateIOLayer(PRFileDesc* fd);
+
+/*
+ **************************************************************************
+ * Pushing a layer
+ *
+ * A file descriptor (perhaps allocated using PR_CreateIOLayerStub()) may
+ * be pushed into an existing stack of file descriptors at any point the
+ * caller deems appropriate. The new layer will be inserted into the stack
+ * just above the layer with the indicated identity.
+ *
+ * Note: Even if the identity parameter indicates the top-most layer of
+ * the stack, the value of the file descriptor describing the original
+ * stack will not change.
+ **************************************************************************
+ */
+NSPR_API(PRStatus) PR_PushIOLayer(
+    PRFileDesc *fd_stack, PRDescIdentity id, PRFileDesc *layer);
+
+/*
+ **************************************************************************
+ * Popping a layer
+ *
+ * A layer may be popped from a stack by indicating the identity of the
+ * layer to be removed. If found, a pointer to the removed object will
+ * be returned to the caller. The object then becomes the responsibility
+ * of the caller.
+ *
+ * Note: Even if the identity indicates the top layer of the stack, the
+ * reference returned will not be the file descriptor for the stack and
+ * that file descriptor will remain valid.
+ **************************************************************************
+ */
+NSPR_API(PRFileDesc*) PR_PopIOLayer(PRFileDesc *fd_stack, PRDescIdentity id);
+
+/*
+ **************************************************************************
+ * FUNCTION:    PR_Open
+ * DESCRIPTION:    Open a file for reading, writing, or both.
+ * INPUTS:
+ *     const char *name
+ *         The path name of the file to be opened
+ *     PRIntn flags
+ *         The file status flags.
+ *         It is a bitwise OR of the following bit flags (only one of
+ *         the first three flags below may be used):
+ *		PR_RDONLY        Open for reading only.
+ *		PR_WRONLY        Open for writing only.
+ *		PR_RDWR          Open for reading and writing.
+ *		PR_CREATE_FILE   If the file does not exist, the file is created
+ *                              If the file exists, this flag has no effect.
+ *      PR_SYNC          If set, each write will wait for both the file data
+ *                              and file status to be physically updated.
+ *		PR_APPEND        The file pointer is set to the end of
+ *                              the file prior to each write.
+ *		PR_TRUNCATE      If the file exists, its length is truncated to 0.
+ *      PR_EXCL          With PR_CREATE_FILE, if the file does not exist,
+ *                              the file is created. If the file already 
+ *                              exists, no action and NULL is returned
+ *
+ *     PRIntn mode
+ *         The access permission bits of the file mode, if the file is
+ *         created when PR_CREATE_FILE is on.
+ * OUTPUTS:    None
+ * RETURNS:    PRFileDesc *
+ *     If the file is successfully opened,
+ *     returns a pointer to the PRFileDesc
+ *     created for the newly opened file.
+ *     Returns a NULL pointer if the open
+ *     failed.
+ * SIDE EFFECTS:
+ * RESTRICTIONS:
+ * MEMORY:
+ *     The return value, if not NULL, points to a dynamically allocated
+ *     PRFileDesc object.
+ * ALGORITHM:
+ **************************************************************************
+ */
+
+/* Open flags */
+#define PR_RDONLY       0x01
+#define PR_WRONLY       0x02
+#define PR_RDWR         0x04
+#define PR_CREATE_FILE  0x08
+#define PR_APPEND       0x10
+#define PR_TRUNCATE     0x20
+#define PR_SYNC         0x40
+#define PR_EXCL         0x80
+
+/*
+** File modes ....
+**
+** CAVEAT: 'mode' is currently only applicable on UNIX platforms.
+** The 'mode' argument may be ignored by PR_Open on other platforms.
+**
+**   00400   Read by owner.
+**   00200   Write by owner.
+**   00100   Execute (search if a directory) by owner.
+**   00040   Read by group.
+**   00020   Write by group.
+**   00010   Execute by group.
+**   00004   Read by others.
+**   00002   Write by others
+**   00001   Execute by others.
+**
+*/
+
+NSPR_API(PRFileDesc*) PR_Open(const char *name, PRIntn flags, PRIntn mode);
+
+/*
+ **************************************************************************
+ * FUNCTION: PR_OpenFile
+ * DESCRIPTION:
+ *     Open a file for reading, writing, or both.
+ *     PR_OpenFile has the same prototype as PR_Open but implements
+ *     the specified file mode where possible.
+ **************************************************************************
+ */
+
+/* File mode bits */
+#define PR_IRWXU 00700  /* read, write, execute/search by owner */
+#define PR_IRUSR 00400  /* read permission, owner */
+#define PR_IWUSR 00200  /* write permission, owner */
+#define PR_IXUSR 00100  /* execute/search permission, owner */
+#define PR_IRWXG 00070  /* read, write, execute/search by group */
+#define PR_IRGRP 00040  /* read permission, group */
+#define PR_IWGRP 00020  /* write permission, group */
+#define PR_IXGRP 00010  /* execute/search permission, group */
+#define PR_IRWXO 00007  /* read, write, execute/search by others */
+#define PR_IROTH 00004  /* read permission, others */
+#define PR_IWOTH 00002  /* write permission, others */
+#define PR_IXOTH 00001  /* execute/search permission, others */
+
+NSPR_API(PRFileDesc*) PR_OpenFile(
+    const char *name, PRIntn flags, PRIntn mode);
+
+#ifdef MOZ_UNICODE
+/*
+ * EXPERIMENTAL: This function may be removed in a future release.
+ */
+NSPR_API(PRFileDesc*) PR_OpenFileUTF16(
+    const PRUnichar *name, PRIntn flags, PRIntn mode);
+#endif /* MOZ_UNICODE */
+
+/*
+ **************************************************************************
+ * FUNCTION: PR_Close
+ * DESCRIPTION:
+ *     Close a file or socket.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *         a pointer to a PRFileDesc.
+ * OUTPUTS:
+ *     None.
+ * RETURN:
+ *     PRStatus
+ * SIDE EFFECTS:
+ * RESTRICTIONS:
+ *     None.
+ * MEMORY:
+ *     The dynamic memory pointed to by the argument fd is freed.
+ **************************************************************************
+ */
+
+NSPR_API(PRStatus)    PR_Close(PRFileDesc *fd);
+
+/*
+ **************************************************************************
+ * FUNCTION: PR_Read
+ * DESCRIPTION:
+ *     Read bytes from a file or socket.
+ *     The operation will block until either an end of stream indication is
+ *     encountered, some positive number of bytes are transferred, or there
+ *     is an error. No more than 'amount' bytes will be transferred.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *         pointer to the PRFileDesc object for the file or socket
+ *     void *buf
+ *         pointer to a buffer to hold the data read in.
+ *     PRInt32 amount
+ *         the size of 'buf' (in bytes)
+ * OUTPUTS:
+ * RETURN:
+ *     PRInt32
+ *         a positive number indicates the number of bytes actually read in.
+ *         0 means end of file is reached or the network connection is closed.
+ *         -1 indicates a failure. The reason for the failure is obtained
+ *         by calling PR_GetError().
+ * SIDE EFFECTS:
+ *     data is written into the buffer pointed to by 'buf'.
+ * RESTRICTIONS:
+ *     None.
+ * MEMORY:
+ *     N/A
+ * ALGORITHM:
+ *     N/A
+ **************************************************************************
+ */
+
+NSPR_API(PRInt32) PR_Read(PRFileDesc *fd, void *buf, PRInt32 amount);
+
+/*
+ ***************************************************************************
+ * FUNCTION: PR_Write
+ * DESCRIPTION:
+ *     Write a specified number of bytes to a file or socket.  The thread
+ *     invoking this function blocks until all the data is written.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *         pointer to a PRFileDesc object that refers to a file or socket
+ *     const void *buf
+ *         pointer to the buffer holding the data
+ *     PRInt32 amount
+ *         amount of data in bytes to be written from the buffer
+ * OUTPUTS:
+ *     None.
+ * RETURN: PRInt32
+ *     A positive number indicates the number of bytes successfully written.
+ *     A -1 is an indication that the operation failed. The reason
+ *     for the failure is obtained by calling PR_GetError().
+ ***************************************************************************
+ */
+
+NSPR_API(PRInt32) PR_Write(PRFileDesc *fd,const void *buf,PRInt32 amount);
+
+/*
+ ***************************************************************************
+ * FUNCTION: PR_Writev
+ * DESCRIPTION:
+ *     Write data to a socket.  The data is organized in a PRIOVec array. The
+ *     operation will block until all the data is written or the operation
+ *     fails.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *         Pointer that points to a PRFileDesc object for a socket.
+ *     const PRIOVec *iov
+ *         An array of PRIOVec.  PRIOVec is a struct with the following
+ *         two fields:
+ *             char *iov_base;
+ *             int iov_len;
+ *     PRInt32 iov_size
+ *         Number of elements in the iov array. The value of this
+ *         argument must not be greater than PR_MAX_IOVECTOR_SIZE.
+ *         If it is, the method will fail (PR_BUFFER_OVERFLOW_ERROR).
+ *     PRIntervalTime timeout
+ *       Time limit for completion of the entire write operation.
+ * OUTPUTS:
+ *     None
+ * RETURN:
+ *     A positive number indicates the number of bytes successfully written.
+ *     A -1 is an indication that the operation failed. The reason
+ *     for the failure is obtained by calling PR_GetError().
+ ***************************************************************************
+ */
+
+#define PR_MAX_IOVECTOR_SIZE 16   /* 'iov_size' must be <= */
+
+NSPR_API(PRInt32) PR_Writev(
+    PRFileDesc *fd, const PRIOVec *iov, PRInt32 iov_size,
+    PRIntervalTime timeout);
+
+/*
+ ***************************************************************************
+ * FUNCTION: PR_Delete
+ * DESCRIPTION:
+ *     Delete a file from the filesystem. The operation may fail if the
+ *     file is open.
+ * INPUTS:
+ *     const char *name
+ *         Path name of the file to be deleted.
+ * OUTPUTS:
+ *     None.
+ * RETURN: PRStatus
+ *     The function returns PR_SUCCESS if the file is successfully
+ *     deleted, otherwise it returns PR_FAILURE.
+ ***************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_Delete(const char *name);
+
+/**************************************************************************/
+
+typedef enum PRFileType
+{
+    PR_FILE_FILE = 1,
+    PR_FILE_DIRECTORY = 2,
+    PR_FILE_OTHER = 3
+} PRFileType;
+
+struct PRFileInfo {
+    PRFileType type;        /* Type of file */
+    PROffset32 size;        /* Size, in bytes, of file's contents */
+    PRTime creationTime;    /* Creation time per definition of PRTime */
+    PRTime modifyTime;      /* Last modification time per definition of PRTime */
+};
+
+struct PRFileInfo64 {
+    PRFileType type;        /* Type of file */
+    PROffset64 size;        /* Size, in bytes, of file's contents */
+    PRTime creationTime;    /* Creation time per definition of PRTime */
+    PRTime modifyTime;      /* Last modification time per definition of PRTime */
+};
+
+/****************************************************************************
+ * FUNCTION: PR_GetFileInfo, PR_GetFileInfo64
+ * DESCRIPTION:
+ *     Get the information about the file with the given path name. This is
+ *     applicable only to NSFileDesc describing 'file' types (see
+ * INPUTS:
+ *     const char *fn
+ *         path name of the file
+ * OUTPUTS:
+ *     PRFileInfo *info
+ *         Information about the given file is written into the file
+ *         information object pointer to by 'info'.
+ * RETURN: PRStatus
+ *     PR_GetFileInfo returns PR_SUCCESS if file information is successfully
+ *     obtained, otherwise it returns PR_FAILURE.
+ ***************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_GetFileInfo(const char *fn, PRFileInfo *info);
+NSPR_API(PRStatus) PR_GetFileInfo64(const char *fn, PRFileInfo64 *info);
+
+#ifdef MOZ_UNICODE
+/*
+ * EXPERIMENTAL: This function may be removed in a future release.
+ */
+NSPR_API(PRStatus) PR_GetFileInfo64UTF16(const PRUnichar *fn, PRFileInfo64 *info);
+#endif /* MOZ_UNICODE */
+
+/*
+ **************************************************************************
+ * FUNCTION: PR_GetOpenFileInfo, PR_GetOpenFileInfo64
+ * DESCRIPTION:
+ *     Get information about an open file referred to by the
+ *     given PRFileDesc object.
+ * INPUTS:
+ *     const PRFileDesc *fd
+ *          A reference to a valid, open file.
+ * OUTPUTS:
+ *     Same as PR_GetFileInfo, PR_GetFileInfo64
+ * RETURN: PRStatus
+ *     PR_GetFileInfo returns PR_SUCCESS if file information is successfully
+ *     obtained, otherwise it returns PR_FAILURE.
+ ***************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_GetOpenFileInfo(PRFileDesc *fd, PRFileInfo *info);
+NSPR_API(PRStatus) PR_GetOpenFileInfo64(PRFileDesc *fd, PRFileInfo64 *info);
+
+/*
+ **************************************************************************
+ * FUNCTION: PR_Rename
+ * DESCRIPTION:
+ *     Rename a file from the old name 'from' to the new name 'to'.
+ * INPUTS:
+ *     const char *from
+ *         The old name of the file to be renamed.
+ *     const char *to
+ *         The new name of the file.
+ * OUTPUTS:
+ *     None.
+ * RETURN: PRStatus
+ **************************************************************************
+ */
+
+NSPR_API(PRStatus)    PR_Rename(const char *from, const char *to);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Access
+ * DESCRIPTION:
+ *     Determine accessibility of a file.
+ * INPUTS:
+ *     const char *name
+ *         path name of the file
+ *     PRAccessHow how
+ *         specifies which access permission to check for.
+ *         It can be one of the following values:
+ *             PR_ACCESS_READ_OK       Test for read permission
+ *             PR_ACCESS_WRITE_OK      Test for write permission
+ *             PR_ACCESS_EXISTS        Check existence of file
+ * OUTPUTS:
+ *     None.
+ * RETURN: PRStatus
+ *     PR_SUCCESS is returned if the requested access is permitted.
+ *     Otherwise, PR_FAILURE is returned. Additional information
+ *     regarding the reason for the failure may be retrieved from
+ *     PR_GetError().
+ *************************************************************************
+ */
+
+typedef enum PRAccessHow {
+    PR_ACCESS_EXISTS = 1,
+    PR_ACCESS_WRITE_OK = 2,
+    PR_ACCESS_READ_OK = 3
+} PRAccessHow;
+
+NSPR_API(PRStatus) PR_Access(const char *name, PRAccessHow how);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Seek, PR_Seek64
+ * DESCRIPTION:
+ *     Moves read-write file offset
+ * INPUTS:
+ *     PRFileDesc *fd
+ *         Pointer to a PRFileDesc object.
+ *     PROffset32, PROffset64 offset
+ *         Specifies a value, in bytes, that is used in conjunction
+ *         with the 'whence' parameter to set the file pointer.  A
+ *         negative value causes seeking in the reverse direction.
+ *     PRSeekWhence whence
+ *         Specifies how to interpret the 'offset' parameter in setting
+ *         the file pointer associated with the 'fd' parameter.
+ *         Values for the 'whence' parameter are:
+ *             PR_SEEK_SET  Sets the file pointer to the value of the
+ *                          'offset' parameter
+ *             PR_SEEK_CUR  Sets the file pointer to its current location
+ *                          plus the value of the offset parameter.
+ *             PR_SEEK_END  Sets the file pointer to the size of the
+ *                          file plus the value of the offset parameter.
+ * OUTPUTS:
+ *     None.
+ * RETURN: PROffset32, PROffset64
+ *     Upon successful completion, the resulting pointer location,
+ *     measured in bytes from the beginning of the file, is returned.
+ *     If the PR_Seek() function fails, the file offset remains
+ *     unchanged, and the returned value is -1. The error code can
+ *     then be retrieved via PR_GetError().
+ *************************************************************************
+ */
+
+NSPR_API(PROffset32) PR_Seek(PRFileDesc *fd, PROffset32 offset, PRSeekWhence whence);
+NSPR_API(PROffset64) PR_Seek64(PRFileDesc *fd, PROffset64 offset, PRSeekWhence whence);
+
+/*
+ ************************************************************************
+ * FUNCTION: PR_Available
+ * DESCRIPTION:
+ *     Determine the amount of data in bytes available for reading
+ *     in the given file or socket.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *         Pointer to a PRFileDesc object that refers to a file or
+ *         socket.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRInt32, PRInt64
+ *     Upon successful completion, PR_Available returns the number of
+ *     bytes beyond the current read pointer that is available for
+ *     reading.  Otherwise, it returns a -1 and the reason for the
+ *     failure can be retrieved via PR_GetError().
+ ************************************************************************
+ */
+
+NSPR_API(PRInt32) PR_Available(PRFileDesc *fd);
+NSPR_API(PRInt64) PR_Available64(PRFileDesc *fd);
+
+/*
+ ************************************************************************
+ * FUNCTION: PR_Sync
+ * DESCRIPTION:
+ *     Sync any buffered data for a fd to its backing device (disk).
+ * INPUTS:
+ *     PRFileDesc *fd
+ *         Pointer to a PRFileDesc object that refers to a file or
+ *         socket
+ * OUTPUTS:
+ *     None
+ * RETURN: PRStatus
+ *     PR_SUCCESS is returned if the requested access is permitted.
+ *     Otherwise, PR_FAILURE is returned.
+ ************************************************************************
+ */
+
+NSPR_API(PRStatus)	PR_Sync(PRFileDesc *fd);
+
+/************************************************************************/
+
+struct PRDirEntry {
+    const char *name;        /* name of entry, relative to directory name */
+};
+
+#ifdef MOZ_UNICODE
+struct PRDirEntryUTF16 {
+    const PRUnichar *name;   /* name of entry in UTF16, relative to
+                              * directory name */
+};
+#endif /* MOZ_UNICODE */
+
+#if !defined(NO_NSPR_10_SUPPORT)
+#define PR_DirName(dirEntry)	(dirEntry->name)
+#endif
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_OpenDir
+ * DESCRIPTION:
+ *     Open the directory by the given name
+ * INPUTS:
+ *     const char *name
+ *         path name of the directory to be opened
+ * OUTPUTS:
+ *     None
+ * RETURN: PRDir *
+ *     If the directory is sucessfully opened, a PRDir object is
+ *     dynamically allocated and a pointer to it is returned.
+ *     If the directory cannot be opened, a NULL pointer is returned.
+ * MEMORY:
+ *     Upon successful completion, the return value points to
+ *     dynamically allocated memory.
+ *************************************************************************
+ */
+
+NSPR_API(PRDir*) PR_OpenDir(const char *name);
+
+#ifdef MOZ_UNICODE
+/*
+ * EXPERIMENTAL: This function may be removed in a future release.
+ */
+NSPR_API(PRDirUTF16*) PR_OpenDirUTF16(const PRUnichar *name);
+#endif /* MOZ_UNICODE */
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_ReadDir
+ * DESCRIPTION:
+ * INPUTS:
+ *     PRDir *dir
+ *         pointer to a PRDir object that designates an open directory
+ *     PRDirFlags flags
+ *           PR_SKIP_NONE     Do not skip any files
+ *           PR_SKIP_DOT      Skip the directory entry "." that
+ *                            represents the current directory
+ *           PR_SKIP_DOT_DOT  Skip the directory entry ".." that
+ *                            represents the parent directory.
+ *           PR_SKIP_BOTH     Skip both '.' and '..'
+ *           PR_SKIP_HIDDEN   Skip hidden files
+ * OUTPUTS:
+ * RETURN: PRDirEntry*
+ *     Returns a pointer to the next entry in the directory.  Returns
+ *     a NULL pointer upon reaching the end of the directory or when an
+ *     error occurs. The actual reason can be retrieved via PR_GetError().
+ *************************************************************************
+ */
+
+typedef enum PRDirFlags {
+    PR_SKIP_NONE = 0x0,
+    PR_SKIP_DOT = 0x1,
+    PR_SKIP_DOT_DOT = 0x2,
+    PR_SKIP_BOTH = 0x3,
+    PR_SKIP_HIDDEN = 0x4
+} PRDirFlags;
+
+NSPR_API(PRDirEntry*) PR_ReadDir(PRDir *dir, PRDirFlags flags);
+
+#ifdef MOZ_UNICODE
+/*
+ * EXPERIMENTAL: This function may be removed in a future release.
+ */
+NSPR_API(PRDirEntryUTF16*) PR_ReadDirUTF16(PRDirUTF16 *dir, PRDirFlags flags);
+#endif /* MOZ_UNICODE */
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_CloseDir
+ * DESCRIPTION:
+ *     Close the specified directory.
+ * INPUTS:
+ *     PRDir *dir
+ *        The directory to be closed.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRStatus
+ *        If successful, will return a status of PR_SUCCESS. Otherwise
+ *        a value of PR_FAILURE. The reason for the failure may be re-
+ *        trieved using PR_GetError().
+ *************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_CloseDir(PRDir *dir);
+
+#ifdef MOZ_UNICODE
+/*
+ * EXPERIMENTAL: This function may be removed in a future release.
+ */
+NSPR_API(PRStatus) PR_CloseDirUTF16(PRDirUTF16 *dir);
+#endif /* MOZ_UNICODE */
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_MkDir
+ * DESCRIPTION:
+ *     Create a new directory with the given name and access mode.
+ * INPUTS:
+ *     const char *name
+ *        The name of the directory to be created. All the path components
+ *        up to but not including the leaf component must already exist.
+ *     PRIntn mode
+ *        See 'mode' definiton in PR_Open().
+ * OUTPUTS:
+ *     None
+ * RETURN: PRStatus
+ *        If successful, will return a status of PR_SUCCESS. Otherwise
+ *        a value of PR_FAILURE. The reason for the failure may be re-
+ *        trieved using PR_GetError().
+ *************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_MkDir(const char *name, PRIntn mode);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_MakeDir
+ * DESCRIPTION:
+ *     Create a new directory with the given name and access mode.
+ *     PR_MakeDir has the same prototype as PR_MkDir but implements
+ *     the specified access mode where possible.
+ *************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_MakeDir(const char *name, PRIntn mode);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_RmDir
+ * DESCRIPTION:
+ *     Remove a directory by the given name.
+ * INPUTS:
+ *     const char *name
+ *        The name of the directory to be removed. All the path components
+ *        must already exist. Only the leaf component will be removed.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRStatus
+ *        If successful, will return a status of PR_SUCCESS. Otherwise
+ *        a value of PR_FAILURE. The reason for the failure may be re-
+ *        trieved using PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_RmDir(const char *name);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_NewUDPSocket
+ * DESCRIPTION:
+ *     Create a new UDP socket.
+ * INPUTS:
+ *     None
+ * OUTPUTS:
+ *     None
+ * RETURN: PRFileDesc*
+ *     Upon successful completion, PR_NewUDPSocket returns a pointer
+ *     to the PRFileDesc created for the newly opened UDP socket.
+ *     Returns a NULL pointer if the creation of a new UDP socket failed.
+ *
+ **************************************************************************
+ */
+
+NSPR_API(PRFileDesc*)    PR_NewUDPSocket(void);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_NewTCPSocket
+ * DESCRIPTION:
+ *     Create a new TCP socket.
+ * INPUTS:
+ *     None
+ * OUTPUTS:
+ *     None
+ * RETURN: PRFileDesc*
+ *     Upon successful completion, PR_NewTCPSocket returns a pointer
+ *     to the PRFileDesc created for the newly opened TCP socket.
+ *     Returns a NULL pointer if the creation of a new TCP socket failed.
+ *
+ **************************************************************************
+ */
+
+NSPR_API(PRFileDesc*)    PR_NewTCPSocket(void);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_OpenUDPSocket
+ * DESCRIPTION:
+ *     Create a new UDP socket of the specified address family.
+ * INPUTS:
+ *     PRIntn af
+ *       Address family
+ * OUTPUTS:
+ *     None
+ * RETURN: PRFileDesc*
+ *     Upon successful completion, PR_OpenUDPSocket returns a pointer
+ *     to the PRFileDesc created for the newly opened UDP socket.
+ *     Returns a NULL pointer if the creation of a new UDP socket failed.
+ *
+ **************************************************************************
+ */
+
+NSPR_API(PRFileDesc*)    PR_OpenUDPSocket(PRIntn af);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_OpenTCPSocket
+ * DESCRIPTION:
+ *     Create a new TCP socket of the specified address family.
+ * INPUTS:
+ *     PRIntn af
+ *       Address family
+ * OUTPUTS:
+ *     None
+ * RETURN: PRFileDesc*
+ *     Upon successful completion, PR_NewTCPSocket returns a pointer
+ *     to the PRFileDesc created for the newly opened TCP socket.
+ *     Returns a NULL pointer if the creation of a new TCP socket failed.
+ *
+ **************************************************************************
+ */
+
+NSPR_API(PRFileDesc*)    PR_OpenTCPSocket(PRIntn af);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Connect
+ * DESCRIPTION:
+ *     Initiate a connection on a socket.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       Points to a PRFileDesc object representing a socket
+ *     PRNetAddr *addr
+ *       Specifies the address of the socket in its own communication
+ *       space.
+ *     PRIntervalTime timeout
+ *       The function uses the lesser of the provided timeout and
+ *       the OS's connect timeout.  In particular, if you specify
+ *       PR_INTERVAL_NO_TIMEOUT as the timeout, the OS's connection
+ *       time limit will be used.
+ *
+ * OUTPUTS:
+ *     None
+ * RETURN: PRStatus
+ *     Upon successful completion of connection initiation, PR_Connect
+ *     returns PR_SUCCESS.  Otherwise, it returns PR_FAILURE.  Further
+ *     failure information can be obtained by calling PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_Connect(
+    PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_ConnectContinue
+ * DESCRIPTION:
+ *     Continue a nonblocking connect.  After a nonblocking connect
+ *     is initiated with PR_Connect() (which fails with
+ *     PR_IN_PROGRESS_ERROR), one should call PR_Poll() on the socket,
+ *     with the in_flags PR_POLL_WRITE | PR_POLL_EXCEPT.  When
+ *     PR_Poll() returns, one calls PR_ConnectContinue() on the
+ *     socket to determine whether the nonblocking connect has
+ *     completed or is still in progress.  Repeat the PR_Poll(),
+ *     PR_ConnectContinue() sequence until the nonblocking connect
+ *     has completed.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *         the file descriptor representing a socket
+ *     PRInt16 out_flags
+ *         the out_flags field of the poll descriptor returned by
+ *         PR_Poll()
+ * RETURN: PRStatus
+ *     If the nonblocking connect has successfully completed,
+ *     PR_ConnectContinue returns PR_SUCCESS.  If PR_ConnectContinue()
+ *     returns PR_FAILURE, call PR_GetError():
+ *     - PR_IN_PROGRESS_ERROR: the nonblocking connect is still in
+ *       progress and has not completed yet.  The caller should poll
+ *       on the file descriptor for the in_flags
+ *       PR_POLL_WRITE|PR_POLL_EXCEPT and retry PR_ConnectContinue
+ *       later when PR_Poll() returns.
+ *     - Other errors: the nonblocking connect has failed with this
+ *       error code.
+ */
+
+NSPR_API(PRStatus)    PR_ConnectContinue(PRFileDesc *fd, PRInt16 out_flags);
+
+/*
+ *************************************************************************
+ * THIS FUNCTION IS DEPRECATED.  USE PR_ConnectContinue INSTEAD.
+ *
+ * FUNCTION: PR_GetConnectStatus
+ * DESCRIPTION:
+ *     Get the completion status of a nonblocking connect.  After
+ *     a nonblocking connect is initiated with PR_Connect() (which
+ *     fails with PR_IN_PROGRESS_ERROR), one should call PR_Poll()
+ *     on the socket, with the in_flags PR_POLL_WRITE | PR_POLL_EXCEPT.
+ *     When PR_Poll() returns, one calls PR_GetConnectStatus on the
+ *     PRPollDesc structure to determine whether the nonblocking
+ *     connect has succeeded or failed.
+ * INPUTS:
+ *     const PRPollDesc *pd
+ *         Pointer to a PRPollDesc whose fd member is the socket,
+ *         and in_flags must contain PR_POLL_WRITE and PR_POLL_EXCEPT.
+ *         PR_Poll() should have been called and set the out_flags.
+ * RETURN: PRStatus
+ *     If the nonblocking connect has successfully completed,
+ *     PR_GetConnectStatus returns PR_SUCCESS.  If PR_GetConnectStatus()
+ *     returns PR_FAILURE, call PR_GetError():
+ *     - PR_IN_PROGRESS_ERROR: the nonblocking connect is still in
+ *       progress and has not completed yet.
+ *     - Other errors: the nonblocking connect has failed with this
+ *       error code.
+ */
+
+NSPR_API(PRStatus)    PR_GetConnectStatus(const PRPollDesc *pd);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Accept
+ * DESCRIPTION:
+ *     Accept a connection on a socket.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       Points to a PRFileDesc object representing the rendezvous socket
+ *       on which the caller is willing to accept new connections.
+ *     PRIntervalTime timeout
+ *       Time limit for completion of the accept operation.
+ * OUTPUTS:
+ *     PRNetAddr *addr
+ *       Returns the address of the connecting entity in its own
+ *       communication space. It may be NULL.
+ * RETURN: PRFileDesc*
+ *     Upon successful acceptance of a connection, PR_Accept
+ *     returns a valid file descriptor. Otherwise, it returns NULL.
+ *     Further failure information can be obtained by calling PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRFileDesc*) PR_Accept(
+    PRFileDesc *fd, PRNetAddr *addr, PRIntervalTime timeout);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Bind
+ * DESCRIPTION:
+ *    Bind an address to a socket.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       Points to a PRFileDesc object representing a socket.
+ *     PRNetAddr *addr
+ *       Specifies the address to which the socket will be bound.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRStatus
+ *     Upon successful binding of an address to a socket, PR_Bind
+ *     returns PR_SUCCESS.  Otherwise, it returns PR_FAILURE.  Further
+ *     failure information can be obtained by calling PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_Bind(PRFileDesc *fd, const PRNetAddr *addr);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Listen
+ * DESCRIPTION:
+ *    Listen for connections on a socket.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       Points to a PRFileDesc object representing a socket that will be
+ *       used to listen for new connections.
+ *     PRIntn backlog
+ *       Specifies the maximum length of the queue of pending connections.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRStatus
+ *     Upon successful completion of listen request, PR_Listen
+ *     returns PR_SUCCESS.  Otherwise, it returns PR_FAILURE.  Further
+ *     failure information can be obtained by calling PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRStatus) PR_Listen(PRFileDesc *fd, PRIntn backlog);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Shutdown
+ * DESCRIPTION:
+ *    Shut down part of a full-duplex connection on a socket.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       Points to a PRFileDesc object representing a connected socket.
+ *     PRIntn how
+ *       Specifies the kind of disallowed operations on the socket.
+ *           PR_SHUTDOWN_RCV - Further receives will be disallowed
+ *           PR_SHUTDOWN_SEND - Further sends will be disallowed
+ *           PR_SHUTDOWN_BOTH - Further sends and receives will be disallowed
+ * OUTPUTS:
+ *     None
+ * RETURN: PRStatus
+ *     Upon successful completion of shutdown request, PR_Shutdown
+ *     returns PR_SUCCESS.  Otherwise, it returns PR_FAILURE.  Further
+ *     failure information can be obtained by calling PR_GetError().
+ **************************************************************************
+ */
+
+typedef enum PRShutdownHow
+{
+    PR_SHUTDOWN_RCV = 0,      /* disallow further receives */
+    PR_SHUTDOWN_SEND = 1,     /* disallow further sends */
+    PR_SHUTDOWN_BOTH = 2      /* disallow further receives and sends */
+} PRShutdownHow;
+
+NSPR_API(PRStatus)    PR_Shutdown(PRFileDesc *fd, PRShutdownHow how);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Recv
+ * DESCRIPTION:
+ *    Receive a specified number of bytes from a connected socket.
+ *     The operation will block until some positive number of bytes are 
+ *     transferred, a time out has occurred, or there is an error. 
+ *     No more than 'amount' bytes will be transferred.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       points to a PRFileDesc object representing a socket.
+ *     void *buf
+ *       pointer to a buffer to hold the data received.
+ *     PRInt32 amount
+ *       the size of 'buf' (in bytes)
+ *     PRIntn flags
+ *       must be zero or PR_MSG_PEEK.
+ *     PRIntervalTime timeout
+ *       Time limit for completion of the receive operation.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRInt32
+ *         a positive number indicates the number of bytes actually received.
+ *         0 means the network connection is closed.
+ *         -1 indicates a failure. The reason for the failure is obtained
+ *         by calling PR_GetError().
+ **************************************************************************
+ */
+
+#define PR_MSG_PEEK 0x2
+
+NSPR_API(PRInt32)    PR_Recv(PRFileDesc *fd, void *buf, PRInt32 amount,
+                PRIntn flags, PRIntervalTime timeout);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_Send
+ * DESCRIPTION:
+ *    Send a specified number of bytes from a connected socket.
+ *     The operation will block until all bytes are 
+ *     processed, a time out has occurred, or there is an error. 
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       points to a PRFileDesc object representing a socket.
+ *     void *buf
+ *       pointer to a buffer from where the data is sent.
+ *     PRInt32 amount
+ *       the size of 'buf' (in bytes)
+ *     PRIntn flags
+ *        (OBSOLETE - must always be zero)
+ *     PRIntervalTime timeout
+ *       Time limit for completion of the send operation.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRInt32
+ *     A positive number indicates the number of bytes successfully processed.
+ *     This number must always equal 'amount'. A -1 is an indication that the
+ *     operation failed. The reason for the failure is obtained by calling
+ *     PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRInt32)    PR_Send(PRFileDesc *fd, const void *buf, PRInt32 amount,
+                                PRIntn flags, PRIntervalTime timeout);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_RecvFrom
+ * DESCRIPTION:
+ *     Receive up to a specified number of bytes from socket which may
+ *     or may not be connected.
+ *     The operation will block until one or more bytes are 
+ *     transferred, a time out has occurred, or there is an error. 
+ *     No more than 'amount' bytes will be transferred.
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       points to a PRFileDesc object representing a socket.
+ *     void *buf
+ *       pointer to a buffer to hold the data received.
+ *     PRInt32 amount
+ *       the size of 'buf' (in bytes)
+ *     PRIntn flags
+ *        (OBSOLETE - must always be zero)
+ *     PRNetAddr *addr
+ *       Specifies the address of the sending peer. It may be NULL.
+ *     PRIntervalTime timeout
+ *       Time limit for completion of the receive operation.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRInt32
+ *         a positive number indicates the number of bytes actually received.
+ *         0 means the network connection is closed.
+ *         -1 indicates a failure. The reason for the failure is obtained
+ *         by calling PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRInt32) PR_RecvFrom(
+    PRFileDesc *fd, void *buf, PRInt32 amount, PRIntn flags,
+    PRNetAddr *addr, PRIntervalTime timeout);
+
+/*
+ *************************************************************************
+ * FUNCTION: PR_SendTo
+ * DESCRIPTION:
+ *    Send a specified number of bytes from an unconnected socket.
+ *    The operation will block until all bytes are 
+ *    sent, a time out has occurred, or there is an error. 
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       points to a PRFileDesc object representing an unconnected socket.
+ *     void *buf
+ *       pointer to a buffer from where the data is sent.
+ *     PRInt32 amount
+ *       the size of 'buf' (in bytes)
+ *     PRIntn flags
+ *        (OBSOLETE - must always be zero)
+ *     PRNetAddr *addr
+ *       Specifies the address of the peer.
+.*     PRIntervalTime timeout
+ *       Time limit for completion of the send operation.
+ * OUTPUTS:
+ *     None
+ * RETURN: PRInt32
+ *     A positive number indicates the number of bytes successfully sent.
+ *     -1 indicates a failure. The reason for the failure is obtained
+ *     by calling PR_GetError().
+ **************************************************************************
+ */
+
+NSPR_API(PRInt32) PR_SendTo(
+    PRFileDesc *fd, const void *buf, PRInt32 amount, PRIntn flags,
+    const PRNetAddr *addr, PRIntervalTime timeout);
+
+/*
+*************************************************************************
+** FUNCTION: PR_TransmitFile
+** DESCRIPTION:
+**    Transmitfile sends a complete file (sourceFile) across a socket 
+**    (networkSocket).  If headers is non-NULL, the headers will be sent across
+**    the socket prior to sending the file.
+** 
+**    Optionally, the PR_TRANSMITFILE_CLOSE_SOCKET flag may be passed to
+**    transmitfile.  This flag specifies that transmitfile should close the
+**    socket after sending the data.
+**
+** INPUTS:
+**    PRFileDesc *networkSocket
+**        The socket to send data over
+**    PRFileDesc *sourceFile
+**        The file to send
+**    const void *headers
+**        A pointer to headers to be sent before sending data
+**    PRInt32       hlen
+**        length of header buffers in bytes.
+**    PRTransmitFileFlags       flags
+**        If the flags indicate that the connection should be closed,
+**        it will be done immediately after transferring the file, unless
+**        the operation is unsuccessful. 
+.*     PRIntervalTime timeout
+ *        Time limit for completion of the transmit operation.
+**
+** RETURNS:
+**    Returns the number of bytes written or -1 if the operation failed.
+**    If an error occurs while sending the file, the PR_TRANSMITFILE_CLOSE_
+**    SOCKET flag is ignored. The reason for the failure is obtained
+**    by calling PR_GetError().
+**************************************************************************
+*/
+
+NSPR_API(PRInt32) PR_TransmitFile(
+    PRFileDesc *networkSocket, PRFileDesc *sourceFile,
+    const void *headers, PRInt32 hlen, PRTransmitFileFlags flags,
+    PRIntervalTime timeout);
+
+/*
+*************************************************************************
+** FUNCTION: PR_SendFile
+** DESCRIPTION:
+**    PR_SendFile sends data from a file (sendData->fd) across a socket 
+**    (networkSocket).  If specified, a header and/or trailer buffer are sent
+**	  before and after the file, respectively. The file offset, number of bytes
+** 	  of file data to send, the header and trailer buffers are specified in the
+**	  sendData argument.
+** 
+**    Optionally, if the PR_TRANSMITFILE_CLOSE_SOCKET flag is passed, the
+**    socket is closed after successfully sending the data.
+**
+** INPUTS:
+**    PRFileDesc *networkSocket
+**        The socket to send data over
+**    PRSendFileData *sendData
+**        Contains the FD, file offset and length, header and trailer
+**		  buffer specifications.
+**    PRTransmitFileFlags       flags
+**        If the flags indicate that the connection should be closed,
+**        it will be done immediately after transferring the file, unless
+**        the operation is unsuccessful. 
+.*     PRIntervalTime timeout
+ *        Time limit for completion of the send operation.
+**
+** RETURNS:
+**    Returns the number of bytes written or -1 if the operation failed.
+**    If an error occurs while sending the file, the PR_TRANSMITFILE_CLOSE_
+**    SOCKET flag is ignored. The reason for the failure is obtained
+**    by calling PR_GetError().
+**************************************************************************
+*/
+
+struct PRSendFileData {
+	PRFileDesc	*fd;			/* file to send							*/
+	PRUint32	file_offset;	/* file offset							*/
+	PRSize		file_nbytes;	/* number of bytes of file data to send	*/
+								/* if 0, send data from file_offset to	*/
+								/* end-of-file.							*/
+	const void	*header;		/* header buffer						*/
+	PRInt32		hlen;			/* header len							*/
+	const void	*trailer;		/* trailer buffer						*/
+	PRInt32		tlen;			/* trailer len							*/
+};
+
+
+NSPR_API(PRInt32) PR_SendFile(
+    PRFileDesc *networkSocket, PRSendFileData *sendData,
+	PRTransmitFileFlags flags, PRIntervalTime timeout);
+
+/*
+*************************************************************************
+** FUNCTION: PR_AcceptRead
+** DESCRIPTION:
+**    AcceptRead accepts a new connection, returns the newly created
+**    socket's descriptor and also returns the connecting peer's address.
+**    AcceptRead, as its name suggests, also receives the first block of data 
+**    sent by the peer.
+**
+** INPUTS:
+**    PRFileDesc *listenSock
+**        A socket descriptor that has been called with the PR_Listen() 
+**        function, also known as the rendezvous socket.
+**    void *buf
+**        A pointer to a buffer to receive data sent by the client.  This 
+**        buffer must be large enough to receive <amount> bytes of data
+**        and two PRNetAddr structures, plus an extra 32 bytes. See:
+**        PR_ACCEPT_READ_BUF_OVERHEAD.
+**    PRInt32 amount
+**        The number of bytes of client data to receive.  Does not include
+**        the size of the PRNetAddr structures.  If 0, no data will be read
+**        from the client.
+**    PRIntervalTime timeout
+**        The timeout interval only applies to the read portion of the 
+**        operation.  PR_AcceptRead will block indefinitely until the 
+**        connection is accepted; the read will timeout after the timeout 
+**        interval elapses.
+** OUTPUTS:
+**    PRFileDesc **acceptedSock
+**        The file descriptor for the newly connected socket.  This parameter
+**        will only be valid if the function return does not indicate failure.
+**    PRNetAddr  **peerAddr,
+**        The address of the remote socket.  This parameter will only be
+**        valid if the function return does not indicate failure.  The
+**        returned address is not guaranteed to be properly aligned.
+** 
+** RETURNS:
+**     The number of bytes read from the client or -1 on failure.  The reason 
+**     for the failure is obtained by calling PR_GetError().
+**************************************************************************
+**/       
+/* define buffer overhead constant. Add this value to the user's 
+** data length when allocating a buffer to accept data.
+**    Example:
+**    #define USER_DATA_SIZE 10
+**    char buf[USER_DATA_SIZE + PR_ACCEPT_READ_BUF_OVERHEAD];
+**    bytesRead = PR_AcceptRead( s, fd, &a, &p, USER_DATA_SIZE, ...);
+*/
+#define PR_ACCEPT_READ_BUF_OVERHEAD (32+(2*sizeof(PRNetAddr)))
+
+NSPR_API(PRInt32) PR_AcceptRead(
+    PRFileDesc *listenSock, PRFileDesc **acceptedSock,
+    PRNetAddr **peerAddr, void *buf, PRInt32 amount, PRIntervalTime timeout);
+
+/*
+*************************************************************************
+** FUNCTION: PR_NewTCPSocketPair
+** DESCRIPTION:
+**    Create a new TCP socket pair. The returned descriptors can be used
+**    interchangeably; they are interconnected full-duplex descriptors: data
+**    written to one can be read from the other and vice-versa.
+**
+** INPUTS:
+**    None
+** OUTPUTS:
+**    PRFileDesc *fds[2]
+**        The file descriptor pair for the newly created TCP sockets.
+** RETURN: PRStatus
+**     Upon successful completion of TCP socket pair, PR_NewTCPSocketPair 
+**     returns PR_SUCCESS.  Otherwise, it returns PR_FAILURE.  Further
+**     failure information can be obtained by calling PR_GetError().
+** XXX can we implement this on windoze and mac?
+**************************************************************************
+**/
+NSPR_API(PRStatus) PR_NewTCPSocketPair(PRFileDesc *fds[2]);
+
+/*
+*************************************************************************
+** FUNCTION: PR_GetSockName
+** DESCRIPTION:
+**    Get socket name.  Return the network address for this socket.
+**
+** INPUTS:
+**     PRFileDesc *fd
+**       Points to a PRFileDesc object representing the socket.
+** OUTPUTS:
+**     PRNetAddr *addr
+**       Returns the address of the socket in its own communication space.
+** RETURN: PRStatus
+**     Upon successful completion, PR_GetSockName returns PR_SUCCESS.  
+**     Otherwise, it returns PR_FAILURE.  Further failure information can 
+**     be obtained by calling PR_GetError().
+**************************************************************************
+**/
+NSPR_API(PRStatus)	PR_GetSockName(PRFileDesc *fd, PRNetAddr *addr);
+
+/*
+*************************************************************************
+** FUNCTION: PR_GetPeerName
+** DESCRIPTION:
+**    Get name of the connected peer.  Return the network address for the 
+**    connected peer socket.
+**
+** INPUTS:
+**     PRFileDesc *fd
+**       Points to a PRFileDesc object representing the connected peer.
+** OUTPUTS:
+**     PRNetAddr *addr
+**       Returns the address of the connected peer in its own communication
+**       space.
+** RETURN: PRStatus
+**     Upon successful completion, PR_GetPeerName returns PR_SUCCESS.  
+**     Otherwise, it returns PR_FAILURE.  Further failure information can 
+**     be obtained by calling PR_GetError().
+**************************************************************************
+**/
+NSPR_API(PRStatus)	PR_GetPeerName(PRFileDesc *fd, PRNetAddr *addr);
+
+NSPR_API(PRStatus)	PR_GetSocketOption(
+    PRFileDesc *fd, PRSocketOptionData *data);
+
+NSPR_API(PRStatus)	PR_SetSocketOption(
+    PRFileDesc *fd, const PRSocketOptionData *data);
+
+/*
+ *********************************************************************
+ *
+ * File descriptor inheritance
+ *
+ *********************************************************************
+ */
+
+/*
+ ************************************************************************
+ * FUNCTION: PR_SetFDInheritable
+ * DESCRIPTION:
+ *    Set the inheritance attribute of a file descriptor.
+ *
+ * INPUTS:
+ *     PRFileDesc *fd
+ *       Points to a PRFileDesc object.
+ *     PRBool inheritable
+ *       If PR_TRUE, the file descriptor fd is set to be inheritable
+ *       by a child process.  If PR_FALSE, the file descriptor is set
+ *       to be not inheritable by a child process.
+ * RETURN: PRStatus
+ *     Upon successful completion, PR_SetFDInheritable returns PR_SUCCESS.  
+ *     Otherwise, it returns PR_FAILURE.  Further failure information can 
+ *     be obtained by calling PR_GetError().
+ *************************************************************************
+ */
+NSPR_API(PRStatus) PR_SetFDInheritable(
+    PRFileDesc *fd,
+    PRBool inheritable);
+
+/*
+ ************************************************************************
+ * FUNCTION: PR_GetInheritedFD
+ * DESCRIPTION:
+ *    Get an inherited file descriptor with the specified name.
+ *
+ * INPUTS:
+ *     const char *name
+ *       The name of the inherited file descriptor.
+ * RETURN: PRFileDesc *
+ *     Upon successful completion, PR_GetInheritedFD returns the
+ *     inherited file descriptor with the specified name.  Otherwise,  
+ *     it returns NULL.  Further failure information can be obtained
+ *     by calling PR_GetError().
+ *************************************************************************
+ */
+NSPR_API(PRFileDesc *) PR_GetInheritedFD(const char *name);
+
+/*
+ *********************************************************************
+ *
+ * Memory-mapped files
+ *
+ *********************************************************************
+ */
+
+typedef struct PRFileMap PRFileMap;
+
+/*
+ * protection options for read and write accesses of a file mapping
+ */
+typedef enum PRFileMapProtect {
+    PR_PROT_READONLY,     /* read only */
+    PR_PROT_READWRITE,    /* readable, and write is shared */
+    PR_PROT_WRITECOPY     /* readable, and write is private (copy-on-write) */
+} PRFileMapProtect;
+
+NSPR_API(PRFileMap *) PR_CreateFileMap(
+    PRFileDesc *fd,
+    PRInt64 size,
+    PRFileMapProtect prot);
+
+/*
+ * return the alignment (in bytes) of the offset argument to PR_MemMap
+ */
+NSPR_API(PRInt32) PR_GetMemMapAlignment(void);
+
+NSPR_API(void *) PR_MemMap(
+    PRFileMap *fmap,
+    PROffset64 offset,  /* must be aligned and sized according to the
+                         * return value of PR_GetMemMapAlignment() */
+    PRUint32 len);
+
+NSPR_API(PRStatus) PR_MemUnmap(void *addr, PRUint32 len);
+
+NSPR_API(PRStatus) PR_CloseFileMap(PRFileMap *fmap);
+
+/*
+ * Synchronously flush the given memory-mapped address range of the given open
+ * file to disk. The function does not return until all modified data have
+ * been written to disk.
+ *
+ * On some platforms, the function will call PR_Sync(fd) internally if it is
+ * necessary for flushing modified data to disk synchronously.
+ */
+NSPR_API(PRStatus) PR_SyncMemMap(
+    PRFileDesc *fd,
+    void *addr,
+    PRUint32 len);
+
+/*
+ ******************************************************************
+ *
+ * Interprocess communication
+ *
+ ******************************************************************
+ */
+
+/*
+ * Creates an anonymous pipe and returns file descriptors for the
+ * read and write ends of the pipe.
+ */
+
+NSPR_API(PRStatus) PR_CreatePipe(
+    PRFileDesc **readPipe,
+    PRFileDesc **writePipe
+);
+
+/************************************************************************/
+/************** The following definitions are for poll ******************/
+/************************************************************************/
+
+struct PRPollDesc {
+    PRFileDesc* fd;
+    PRInt16 in_flags;
+    PRInt16 out_flags;
+};
+
+/*
+** Bit values for PRPollDesc.in_flags or PRPollDesc.out_flags. Binary-or
+** these together to produce the desired poll request.
+*/
+
+#if defined(_PR_POLL_BACKCOMPAT)
+
+#include <poll.h>
+#define PR_POLL_READ    POLLIN
+#define PR_POLL_WRITE   POLLOUT
+#define PR_POLL_EXCEPT  POLLPRI
+#define PR_POLL_ERR     POLLERR     /* only in out_flags */
+#define PR_POLL_NVAL    POLLNVAL    /* only in out_flags when fd is bad */
+#define PR_POLL_HUP     POLLHUP     /* only in out_flags */
+
+#else  /* _PR_POLL_BACKCOMPAT */
+
+#define PR_POLL_READ    0x1
+#define PR_POLL_WRITE   0x2
+#define PR_POLL_EXCEPT  0x4
+#define PR_POLL_ERR     0x8         /* only in out_flags */
+#define PR_POLL_NVAL    0x10        /* only in out_flags when fd is bad */
+#define PR_POLL_HUP     0x20        /* only in out_flags */
+
+#endif  /* _PR_POLL_BACKCOMPAT */
+
+/*
+*************************************************************************
+** FUNCTION:    PR_Poll
+** DESCRIPTION:
+**
+** The call returns as soon as I/O is ready on one or more of the underlying
+** socket objects. A count of the number of ready descriptors is
+** returned unless a timeout occurs in which case zero is returned.
+**
+** PRPollDesc.fd should be set to a pointer to a PRFileDesc object
+** representing a socket. This field can be set to NULL to indicate to
+** PR_Poll that this PRFileDesc object should be ignored.
+** PRPollDesc.in_flags should be set to the desired request
+** (read/write/except or some combination). Upon successful return from
+** this call PRPollDesc.out_flags will be set to indicate what kind of
+** i/o can be performed on the respective descriptor. PR_Poll() uses the
+** out_flags fields as scratch variables during the call. If PR_Poll()
+** returns 0 or -1, the out_flags fields do not contain meaningful values
+** and must not be used.
+**
+** INPUTS:
+**      PRPollDesc *pds         A pointer to an array of PRPollDesc
+**
+**      PRIntn npds             The number of elements in the array
+**                              If this argument is zero PR_Poll is
+**                              equivalent to a PR_Sleep(timeout).
+**
+**      PRIntervalTime timeout  Amount of time the call will block waiting
+**                              for I/O to become ready. If this time expires
+**                              w/o any I/O becoming ready, the result will
+**                              be zero.
+**
+** OUTPUTS:    None
+** RETURN:
+**      PRInt32                 Number of PRPollDesc's with events or zero
+**                              if the function timed out or -1 on failure.
+**                              The reason for the failure is obtained by
+**                              calling PR_GetError().
+**************************************************************************
+*/
+NSPR_API(PRInt32) PR_Poll(
+    PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout);
+
+/*
+**************************************************************************
+**
+** Pollable events
+**
+** A pollable event is a special kind of file descriptor.
+** The only I/O operation you can perform on a pollable event
+** is to poll it with the PR_POLL_READ flag.  You can't
+** read from or write to a pollable event.
+**
+** The purpose of a pollable event is to combine event waiting
+** with I/O waiting in a single PR_Poll call.  Pollable events
+** are implemented using a pipe or a pair of TCP sockets
+** connected via the loopback address, therefore setting and
+** waiting for pollable events are expensive operating system
+** calls.  Do not use pollable events for general thread
+** synchronization. Use condition variables instead.
+**
+** A pollable event has two states: set and unset.  Events
+** are not queued, so there is no notion of an event count.
+** A pollable event is either set or unset.
+**
+** A new pollable event is created by a PR_NewPollableEvent
+** call and is initially in the unset state.
+**
+** PR_WaitForPollableEvent blocks the calling thread until
+** the pollable event is set, and then it atomically unsets
+** the pollable event before it returns.
+**
+** To set a pollable event, call PR_SetPollableEvent.
+**
+** One can call PR_Poll with the PR_POLL_READ flag on a pollable
+** event.  When the pollable event is set, PR_Poll returns with
+** the PR_POLL_READ flag set in the out_flags.
+**
+** To close a pollable event, call PR_DestroyPollableEvent
+** (not PR_Close).
+**
+**************************************************************************
+*/
+
+NSPR_API(PRFileDesc *) PR_NewPollableEvent(void);
+
+NSPR_API(PRStatus) PR_DestroyPollableEvent(PRFileDesc *event);
+
+NSPR_API(PRStatus) PR_SetPollableEvent(PRFileDesc *event);
+
+NSPR_API(PRStatus) PR_WaitForPollableEvent(PRFileDesc *event);
+
+PR_END_EXTERN_C
+
+#endif /* prio_h___ */
diff --git a/js/src/prlink.h b/js/src/prlink.h
new file mode 100644
--- /dev/null
+++ b/js/src/prlink.h
@@ -0,0 +1,230 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef prlink_h___
+#define prlink_h___
+
+/*
+** API to static and dynamic linking.
+*/
+#include "prtypes.h"
+
+PR_BEGIN_EXTERN_C
+
+typedef struct PRLibrary PRLibrary;
+
+typedef struct PRStaticLinkTable {
+    const char *name;
+    void (*fp)(void);
+} PRStaticLinkTable;
+
+/*
+** Change the default library path to the given string. The string is
+** copied. This call will fail if it runs out of memory.
+**
+** The string provided as 'path' is copied. The caller can do whatever is
+** convenient with the argument when the function is complete.
+*/
+NSPR_API(PRStatus) PR_SetLibraryPath(const char *path);
+
+/*
+** Return a character string which contains the path used to search for
+** dynamically loadable libraries.
+**
+** The returned value is basically a copy of a PR_SetLibraryPath().
+** The storage is allocated by the runtime and becomes the responsibilty
+** of the caller.
+*/
+NSPR_API(char*) PR_GetLibraryPath(void);
+
+/*
+** Given a directory name "dir" and a library name "lib" construct a full
+** path name that will refer to the actual dynamically loaded
+** library. This does not test for existance of said file, it just
+** constructs the full filename. The name constructed is system dependent
+** and prepared for PR_LoadLibrary. The result must be free'd when the
+** caller is done with it.
+**
+** The storage for the result is allocated by the runtime and becomes the
+** responsibility of the caller.
+*/
+NSPR_API(char*) PR_GetLibraryName(const char *dir, const char *lib);
+
+/*
+**
+** Free the memory allocated, for the caller, by PR_GetLibraryName
+*/
+NSPR_API(void) PR_FreeLibraryName(char *mem);
+
+/*
+** Given a library "name" try to load the library. The argument "name"
+** is a machine-dependent name for the library, such as the full pathname
+** returned by PR_GetLibraryName.  If the library is already loaded,
+** this function will avoid loading the library twice.
+**
+** If the library is loaded successfully, then a pointer to the PRLibrary
+** structure representing the library is returned.  Otherwise, NULL is
+** returned.
+**
+** This increments the reference count of the library.
+*/
+NSPR_API(PRLibrary*) PR_LoadLibrary(const char *name);
+
+/*
+** Each operating system has its preferred way of specifying
+** a file in the file system.  Most operating systems use
+** a pathname.  Mac OS Classic, on the other hand, uses the FSSpec
+** structure to specify a file. PRLibSpec allows NSPR clients
+** to use the type of file specification that is most efficient
+** for a particular platform.
+**
+** On some operating systems such as Mac OS Classic, a shared library
+** may contain code fragments that can be individually loaded.
+** PRLibSpec also allows NSPR clients to identify a code fragment
+** in a library, if code fragments are supported by the OS.
+** A code fragment can be specified by name or by an integer index.
+**
+** Right now PRLibSpec supports four types of library specification:
+** a pathname in the native character encoding, a Mac code fragment
+** by name, a Mac code fragment by index, and a UTF-16 pathname.
+*/
+
+typedef enum PRLibSpecType {
+    PR_LibSpec_Pathname,
+    PR_LibSpec_MacNamedFragment,   /* obsolete (for Mac OS Classic) */
+    PR_LibSpec_MacIndexedFragment, /* obsolete (for Mac OS Classic) */
+    PR_LibSpec_PathnameU           /* supported only on Win32 */ 
+} PRLibSpecType;
+
+struct FSSpec; /* Mac OS Classic FSSpec */
+
+typedef struct PRLibSpec {
+    PRLibSpecType type;
+    union {
+        /* if type is PR_LibSpec_Pathname */
+        const char *pathname;
+
+        /* if type is PR_LibSpec_MacNamedFragment */
+        struct {
+            const struct FSSpec *fsspec;
+            const char *name;
+        } mac_named_fragment;      /* obsolete (for Mac OS Classic) */
+
+        /* if type is PR_LibSpec_MacIndexedFragment */
+        struct {
+            const struct FSSpec *fsspec;
+            PRUint32 index;
+        } mac_indexed_fragment;    /* obsolete (for Mac OS Classic) */
+
+        /* if type is PR_LibSpec_PathnameU */
+        const PRUnichar *pathname_u; /* supported only on Win32 */
+    } value;
+} PRLibSpec;
+
+/*
+** The following bit flags may be or'd together and passed
+** as the 'flags' argument to PR_LoadLibraryWithFlags.
+** Flags not supported by the underlying OS are ignored.
+*/
+
+#define PR_LD_LAZY   0x1  /* equivalent to RTLD_LAZY on Unix */
+#define PR_LD_NOW    0x2  /* equivalent to RTLD_NOW on Unix */
+#define PR_LD_GLOBAL 0x4  /* equivalent to RTLD_GLOBAL on Unix */
+#define PR_LD_LOCAL  0x8  /* equivalent to RTLD_LOCAL on Unix */
+/* The following is equivalent to LOAD_WITH_ALTERED_SEARCH_PATH on Windows */
+#define PR_LD_ALT_SEARCH_PATH  0x10  
+/*                0x8000     reserved for NSPR internal use */
+
+/*
+** Load the specified library, in the manner specified by 'flags'.
+*/
+
+NSPR_API(PRLibrary *)
+PR_LoadLibraryWithFlags(
+    PRLibSpec libSpec,    /* the shared library */
+    PRIntn flags          /* flags that affect the loading */
+);
+
+/*
+** Unload a previously loaded library. If the library was a static
+** library then the static link table will no longer be referenced. The
+** associated PRLibrary object is freed.
+**
+** PR_FAILURE is returned if the library cannot be unloaded.
+**
+** This function decrements the reference count of the library.
+*/
+NSPR_API(PRStatus) PR_UnloadLibrary(PRLibrary *lib);
+
+/*
+** Given the name of a procedure, return the address of the function that
+** implements the procedure, or NULL if no such function can be
+** found. This does not find symbols in the main program (the ".exe");
+** use PR_LoadStaticLibrary to register symbols in the main program.
+**
+** This function does not modify the reference count of the library.
+*/
+NSPR_API(void*) PR_FindSymbol(PRLibrary *lib, const char *name);
+
+/*
+** Similar to PR_FindSymbol, except that the return value is a pointer to
+** a function, and not a pointer to void. Casting between a data pointer
+** and a function pointer is not portable according to the C standard.
+** Any function pointer can be cast to any other function pointer.
+**
+** This function does not modify the reference count of the library.
+*/
+typedef void (*PRFuncPtr)(void);
+NSPR_API(PRFuncPtr) PR_FindFunctionSymbol(PRLibrary *lib, const char *name);
+
+/*
+** Finds a symbol in one of the currently loaded libraries. Given the
+** name of a procedure, return the address of the function that
+** implements the procedure, and return the library that contains that
+** symbol, or NULL if no such function can be found. This does not find
+** symbols in the main program (the ".exe"); use PR_AddStaticLibrary to
+** register symbols in the main program.  
+**
+** This increments the reference count of the library.
+*/
+NSPR_API(void*) PR_FindSymbolAndLibrary(const char *name,
+						      PRLibrary* *lib);
+
+/*
+** Similar to PR_FindSymbolAndLibrary, except that the return value is
+** a pointer to a function, and not a pointer to void. Casting between a
+** data pointer and a function pointer is not portable according to the C
+** standard. Any function pointer can be cast to any other function pointer.
+**
+** This increments the reference count of the library.
+*/
+NSPR_API(PRFuncPtr) PR_FindFunctionSymbolAndLibrary(const char *name,
+						      PRLibrary* *lib);
+
+/*
+** Register a static link table with the runtime under the name
+** "name". The symbols present in the static link table will be made
+** available to PR_FindSymbol. If "name" is null then the symbols will be
+** made available to the library which represents the executable. The
+** tables are not copied.
+**
+** Returns the library object if successful, null otherwise.
+**
+** This increments the reference count of the library.
+*/
+NSPR_API(PRLibrary*) PR_LoadStaticLibrary(
+    const char *name, const PRStaticLinkTable *table);
+
+/*
+** Return the pathname of the file that the library "name" was loaded
+** from. "addr" is the address of a function defined in the library.
+**
+** The caller is responsible for freeing the result with PR_Free.
+*/
+NSPR_API(char *) PR_GetLibraryFilePathname(const char *name, PRFuncPtr addr);
+
+PR_END_EXTERN_C
+
+#endif /* prlink_h___ */
diff --git a/js/src/prlock.h b/js/src/prlock.h
new file mode 100644
--- /dev/null
+++ b/js/src/prlock.h
@@ -0,0 +1,109 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+** File:		prlock.h
+** Description:	API to basic locking functions of NSPR.
+**
+**
+** NSPR provides basic locking mechanisms for thread synchronization.  Locks 
+** are lightweight resource contention controls that prevent multiple threads 
+** from accessing something (code/data) simultaneously.
+**/
+
+#ifndef prlock_h___
+#define prlock_h___
+
+#include "prtypes.h"
+
+PR_BEGIN_EXTERN_C
+
+/**********************************************************************/
+/************************* TYPES AND CONSTANTS ************************/
+/**********************************************************************/
+
+/*
+ * PRLock --
+ *
+ *     NSPR represents the lock as an opaque entity to the client of the
+ *	   API.  All routines operate on a pointer to this opaque entity.
+ */
+
+typedef struct PRLock PRLock;
+
+/**********************************************************************/
+/****************************** FUNCTIONS *****************************/
+/**********************************************************************/
+
+/***********************************************************************
+** FUNCTION:    PR_NewLock
+** DESCRIPTION:
+**  Returns a pointer to a newly created opaque lock object.
+** INPUTS:      void
+** OUTPUTS:     void
+** RETURN:      PRLock*
+**   If the lock can not be created because of resource constraints, NULL
+**   is returned.
+**  
+***********************************************************************/
+NSPR_API(PRLock*) PR_NewLock(void);
+
+/***********************************************************************
+** FUNCTION:    PR_DestroyLock
+** DESCRIPTION:
+**  Destroys a given opaque lock object.
+** INPUTS:      PRLock *lock
+**              Lock to be freed.
+** OUTPUTS:     void
+** RETURN:      None
+***********************************************************************/
+NSPR_API(void) PR_DestroyLock(PRLock *lock);
+
+/***********************************************************************
+** FUNCTION:    PR_Lock
+** DESCRIPTION:
+**  Lock a lock.
+** INPUTS:      PRLock *lock
+**              Lock to locked.
+** OUTPUTS:     void
+** RETURN:      None
+***********************************************************************/
+NSPR_API(void) PR_Lock(PRLock *lock);
+
+/***********************************************************************
+** FUNCTION:    PR_Unlock
+** DESCRIPTION:
+**  Unlock a lock.  Unlocking an unlocked lock has undefined results.
+** INPUTS:      PRLock *lock
+**              Lock to unlocked.
+** OUTPUTS:     void
+** RETURN:      PR_STATUS
+**              Returns PR_FAILURE if the caller does not own the lock.
+***********************************************************************/
+NSPR_API(PRStatus) PR_Unlock(PRLock *lock);
+
+/***********************************************************************
+** MACRO:    PR_ASSERT_CURRENT_THREAD_OWNS_LOCK
+** DESCRIPTION:
+**  If the current thread owns |lock|, this assertion is guaranteed to
+**  succeed.  Otherwise, the behavior of this function is undefined.
+** INPUTS:      PRLock *lock
+**              Lock to assert ownership of.
+** OUTPUTS:     void
+** RETURN:      None
+***********************************************************************/
+#if defined(DEBUG) || defined(FORCE_PR_ASSERT)
+#define PR_ASSERT_CURRENT_THREAD_OWNS_LOCK(/* PrLock* */ lock) \
+    PR_AssertCurrentThreadOwnsLock(lock)
+#else
+#define PR_ASSERT_CURRENT_THREAD_OWNS_LOCK(/* PrLock* */ lock)
+#endif
+
+/* Don't call this function directly. */
+NSPR_API(void) PR_AssertCurrentThreadOwnsLock(PRLock *lock);
+
+PR_END_EXTERN_C
+
+#endif /* prlock_h___ */
diff --git a/js/src/prlong.h b/js/src/prlong.h
new file mode 100644
--- /dev/null
+++ b/js/src/prlong.h
@@ -0,0 +1,403 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+** File:                prlong.h
+** Description: Portable access to 64 bit numerics
+**
+** Long-long (64-bit signed integer type) support. Some C compilers
+** don't support 64 bit integers yet, so we use these macros to
+** support both machines that do and don't.
+**/
+#ifndef prlong_h___
+#define prlong_h___
+
+#include "prtypes.h"
+
+PR_BEGIN_EXTERN_C
+
+/***********************************************************************
+** DEFINES:     LL_MaxInt
+**              LL_MinInt
+**              LL_Zero
+**              LL_MaxUint
+** DESCRIPTION:
+**      Various interesting constants and static variable
+**      initializer
+***********************************************************************/
+NSPR_API(PRInt64) LL_MaxInt(void);
+NSPR_API(PRInt64) LL_MinInt(void);
+NSPR_API(PRInt64) LL_Zero(void);
+NSPR_API(PRUint64) LL_MaxUint(void);
+
+#if defined(HAVE_LONG_LONG)
+
+/* Keep this in sync with prtypes.h. */
+#if PR_BYTES_PER_LONG == 8 && !defined(PR_ALTERNATE_INT64_TYPEDEF)
+#define LL_MAXINT   9223372036854775807L
+#define LL_MININT   (-LL_MAXINT - 1L)
+#define LL_ZERO     0L
+#define LL_MAXUINT  18446744073709551615UL
+#define LL_INIT(hi, lo)  ((hi ## L << 32) + lo ## L)
+#elif defined(WIN32) && !defined(__GNUC__)
+#define LL_MAXINT   9223372036854775807i64
+#define LL_MININT   (-LL_MAXINT - 1i64)
+#define LL_ZERO     0i64
+#define LL_MAXUINT  18446744073709551615ui64
+#define LL_INIT(hi, lo)  ((hi ## i64 << 32) + lo ## i64)
+#else
+#define LL_MAXINT   9223372036854775807LL
+#define LL_MININT   (-LL_MAXINT - 1LL)
+#define LL_ZERO     0LL
+#define LL_MAXUINT  18446744073709551615ULL
+#define LL_INIT(hi, lo)  ((hi ## LL << 32) + lo ## LL)
+#endif
+
+/***********************************************************************
+** MACROS:      LL_*
+** DESCRIPTION:
+**      The following macros define portable access to the 64 bit
+**      math facilities.
+**
+***********************************************************************/
+
+/***********************************************************************
+** MACROS:      LL_<relational operators>
+**
+**  LL_IS_ZERO        Test for zero
+**  LL_EQ             Test for equality
+**  LL_NE             Test for inequality
+**  LL_GE_ZERO        Test for zero or positive
+**  LL_CMP            Compare two values
+***********************************************************************/
+#define LL_IS_ZERO(a)       ((a) == 0)
+#define LL_EQ(a, b)         ((a) == (b))
+#define LL_NE(a, b)         ((a) != (b))
+#define LL_GE_ZERO(a)       ((a) >= 0)
+#define LL_CMP(a, op, b)    ((PRInt64)(a) op (PRInt64)(b))
+#define LL_UCMP(a, op, b)   ((PRUint64)(a) op (PRUint64)(b))
+
+/***********************************************************************
+** MACROS:      LL_<logical operators>
+**
+**  LL_AND            Logical and
+**  LL_OR             Logical or
+**  LL_XOR            Logical exclusion
+**  LL_OR2            A disgusting deviation
+**  LL_NOT            Negation (one's complement)
+***********************************************************************/
+#define LL_AND(r, a, b)        ((r) = (a) & (b))
+#define LL_OR(r, a, b)        ((r) = (a) | (b))
+#define LL_XOR(r, a, b)        ((r) = (a) ^ (b))
+#define LL_OR2(r, a)        ((r) = (r) | (a))
+#define LL_NOT(r, a)        ((r) = ~(a))
+
+/***********************************************************************
+** MACROS:      LL_<mathematical operators>
+**
+**  LL_NEG            Negation (two's complement)
+**  LL_ADD            Summation (two's complement)
+**  LL_SUB            Difference (two's complement)
+***********************************************************************/
+#define LL_NEG(r, a)        ((r) = -(a))
+#define LL_ADD(r, a, b)     ((r) = (a) + (b))
+#define LL_SUB(r, a, b)     ((r) = (a) - (b))
+
+/***********************************************************************
+** MACROS:      LL_<mathematical operators>
+**
+**  LL_MUL            Product (two's complement)
+**  LL_DIV            Quotient (two's complement)
+**  LL_MOD            Modulus (two's complement)
+***********************************************************************/
+#define LL_MUL(r, a, b)        ((r) = (a) * (b))
+#define LL_DIV(r, a, b)        ((r) = (a) / (b))
+#define LL_MOD(r, a, b)        ((r) = (a) % (b))
+
+/***********************************************************************
+** MACROS:      LL_<shifting operators>
+**
+**  LL_SHL            Shift left [0..64] bits
+**  LL_SHR            Shift right [0..64] bits with sign extension
+**  LL_USHR           Unsigned shift right [0..64] bits
+**  LL_ISHL           Signed shift left [0..64] bits
+***********************************************************************/
+#define LL_SHL(r, a, b)     ((r) = (PRInt64)(a) << (b))
+#define LL_SHR(r, a, b)     ((r) = (PRInt64)(a) >> (b))
+#define LL_USHR(r, a, b)    ((r) = (PRUint64)(a) >> (b))
+#define LL_ISHL(r, a, b)    ((r) = (PRInt64)(a) << (b))
+
+/***********************************************************************
+** MACROS:      LL_<conversion operators>
+**
+**  LL_L2I            Convert to signed 32 bit
+**  LL_L2UI           Convert to unsigned 32 bit
+**  LL_L2F            Convert to floating point
+**  LL_L2D            Convert to floating point
+**  LL_I2L            Convert signed to 64 bit
+**  LL_UI2L           Convert unsigned to 64 bit
+**  LL_F2L            Convert float to 64 bit
+**  LL_D2L            Convert float to 64 bit
+***********************************************************************/
+#define LL_L2I(i, l)        ((i) = (PRInt32)(l))
+#define LL_L2UI(ui, l)        ((ui) = (PRUint32)(l))
+#define LL_L2F(f, l)        ((f) = (PRFloat64)(l))
+#define LL_L2D(d, l)        ((d) = (PRFloat64)(l))
+
+#define LL_I2L(l, i)        ((l) = (PRInt64)(i))
+#define LL_UI2L(l, ui)        ((l) = (PRInt64)(ui))
+#define LL_F2L(l, f)        ((l) = (PRInt64)(f))
+#define LL_D2L(l, d)        ((l) = (PRInt64)(d))
+
+/***********************************************************************
+** MACROS:      LL_UDIVMOD
+** DESCRIPTION:
+**  Produce both a quotient and a remainder given an unsigned 
+** INPUTS:      PRUint64 a: The dividend of the operation
+**              PRUint64 b: The quotient of the operation
+** OUTPUTS:     PRUint64 *qp: pointer to quotient
+**              PRUint64 *rp: pointer to remainder
+***********************************************************************/
+#define LL_UDIVMOD(qp, rp, a, b) \
+    (*(qp) = ((PRUint64)(a) / (b)), \
+     *(rp) = ((PRUint64)(a) % (b)))
+
+#else  /* !HAVE_LONG_LONG */
+
+#define LL_MAXINT   LL_MaxInt()
+#define LL_MININT   LL_MinInt()
+#define LL_ZERO     LL_Zero()
+#define LL_MAXUINT  LL_MaxUint()
+
+#ifdef IS_LITTLE_ENDIAN
+#define LL_INIT(hi, lo) {PR_UINT32(lo), PR_UINT32(hi)}
+#else
+#define LL_INIT(hi, lo) {PR_UINT32(hi), PR_UINT32(lo)}
+#endif
+
+#define LL_IS_ZERO(a)        (((a).hi == 0) && ((a).lo == 0))
+#define LL_EQ(a, b)        (((a).hi == (b).hi) && ((a).lo == (b).lo))
+#define LL_NE(a, b)        (((a).hi != (b).hi) || ((a).lo != (b).lo))
+#define LL_GE_ZERO(a)        (((a).hi >> 31) == 0)
+
+#define LL_CMP(a, op, b)    (((a).hi == (b).hi) ? ((a).lo op (b).lo) : \
+                 ((PRInt32)(a).hi op (PRInt32)(b).hi))
+#define LL_UCMP(a, op, b)    (((a).hi == (b).hi) ? ((a).lo op (b).lo) : \
+                 ((a).hi op (b).hi))
+
+#define LL_AND(r, a, b)        ((r).lo = (a).lo & (b).lo, \
+                 (r).hi = (a).hi & (b).hi)
+#define LL_OR(r, a, b)        ((r).lo = (a).lo | (b).lo, \
+                 (r).hi = (a).hi | (b).hi)
+#define LL_XOR(r, a, b)        ((r).lo = (a).lo ^ (b).lo, \
+                 (r).hi = (a).hi ^ (b).hi)
+#define LL_OR2(r, a)        ((r).lo = (r).lo | (a).lo, \
+                 (r).hi = (r).hi | (a).hi)
+#define LL_NOT(r, a)        ((r).lo = ~(a).lo, \
+                 (r).hi = ~(a).hi)
+
+#define LL_NEG(r, a)        ((r).lo = -(PRInt32)(a).lo, \
+                 (r).hi = -(PRInt32)(a).hi - ((r).lo != 0))
+#define LL_ADD(r, a, b) { \
+    PRInt64 _a, _b; \
+    _a = a; _b = b; \
+    (r).lo = _a.lo + _b.lo; \
+    (r).hi = _a.hi + _b.hi + ((r).lo < _b.lo); \
+}
+
+#define LL_SUB(r, a, b) { \
+    PRInt64 _a, _b; \
+    _a = a; _b = b; \
+    (r).lo = _a.lo - _b.lo; \
+    (r).hi = _a.hi - _b.hi - (_a.lo < _b.lo); \
+}
+
+#define LL_MUL(r, a, b) { \
+    PRInt64 _a, _b; \
+    _a = a; _b = b; \
+    LL_MUL32(r, _a.lo, _b.lo); \
+    (r).hi += _a.hi * _b.lo + _a.lo * _b.hi; \
+}
+
+#define _lo16(a)        ((a) & PR_BITMASK(16))
+#define _hi16(a)        ((a) >> 16)
+
+#define LL_MUL32(r, a, b) { \
+     PRUint32 _a1, _a0, _b1, _b0, _y0, _y1, _y2, _y3; \
+     _a1 = _hi16(a), _a0 = _lo16(a); \
+     _b1 = _hi16(b), _b0 = _lo16(b); \
+     _y0 = _a0 * _b0; \
+     _y1 = _a0 * _b1; \
+     _y2 = _a1 * _b0; \
+     _y3 = _a1 * _b1; \
+     _y1 += _hi16(_y0);                         /* can't carry */ \
+     _y1 += _y2;                                /* might carry */ \
+     if (_y1 < _y2)    \
+        _y3 += (PRUint32)(PR_BIT(16));  /* propagate */ \
+     (r).lo = (_lo16(_y1) << 16) + _lo16(_y0); \
+     (r).hi = _y3 + _hi16(_y1); \
+}
+
+#define LL_UDIVMOD(qp, rp, a, b)    ll_udivmod(qp, rp, a, b)
+
+NSPR_API(void) ll_udivmod(PRUint64 *qp, PRUint64 *rp, PRUint64 a, PRUint64 b);
+
+#define LL_DIV(r, a, b) { \
+    PRInt64 _a, _b; \
+    PRUint32 _negative = (PRInt32)(a).hi < 0; \
+    if (_negative) { \
+    LL_NEG(_a, a); \
+    } else { \
+    _a = a; \
+    } \
+    if ((PRInt32)(b).hi < 0) { \
+    _negative ^= 1; \
+    LL_NEG(_b, b); \
+    } else { \
+    _b = b; \
+    } \
+    LL_UDIVMOD(&(r), 0, _a, _b); \
+    if (_negative) \
+    LL_NEG(r, r); \
+}
+
+#define LL_MOD(r, a, b) { \
+    PRInt64 _a, _b; \
+    PRUint32 _negative = (PRInt32)(a).hi < 0; \
+    if (_negative) { \
+    LL_NEG(_a, a); \
+    } else { \
+    _a = a; \
+    } \
+    if ((PRInt32)(b).hi < 0) { \
+    LL_NEG(_b, b); \
+    } else { \
+    _b = b; \
+    } \
+    LL_UDIVMOD(0, &(r), _a, _b); \
+    if (_negative) \
+    LL_NEG(r, r); \
+}
+
+#define LL_SHL(r, a, b) { \
+    if (b) { \
+    PRInt64 _a; \
+        _a = a; \
+        if ((b) < 32) { \
+        (r).lo = _a.lo << ((b) & 31); \
+        (r).hi = (_a.hi << ((b) & 31)) | (_a.lo >> (32 - (b))); \
+    } else { \
+        (r).lo = 0; \
+        (r).hi = _a.lo << ((b) & 31); \
+    } \
+    } else { \
+    (r) = (a); \
+    } \
+}
+
+/* a is an PRInt32, b is PRInt32, r is PRInt64 */
+#define LL_ISHL(r, a, b) { \
+    if (b) { \
+    PRInt64 _a; \
+    _a.lo = (a); \
+    _a.hi = 0; \
+        if ((b) < 32) { \
+        (r).lo = (a) << ((b) & 31); \
+        (r).hi = ((a) >> (32 - (b))); \
+    } else { \
+        (r).lo = 0; \
+        (r).hi = (a) << ((b) & 31); \
+    } \
+    } else { \
+    (r).lo = (a); \
+    (r).hi = 0; \
+    } \
+}
+
+#define LL_SHR(r, a, b) { \
+    if (b) { \
+    PRInt64 _a; \
+        _a = a; \
+    if ((b) < 32) { \
+        (r).lo = (_a.hi << (32 - (b))) | (_a.lo >> ((b) & 31)); \
+        (r).hi = (PRInt32)_a.hi >> ((b) & 31); \
+    } else { \
+        (r).lo = (PRInt32)_a.hi >> ((b) & 31); \
+        (r).hi = (PRInt32)_a.hi >> 31; \
+    } \
+    } else { \
+    (r) = (a); \
+    } \
+}
+
+#define LL_USHR(r, a, b) { \
+    if (b) { \
+    PRInt64 _a; \
+        _a = a; \
+    if ((b) < 32) { \
+        (r).lo = (_a.hi << (32 - (b))) | (_a.lo >> ((b) & 31)); \
+        (r).hi = _a.hi >> ((b) & 31); \
+    } else { \
+        (r).lo = _a.hi >> ((b) & 31); \
+        (r).hi = 0; \
+    } \
+    } else { \
+    (r) = (a); \
+    } \
+}
+
+#define LL_L2I(i, l)        ((i) = (l).lo)
+#define LL_L2UI(ui, l)        ((ui) = (l).lo)
+#define LL_L2F(f, l)        { double _d; LL_L2D(_d, l); (f) = (PRFloat64)_d; }
+
+#define LL_L2D(d, l) { \
+    int _negative; \
+    PRInt64 _absval; \
+ \
+    _negative = (l).hi >> 31; \
+    if (_negative) { \
+    LL_NEG(_absval, l); \
+    } else { \
+    _absval = l; \
+    } \
+    (d) = (double)_absval.hi * 4.294967296e9 + _absval.lo; \
+    if (_negative) \
+    (d) = -(d); \
+}
+
+#define LL_I2L(l, i)        { PRInt32 _i = ((PRInt32)(i)) >> 31; (l).lo = (i); (l).hi = _i; }
+#define LL_UI2L(l, ui)      ((l).lo = (ui), (l).hi = 0)
+#define LL_F2L(l, f)        { double _d = (double)f; LL_D2L(l, _d); }
+
+#define LL_D2L(l, d) { \
+    int _negative; \
+    double _absval, _d_hi; \
+    PRInt64 _lo_d; \
+ \
+    _negative = ((d) < 0); \
+    _absval = _negative ? -(d) : (d); \
+ \
+    (l).hi = _absval / 4.294967296e9; \
+    (l).lo = 0; \
+    LL_L2D(_d_hi, l); \
+    _absval -= _d_hi; \
+    _lo_d.hi = 0; \
+    if (_absval < 0) { \
+    _lo_d.lo = -_absval; \
+    LL_SUB(l, l, _lo_d); \
+    } else { \
+    _lo_d.lo = _absval; \
+    LL_ADD(l, l, _lo_d); \
+    } \
+ \
+    if (_negative) \
+    LL_NEG(l, l); \
+}
+
+#endif /* !HAVE_LONG_LONG */
+
+PR_END_EXTERN_C
+
+#endif /* prlong_h___ */
diff --git a/js/src/prprf.h b/js/src/prprf.h
new file mode 100644
--- /dev/null
+++ b/js/src/prprf.h
@@ -0,0 +1,122 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef prprf_h___
+#define prprf_h___
+
+/*
+** API for PR printf like routines. Supports the following formats
+**	%d - decimal
+**	%u - unsigned decimal
+**	%x - unsigned hex
+**	%X - unsigned uppercase hex
+**	%o - unsigned octal
+**	%hd, %hu, %hx, %hX, %ho - 16-bit versions of above
+**	%ld, %lu, %lx, %lX, %lo - 32-bit versions of above
+**	%lld, %llu, %llx, %llX, %llo - 64 bit versions of above
+**	%s - string
+**	%c - character
+**	%p - pointer (deals with machine dependent pointer size)
+**	%f - float
+**	%g - float
+*/
+#include "prtypes.h"
+#include "prio.h"
+#include <stdio.h>
+#include <stdarg.h>
+
+PR_BEGIN_EXTERN_C
+
+/*
+** sprintf into a fixed size buffer. Guarantees that a NUL is at the end
+** of the buffer. Returns the length of the written output, NOT including
+** the NUL, or (PRUint32)-1 if an error occurs.
+*/
+NSPR_API(PRUint32) PR_snprintf(char *out, PRUint32 outlen, const char *fmt, ...);
+
+/*
+** sprintf into a PR_MALLOC'd buffer. Return a pointer to the malloc'd
+** buffer on success, NULL on failure. Call "PR_smprintf_free" to release
+** the memory returned.
+*/
+NSPR_API(char*) PR_smprintf(const char *fmt, ...);
+
+/*
+** Free the memory allocated, for the caller, by PR_smprintf
+*/
+NSPR_API(void) PR_smprintf_free(char *mem);
+
+/*
+** "append" sprintf into a PR_MALLOC'd buffer. "last" is the last value of
+** the PR_MALLOC'd buffer. sprintf will append data to the end of last,
+** growing it as necessary using realloc. If last is NULL, PR_sprintf_append
+** will allocate the initial string. The return value is the new value of
+** last for subsequent calls, or NULL if there is a malloc failure.
+*/
+NSPR_API(char*) PR_sprintf_append(char *last, const char *fmt, ...);
+
+/*
+** sprintf into a function. The function "f" is called with a string to
+** place into the output. "arg" is an opaque pointer used by the stuff
+** function to hold any state needed to do the storage of the output
+** data. The return value is a count of the number of characters fed to
+** the stuff function, or (PRUint32)-1 if an error occurs.
+*/
+typedef PRIntn (*PRStuffFunc)(void *arg, const char *s, PRUint32 slen);
+
+NSPR_API(PRUint32) PR_sxprintf(PRStuffFunc f, void *arg, const char *fmt, ...);
+
+/*
+** fprintf to a PRFileDesc
+*/
+NSPR_API(PRUint32) PR_fprintf(struct PRFileDesc* fd, const char *fmt, ...);
+
+/*
+** va_list forms of the above.
+*/
+NSPR_API(PRUint32) PR_vsnprintf(char *out, PRUint32 outlen, const char *fmt, va_list ap);
+NSPR_API(char*) PR_vsmprintf(const char *fmt, va_list ap);
+NSPR_API(char*) PR_vsprintf_append(char *last, const char *fmt, va_list ap);
+NSPR_API(PRUint32) PR_vsxprintf(PRStuffFunc f, void *arg, const char *fmt, va_list ap);
+NSPR_API(PRUint32) PR_vfprintf(struct PRFileDesc* fd, const char *fmt, va_list ap);
+
+/*
+***************************************************************************
+** FUNCTION: PR_sscanf
+** DESCRIPTION:
+**     PR_sscanf() scans the input character string, performs data
+**     conversions, and stores the converted values in the data objects
+**     pointed to by its arguments according to the format control
+**     string.
+**
+**     PR_sscanf() behaves the same way as the sscanf() function in the
+**     Standard C Library (stdio.h), with the following exceptions:
+**     - PR_sscanf() handles the NSPR integer and floating point types,
+**       such as PRInt16, PRInt32, PRInt64, and PRFloat64, whereas
+**       sscanf() handles the standard C types like short, int, long,
+**       and double.
+**     - PR_sscanf() has no multibyte character support, while sscanf()
+**       does.
+** INPUTS:
+**     const char *buf
+**         a character string holding the input to scan
+**     const char *fmt
+**         the format control string for the conversions
+**     ...
+**         variable number of arguments, each of them is a pointer to
+**         a data object in which the converted value will be stored
+** OUTPUTS: none
+** RETURNS: PRInt32
+**     The number of values converted and stored.
+** RESTRICTIONS:
+**    Multibyte characters in 'buf' or 'fmt' are not allowed.
+***************************************************************************
+*/
+
+NSPR_API(PRInt32) PR_sscanf(const char *buf, const char *fmt, ...);
+
+PR_END_EXTERN_C
+
+#endif /* prprf_h___ */
diff --git a/js/src/prthread.h b/js/src/prthread.h
new file mode 100644
--- /dev/null
+++ b/js/src/prthread.h
@@ -0,0 +1,272 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef prthread_h___
+#define prthread_h___
+
+/*
+** API for NSPR threads. On some architectures (Mac OS Classic
+** notably) pre-emptibility is not guaranteed. Hard priority scheduling
+** is not guaranteed, so programming using priority based synchronization
+** is a no-no.
+**
+** NSPR threads are scheduled based loosely on their client set priority.
+** In general, a thread of a higher priority has a statistically better
+** chance of running relative to threads of lower priority. However,
+** NSPR uses multiple strategies to provide execution vehicles for thread
+** abstraction of various host platforms. As it turns out, there is little
+** NSPR can do to affect the scheduling attributes of "GLOBAL" threads.
+** However, a semblance of GLOBAL threads is used to implement "LOCAL"
+** threads. An arbitrary number of such LOCAL threads can be assigned to
+** a single GLOBAL thread.
+**
+** For scheduling, NSPR will attempt to run the highest priority LOCAL
+** thread associated with a given GLOBAL thread. It is further assumed
+** that the host OS will apply some form of "fair" scheduling on the
+** GLOBAL threads.
+**
+** Threads have a "system flag" which when set indicates the thread
+** doesn't count for determining when the process should exit (the
+** process exits when the last user thread exits).
+**
+** Threads also have a "scope flag" which controls whether the threads
+** are scheduled in the local scope or scheduled by the OS globally. This 
+** indicates whether a thread is permanently bound to a native OS thread. 
+** An unbound thread competes for scheduling resources in the same process.
+**
+** Another flag is "state flag" which control whether the thread is joinable.
+** It allows other threads to wait for the created thread to reach completion.
+**
+** Threads can have "per-thread-data" attached to them. Each thread has a
+** per-thread error number and error string which are updated when NSPR
+** operations fail.
+*/
+#include "prtypes.h"
+#include "prinrval.h"
+
+PR_BEGIN_EXTERN_C
+
+typedef struct PRThread PRThread;
+typedef struct PRThreadStack PRThreadStack;
+
+typedef enum PRThreadType {
+    PR_USER_THREAD,
+    PR_SYSTEM_THREAD
+} PRThreadType;
+
+typedef enum PRThreadScope {
+    PR_LOCAL_THREAD,
+    PR_GLOBAL_THREAD,
+    PR_GLOBAL_BOUND_THREAD
+} PRThreadScope;
+
+typedef enum PRThreadState {
+    PR_JOINABLE_THREAD,
+    PR_UNJOINABLE_THREAD
+} PRThreadState;
+
+typedef enum PRThreadPriority
+{
+    PR_PRIORITY_FIRST = 0,      /* just a placeholder */
+    PR_PRIORITY_LOW = 0,        /* the lowest possible priority */
+    PR_PRIORITY_NORMAL = 1,     /* most common expected priority */
+    PR_PRIORITY_HIGH = 2,       /* slightly more aggressive scheduling */
+    PR_PRIORITY_URGENT = 3,     /* it does little good to have more than one */
+    PR_PRIORITY_LAST = 3        /* this is just a placeholder */
+} PRThreadPriority;
+
+/*
+** Create a new thread:
+**     "type" is the type of thread to create
+**     "start(arg)" will be invoked as the threads "main"
+**     "priority" will be created thread's priority
+**     "scope" will specify whether the thread is local or global
+**     "state" will specify whether the thread is joinable or not
+**     "stackSize" the size of the stack, in bytes. The value can be zero
+**        and then a machine specific stack size will be chosen.
+**
+** This can return NULL if some kind of error occurs, such as if memory is
+** tight.
+**
+** If you want the thread to start up waiting for the creator to do
+** something, enter a lock before creating the thread and then have the
+** threads start routine enter and exit the same lock. When you are ready
+** for the thread to run, exit the lock.
+**
+** If you want to detect the completion of the created thread, the thread
+** should be created joinable.  Then, use PR_JoinThread to synchrnoize the
+** termination of another thread.
+**
+** When the start function returns the thread exits. If it is the last
+** PR_USER_THREAD to exit then the process exits.
+*/
+NSPR_API(PRThread*) PR_CreateThread(PRThreadType type,
+                     void (PR_CALLBACK *start)(void *arg),
+                     void *arg,
+                     PRThreadPriority priority,
+                     PRThreadScope scope,
+                     PRThreadState state,
+                     PRUint32 stackSize);
+
+/*
+** Wait for thread termination:
+**     "thread" is the target thread 
+**
+** This can return PR_FAILURE if no joinable thread could be found 
+** corresponding to the specified target thread.
+**
+** The calling thread is blocked until the target thread completes.
+** Several threads cannot wait for the same thread to complete; one thread
+** will operate successfully and others will terminate with an error PR_FAILURE.
+** The calling thread will not be blocked if the target thread has already
+** terminated.
+*/
+NSPR_API(PRStatus) PR_JoinThread(PRThread *thread);
+
+/*
+** Return the current thread object for the currently running code.
+** Never returns NULL.
+*/
+NSPR_API(PRThread*) PR_GetCurrentThread(void);
+#ifndef NO_NSPR_10_SUPPORT
+#define PR_CurrentThread() PR_GetCurrentThread() /* for nspr1.0 compat. */
+#endif /* NO_NSPR_10_SUPPORT */
+
+/*
+** Get the priority of "thread".
+*/
+NSPR_API(PRThreadPriority) PR_GetThreadPriority(const PRThread *thread);
+
+/*
+** Change the priority of the "thread" to "priority".
+**
+** PR_SetThreadPriority works in a best-effort manner. On some platforms a
+** special privilege, such as root access, is required to change thread
+** priorities, especially to raise thread priorities. If the caller doesn't
+** have enough privileges to change thread priorites, the function has no
+** effect except causing a future PR_GetThreadPriority call to return
+** |priority|.
+*/
+NSPR_API(void) PR_SetThreadPriority(PRThread *thread, PRThreadPriority priority);
+
+/*
+** Set the name of the current thread, which will be visible in a debugger
+** and accessible via a call to PR_GetThreadName().
+*/
+NSPR_API(PRStatus) PR_SetCurrentThreadName(const char *name);
+
+/*
+** Return the name of "thread", if set.  Otherwise return NULL.
+*/
+NSPR_API(const char *) PR_GetThreadName(const PRThread *thread);
+
+/*
+** This routine returns a new index for per-thread-private data table. 
+** The index is visible to all threads within a process. This index can 
+** be used with the PR_SetThreadPrivate() and PR_GetThreadPrivate() routines 
+** to save and retrieve data associated with the index for a thread.
+**
+** Each index is associationed with a destructor function ('dtor'). The function
+** may be specified as NULL when the index is created. If it is not NULL, the
+** function will be called when:
+**      - the thread exits and the private data for the associated index
+**        is not NULL,
+**      - new thread private data is set and the current private data is
+**        not NULL.
+**
+** The index independently maintains specific values for each binding thread. 
+** A thread can only get access to its own thread-specific-data.
+**
+** Upon a new index return the value associated with the index for all threads
+** is NULL, and upon thread creation the value associated with all indices for 
+** that thread is NULL. 
+**
+** Returns PR_FAILURE if the total number of indices will exceed the maximun 
+** allowed.
+*/
+typedef void (PR_CALLBACK *PRThreadPrivateDTOR)(void *priv);
+
+NSPR_API(PRStatus) PR_NewThreadPrivateIndex(
+    PRUintn *newIndex, PRThreadPrivateDTOR destructor);
+
+/*
+** Define some per-thread-private data.
+**     "tpdIndex" is an index into the per-thread private data table
+**     "priv" is the per-thread-private data 
+**
+** If the per-thread private data table has a previously registered
+** destructor function and a non-NULL per-thread-private data value,
+** the destructor function is invoked.
+**
+** This can return PR_FAILURE if the index is invalid.
+*/
+NSPR_API(PRStatus) PR_SetThreadPrivate(PRUintn tpdIndex, void *priv);
+
+/*
+** Recover the per-thread-private data for the current thread. "tpdIndex" is
+** the index into the per-thread private data table. 
+**
+** The returned value may be NULL which is indistinguishable from an error 
+** condition.
+**
+** A thread can only get access to its own thread-specific-data.
+*/
+NSPR_API(void*) PR_GetThreadPrivate(PRUintn tpdIndex);
+
+/*
+** This routine sets the interrupt request for a target thread. The interrupt
+** request remains in the thread's state until it is delivered exactly once
+** or explicitly canceled.
+**
+** A thread that has been interrupted will fail all NSPR blocking operations
+** that return a PRStatus (I/O, waiting on a condition, etc).
+**
+** PR_Interrupt may itself fail if the target thread is invalid.
+*/
+NSPR_API(PRStatus) PR_Interrupt(PRThread *thread);
+
+/*
+** Clear the interrupt request for the calling thread. If no such request
+** is pending, this operation is a noop.
+*/
+NSPR_API(void) PR_ClearInterrupt(void);
+
+/*
+** Block the interrupt for the calling thread.
+*/
+NSPR_API(void) PR_BlockInterrupt(void);
+
+/*
+** Unblock the interrupt for the calling thread.
+*/
+NSPR_API(void) PR_UnblockInterrupt(void);
+
+/*
+** Make the current thread sleep until "ticks" time amount of time
+** has expired. If "ticks" is PR_INTERVAL_NO_WAIT then the call is
+** equivalent to calling PR_Yield. Calling PR_Sleep with an argument
+** equivalent to PR_INTERVAL_NO_TIMEOUT is an error and will result
+** in a PR_FAILURE error return.
+*/
+NSPR_API(PRStatus) PR_Sleep(PRIntervalTime ticks);
+
+/*
+** Get the scoping of this thread.
+*/
+NSPR_API(PRThreadScope) PR_GetThreadScope(const PRThread *thread);
+
+/*
+** Get the type of this thread.
+*/
+NSPR_API(PRThreadType) PR_GetThreadType(const PRThread *thread);
+
+/*
+** Get the join state of this thread.
+*/
+NSPR_API(PRThreadState) PR_GetThreadState(const PRThread *thread);
+
+PR_END_EXTERN_C
+
+#endif /* prthread_h___ */
diff --git a/js/src/prtime.h b/js/src/prtime.h
new file mode 100644
--- /dev/null
+++ b/js/src/prtime.h
@@ -0,0 +1,262 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * prtime.h --
+ *
+ *     NSPR date and time functions
+ *
+ *-----------------------------------------------------------------------
+ */
+
+#ifndef prtime_h___
+#define prtime_h___
+
+#include "prlong.h"
+
+PR_BEGIN_EXTERN_C
+
+/**********************************************************************/
+/************************* TYPES AND CONSTANTS ************************/
+/**********************************************************************/
+
+#define PR_MSEC_PER_SEC		1000L
+#define PR_USEC_PER_SEC		1000000L
+#define PR_NSEC_PER_SEC		1000000000L
+#define PR_USEC_PER_MSEC	1000L
+#define PR_NSEC_PER_MSEC	1000000L
+
+/*
+ * PRTime --
+ *
+ *     NSPR represents basic time as 64-bit signed integers relative
+ *     to midnight (00:00:00), January 1, 1970 Greenwich Mean Time (GMT).
+ *     (GMT is also known as Coordinated Universal Time, UTC.)
+ *     The units of time are in microseconds. Negative times are allowed
+ *     to represent times prior to the January 1970 epoch. Such values are
+ *     intended to be exported to other systems or converted to human
+ *     readable form.
+ *
+ *     Notes on porting: PRTime corresponds to time_t in ANSI C.  NSPR 1.0
+ *     simply uses PRInt64.
+ */
+
+typedef PRInt64 PRTime;
+
+/*
+ * Time zone and daylight saving time corrections applied to GMT to
+ * obtain the local time of some geographic location
+ */
+
+typedef struct PRTimeParameters {
+    PRInt32 tp_gmt_offset;     /* the offset from GMT in seconds */
+    PRInt32 tp_dst_offset;     /* contribution of DST in seconds */
+} PRTimeParameters;
+
+/*
+ * PRExplodedTime --
+ *
+ *     Time broken down into human-readable components such as year, month,
+ *     day, hour, minute, second, and microsecond.  Time zone and daylight
+ *     saving time corrections may be applied.  If they are applied, the
+ *     offsets from the GMT must be saved in the 'tm_params' field so that
+ *     all the information is available to reconstruct GMT.
+ *
+ *     Notes on porting: PRExplodedTime corrresponds to struct tm in
+ *     ANSI C, with the following differences:
+ *       - an additional field tm_usec;
+ *       - replacing tm_isdst by tm_params;
+ *       - the month field is spelled tm_month, not tm_mon;
+ *       - we use absolute year, AD, not the year since 1900.
+ *     The corresponding type in NSPR 1.0 is called PRTime.  Below is
+ *     a table of date/time type correspondence in the three APIs:
+ *         API          time since epoch          time in components
+ *       ANSI C             time_t                  struct tm
+ *       NSPR 1.0           PRInt64                   PRTime
+ *       NSPR 2.0           PRTime                  PRExplodedTime
+ */
+
+typedef struct PRExplodedTime {
+    PRInt32 tm_usec;		    /* microseconds past tm_sec (0-99999)  */
+    PRInt32 tm_sec;             /* seconds past tm_min (0-61, accomodating
+                                   up to two leap seconds) */
+    PRInt32 tm_min;             /* minutes past tm_hour (0-59) */
+    PRInt32 tm_hour;            /* hours past tm_day (0-23) */
+    PRInt32 tm_mday;            /* days past tm_mon (1-31, note that it
+				                starts from 1) */
+    PRInt32 tm_month;           /* months past tm_year (0-11, Jan = 0) */
+    PRInt16 tm_year;            /* absolute year, AD (note that we do not
+				                count from 1900) */
+
+    PRInt8 tm_wday;		        /* calculated day of the week
+				                (0-6, Sun = 0) */
+    PRInt16 tm_yday;            /* calculated day of the year
+				                (0-365, Jan 1 = 0) */
+
+    PRTimeParameters tm_params;  /* time parameters used by conversion */
+} PRExplodedTime;
+
+/*
+ * PRTimeParamFn --
+ *
+ *     A function of PRTimeParamFn type returns the time zone and
+ *     daylight saving time corrections for some geographic location,
+ *     given the current time in GMT.  The input argument gmt should
+ *     point to a PRExplodedTime that is in GMT, i.e., whose
+ *     tm_params contains all 0's.
+ *
+ *     For any time zone other than GMT, the computation is intended to
+ *     consist of two steps:
+ *       - Figure out the time zone correction, tp_gmt_offset.  This number
+ *         usually depends on the geographic location only.  But it may
+ *         also depend on the current time.  For example, all of China
+ *         is one time zone right now.  But this situation may change
+ *         in the future.
+ *       - Figure out the daylight saving time correction, tp_dst_offset.
+ *         This number depends on both the geographic location and the
+ *         current time.  Most of the DST rules are expressed in local
+ *         current time.  If so, one should apply the time zone correction
+ *         to GMT before applying the DST rules.
+ */
+
+typedef PRTimeParameters (PR_CALLBACK *PRTimeParamFn)(const PRExplodedTime *gmt);
+
+/**********************************************************************/
+/****************************** FUNCTIONS *****************************/
+/**********************************************************************/
+
+/*
+ * The PR_Now routine returns the current time relative to the
+ * epoch, midnight, January 1, 1970 UTC. The units of the returned
+ * value are microseconds since the epoch.
+ *
+ * The values returned are not guaranteed to advance in a linear fashion
+ * due to the application of time correction protocols which synchronize
+ * computer clocks to some external time source. Consequently it should
+ * not be depended on for interval timing.
+ *
+ * The implementation is machine dependent.
+ * Cf. time_t time(time_t *tp) in ANSI C.
+ */
+NSPR_API(PRTime)
+PR_Now(void);
+
+/*
+ * Expand time binding it to time parameters provided by PRTimeParamFn.
+ * The calculation is envisoned to proceed in the following steps:
+ *   - From given PRTime, calculate PRExplodedTime in GMT
+ *   - Apply the given PRTimeParamFn to the GMT that we just calculated
+ *     to obtain PRTimeParameters.
+ *   - Add the PRTimeParameters offsets to GMT to get the local time
+ *     as PRExplodedTime.
+ */
+
+NSPR_API(void) PR_ExplodeTime(
+    PRTime usecs, PRTimeParamFn params, PRExplodedTime *exploded);
+
+/* Reverse operation of PR_ExplodeTime */
+NSPR_API(PRTime)
+PR_ImplodeTime(const PRExplodedTime *exploded);
+
+/*
+ * Adjust exploded time to normalize field overflows after manipulation.
+ * Note that the following fields of PRExplodedTime should not be
+ * manipulated:
+ *   - tm_month and tm_year: because the number of days in a month and
+ *     number of days in a year are not constant, it is ambiguous to
+ *     manipulate the month and year fields, although one may be tempted
+ *     to.  For example, what does "a month from January 31st" mean?
+ *   - tm_wday and tm_yday: these fields are calculated by NSPR.  Users
+ *     should treat them as "read-only".
+ */
+
+NSPR_API(void) PR_NormalizeTime(
+    PRExplodedTime *exploded, PRTimeParamFn params);
+
+/**********************************************************************/
+/*********************** TIME PARAMETER FUNCTIONS *********************/
+/**********************************************************************/
+
+/* Time parameters that suit current host machine */
+NSPR_API(PRTimeParameters) PR_LocalTimeParameters(const PRExplodedTime *gmt);
+
+/* Time parameters that represent Greenwich Mean Time */
+NSPR_API(PRTimeParameters) PR_GMTParameters(const PRExplodedTime *gmt);
+
+/*
+ * Time parameters that represent the US Pacific Time Zone, with the
+ * current daylight saving time rules (for testing only)
+ */
+NSPR_API(PRTimeParameters) PR_USPacificTimeParameters(const PRExplodedTime *gmt);
+
+/*
+ * This parses a time/date string into a PRExplodedTime
+ * struct. It populates all fields but it can't split
+ * the offset from UTC into tp_gmt_offset and tp_dst_offset in
+ * most cases (exceptions: PST/PDT, MST/MDT, CST/CDT, EST/EDT, GMT/BST).
+ * In those cases tp_gmt_offset will be the sum of these two and
+ * tp_dst_offset will be 0.
+ * It returns PR_SUCCESS on success, and PR_FAILURE
+ * if the time/date string can't be parsed.
+ *
+ * Many formats are handled, including:
+ *
+ *   14 Apr 89 03:20:12
+ *   14 Apr 89 03:20 GMT
+ *   Fri, 17 Mar 89 4:01:33
+ *   Fri, 17 Mar 89 4:01 GMT
+ *   Mon Jan 16 16:12 PDT 1989
+ *   Mon Jan 16 16:12 +0130 1989
+ *   6 May 1992 16:41-JST (Wednesday)
+ *   22-AUG-1993 10:59:12.82
+ *   22-AUG-1993 10:59pm
+ *   22-AUG-1993 12:59am
+ *   22-AUG-1993 12:59 PM
+ *   Friday, August 04, 1995 3:54 PM
+ *   06/21/95 04:24:34 PM
+ *   20/06/95 21:07
+ *   95-06-08 19:32:48 EDT
+ *
+ * If the input string doesn't contain a description of the timezone,
+ * we consult the `default_to_gmt' to decide whether the string should
+ * be interpreted relative to the local time zone (PR_FALSE) or GMT (PR_TRUE).
+ * The correct value for this argument depends on what standard specified
+ * the time string which you are parsing.
+ */
+
+NSPR_API(PRStatus) PR_ParseTimeStringToExplodedTime (
+        const char *string,
+        PRBool default_to_gmt,
+        PRExplodedTime *result);
+
+/*
+ * This uses PR_ParseTimeStringToExplodedTime to parse
+ * a time/date string and PR_ImplodeTime to transform it into
+ * a PRTime (microseconds after "1-Jan-1970 00:00:00 GMT").
+ * It returns PR_SUCCESS on success, and PR_FAILURE
+ * if the time/date string can't be parsed.
+ */
+
+NSPR_API(PRStatus) PR_ParseTimeString (
+	const char *string,
+	PRBool default_to_gmt,
+	PRTime *result);
+
+/* Format a time value into a buffer. Same semantics as strftime() */
+NSPR_API(PRUint32) PR_FormatTime(char *buf, int buflen, const char *fmt,
+                                           const PRExplodedTime *tm);
+
+/* Format a time value into a buffer. Time is always in US English format, regardless
+ * of locale setting.
+ */
+NSPR_API(PRUint32)
+PR_FormatTimeUSEnglish( char* buf, PRUint32 bufSize,
+                        const char* format, const PRExplodedTime* tm );
+
+PR_END_EXTERN_C
+
+#endif /* prtime_h___ */
diff --git a/js/src/prtypes.h b/js/src/prtypes.h
new file mode 100644
--- /dev/null
+++ b/js/src/prtypes.h
@@ -0,0 +1,565 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+** File:                prtypes.h
+** Description: Definitions of NSPR's basic types
+**
+** Prototypes and macros used to make up for deficiencies that we have found
+** in ANSI environments.
+**
+** Since we do not wrap <stdlib.h> and all the other standard headers, authors
+** of portable code will not know in general that they need these definitions.
+** Instead of requiring these authors to find the dependent uses in their code
+** and take the following steps only in those C files, we take steps once here
+** for all C files.
+**/
+
+#ifndef prtypes_h___
+#define prtypes_h___
+
+#ifdef MDCPUCFG
+#include MDCPUCFG
+#else
+#include "prcpucfg.h"
+#endif
+
+#include <stddef.h>
+
+/***********************************************************************
+** MACROS:      PR_EXTERN
+**              PR_IMPLEMENT
+** DESCRIPTION:
+**      These are only for externally visible routines and globals.  For
+**      internal routines, just use "extern" for type checking and that
+**      will not export internal cross-file or forward-declared symbols.
+**      Define a macro for declaring procedures return types. We use this to
+**      deal with windoze specific type hackery for DLL definitions. Use
+**      PR_EXTERN when the prototype for the method is declared. Use
+**      PR_IMPLEMENT for the implementation of the method.
+**
+** Example:
+**   in dowhim.h
+**     PR_EXTERN( void ) DoWhatIMean( void );
+**   in dowhim.c
+**     PR_IMPLEMENT( void ) DoWhatIMean( void ) { return; }
+**
+**
+***********************************************************************/
+#if defined(WIN32)
+
+#define PR_EXPORT(__type) extern __declspec(dllexport) __type
+#define PR_EXPORT_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPORT(__type) __declspec(dllimport) __type
+#define PR_IMPORT_DATA(__type) __declspec(dllimport) __type
+
+#define PR_EXTERN(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT(__type) __declspec(dllexport) __type
+#define PR_EXTERN_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT_DATA(__type) __declspec(dllexport) __type
+
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#elif defined(XP_BEOS)
+
+#define PR_EXPORT(__type) extern __declspec(dllexport) __type
+#define PR_EXPORT_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPORT(__type) extern __declspec(dllexport) __type
+#define PR_IMPORT_DATA(__type) extern __declspec(dllexport) __type
+
+#define PR_EXTERN(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT(__type) __declspec(dllexport) __type
+#define PR_EXTERN_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT_DATA(__type) __declspec(dllexport) __type
+
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#elif defined(XP_OS2) && defined(__declspec)
+
+#define PR_EXPORT(__type) extern __declspec(dllexport) __type
+#define PR_EXPORT_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPORT(__type) extern  __declspec(dllimport) __type
+#define PR_IMPORT_DATA(__type) extern __declspec(dllimport) __type
+
+#define PR_EXTERN(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT(__type) __declspec(dllexport) __type
+#define PR_EXTERN_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT_DATA(__type) __declspec(dllexport) __type
+
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#elif defined(SYMBIAN)
+
+#define PR_EXPORT(__type) extern __declspec(dllexport) __type
+#define PR_EXPORT_DATA(__type) extern __declspec(dllexport) __type
+#ifdef __WINS__
+#define PR_IMPORT(__type) extern __declspec(dllexport) __type
+#define PR_IMPORT_DATA(__type) extern __declspec(dllexport) __type
+#else
+#define PR_IMPORT(__type) extern __declspec(dllimport) __type
+#define PR_IMPORT_DATA(__type) extern __declspec(dllimport) __type
+#endif
+
+#define PR_EXTERN(__type) extern __type
+#define PR_IMPLEMENT(__type) __type
+#define PR_EXTERN_DATA(__type) extern __type
+#define PR_IMPLEMENT_DATA(__type) __type
+
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#else /* Unix */
+
+/* GCC 3.3 and later support the visibility attribute. */
+#if (__GNUC__ >= 4) || \
+    (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
+#define PR_VISIBILITY_DEFAULT __attribute__((visibility("default")))
+#else
+#define PR_VISIBILITY_DEFAULT
+#endif
+
+#define PR_EXPORT(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_EXPORT_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPORT(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPORT_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+
+#define PR_EXTERN(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPLEMENT(__type) PR_VISIBILITY_DEFAULT __type
+#define PR_EXTERN_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPLEMENT_DATA(__type) PR_VISIBILITY_DEFAULT __type
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#endif
+
+#if defined(_NSPR_BUILD_)
+#define NSPR_API(__type) PR_EXPORT(__type)
+#define NSPR_DATA_API(__type) PR_EXPORT_DATA(__type)
+#else
+#define NSPR_API(__type) PR_IMPORT(__type)
+#define NSPR_DATA_API(__type) PR_IMPORT_DATA(__type)
+#endif
+
+/***********************************************************************
+** MACROS:      PR_BEGIN_MACRO
+**              PR_END_MACRO
+** DESCRIPTION:
+**      Macro body brackets so that macros with compound statement definitions
+**      behave syntactically more like functions when called.
+***********************************************************************/
+#define PR_BEGIN_MACRO  do {
+#define PR_END_MACRO    } while (0)
+
+/***********************************************************************
+** MACROS:      PR_BEGIN_EXTERN_C
+**              PR_END_EXTERN_C
+** DESCRIPTION:
+**      Macro shorthands for conditional C++ extern block delimiters.
+***********************************************************************/
+#ifdef __cplusplus
+#define PR_BEGIN_EXTERN_C       extern "C" {
+#define PR_END_EXTERN_C         }
+#else
+#define PR_BEGIN_EXTERN_C
+#define PR_END_EXTERN_C
+#endif
+
+/***********************************************************************
+** MACROS:      PR_BIT
+**              PR_BITMASK
+** DESCRIPTION:
+** Bit masking macros.  XXX n must be <= 31 to be portable
+***********************************************************************/
+#define PR_BIT(n)       ((PRUint32)1 << (n))
+#define PR_BITMASK(n)   (PR_BIT(n) - 1)
+
+/***********************************************************************
+** MACROS:      PR_ROUNDUP
+**              PR_MIN
+**              PR_MAX
+**              PR_ABS
+** DESCRIPTION:
+**      Commonly used macros for operations on compatible types.
+***********************************************************************/
+#define PR_ROUNDUP(x,y) ((((x)+((y)-1))/(y))*(y))
+#define PR_MIN(x,y)     ((x)<(y)?(x):(y))
+#define PR_MAX(x,y)     ((x)>(y)?(x):(y))
+#define PR_ABS(x)       ((x)<0?-(x):(x))
+
+/***********************************************************************
+** MACROS:      PR_ARRAY_SIZE
+** DESCRIPTION:
+**  The number of elements in an array.
+***********************************************************************/
+#define PR_ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))
+
+PR_BEGIN_EXTERN_C
+
+/*
+** Starting in NSPR 4.9.5, NSPR's exact-width integer types should match
+** the exact-width integer types defined in <stdint.h>. This allows sloppy
+** code to use PRInt{N} and int{N}_t interchangeably.
+**
+** The 8-bit and 16-bit integer types can only be defined using char and
+** short. All platforms define the 32-bit integer types using int. So only
+** the 64-bit integer types could be defined differently.
+**
+** NSPR's original strategy was to use the "shortest" 64-bit integer type:
+** if long is 64-bit, then prefer it over long long. This strategy is also
+** used by Linux/glibc, FreeBSD, and NetBSD.
+**
+** Other platforms use a different strategy: simply define the 64-bit
+** integer types using long long. We define the PR_ALTERNATE_INT64_TYPEDEF
+** macro on these platforms. Note that PR_ALTERNATE_INT64_TYPEDEF is for
+** internal use by NSPR headers only. Do not define or test this macro in
+** your code.
+**
+** NOTE: NSPR can't use <stdint.h> because C99 requires C++ code to define
+** __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS to make all the macros
+** defined in <stdint.h> available. This strange requirement is gone in
+** C11. When most platforms ignore this C99 requirement, NSPR will be able
+** to use <stdint.h>. A patch to do that is in NSPR bug 634793.
+*/
+
+#if defined(__APPLE__) || defined(__ANDROID__) || defined(__OpenBSD__)
+#define PR_ALTERNATE_INT64_TYPEDEF
+#endif
+
+/************************************************************************
+** TYPES:       PRUint8
+**              PRInt8
+** DESCRIPTION:
+**  The int8 types are known to be 8 bits each. There is no type that
+**      is equivalent to a plain "char".
+************************************************************************/
+#if PR_BYTES_PER_BYTE == 1
+typedef unsigned char PRUint8;
+/*
+** Some cfront-based C++ compilers do not like 'signed char' and
+** issue the warning message:
+**     warning: "signed" not implemented (ignored)
+** For these compilers, we have to define PRInt8 as plain 'char'.
+** Make sure that plain 'char' is indeed signed under these compilers.
+*/
+#if (defined(HPUX) && defined(__cplusplus) \
+        && !defined(__GNUC__) && __cplusplus < 199707L) \
+    || (defined(SCO) && defined(__cplusplus) \
+        && !defined(__GNUC__) && __cplusplus == 1L)
+typedef char PRInt8;
+#else
+typedef signed char PRInt8;
+#endif
+#else
+#error No suitable type for PRInt8/PRUint8
+#endif
+
+/************************************************************************
+ * MACROS:      PR_INT8_MAX
+ *              PR_INT8_MIN
+ *              PR_UINT8_MAX
+ * DESCRIPTION:
+ *  The maximum and minimum values of a PRInt8 or PRUint8.
+************************************************************************/
+
+#define PR_INT8_MAX 127
+#define PR_INT8_MIN (-128)
+#define PR_UINT8_MAX 255U
+
+/************************************************************************
+** TYPES:       PRUint16
+**              PRInt16
+** DESCRIPTION:
+**  The int16 types are known to be 16 bits each.
+************************************************************************/
+#if PR_BYTES_PER_SHORT == 2
+typedef unsigned short PRUint16;
+typedef short PRInt16;
+#else
+#error No suitable type for PRInt16/PRUint16
+#endif
+
+/************************************************************************
+ * MACROS:      PR_INT16_MAX
+ *              PR_INT16_MIN
+ *              PR_UINT16_MAX
+ * DESCRIPTION:
+ *  The maximum and minimum values of a PRInt16 or PRUint16.
+************************************************************************/
+
+#define PR_INT16_MAX 32767
+#define PR_INT16_MIN (-32768)
+#define PR_UINT16_MAX 65535U
+
+/************************************************************************
+** TYPES:       PRUint32
+**              PRInt32
+** DESCRIPTION:
+**  The int32 types are known to be 32 bits each.
+************************************************************************/
+#if PR_BYTES_PER_INT == 4
+typedef unsigned int PRUint32;
+typedef int PRInt32;
+#define PR_INT32(x)  x
+#define PR_UINT32(x) x ## U
+#elif PR_BYTES_PER_LONG == 4
+typedef unsigned long PRUint32;
+typedef long PRInt32;
+#define PR_INT32(x)  x ## L
+#define PR_UINT32(x) x ## UL
+#else
+#error No suitable type for PRInt32/PRUint32
+#endif
+
+/************************************************************************
+ * MACROS:      PR_INT32_MAX
+ *              PR_INT32_MIN
+ *              PR_UINT32_MAX
+ * DESCRIPTION:
+ *  The maximum and minimum values of a PRInt32 or PRUint32.
+************************************************************************/
+
+#define PR_INT32_MAX PR_INT32(2147483647)
+#define PR_INT32_MIN (-PR_INT32_MAX - 1)
+#define PR_UINT32_MAX PR_UINT32(4294967295)
+
+/************************************************************************
+** TYPES:       PRUint64
+**              PRInt64
+** DESCRIPTION:
+**  The int64 types are known to be 64 bits each. Care must be used when
+**      declaring variables of type PRUint64 or PRInt64. Different hardware
+**      architectures and even different compilers have varying support for
+**      64 bit values. The only guaranteed portability requires the use of
+**      the LL_ macros (see prlong.h).
+**
+** MACROS:      PR_INT64
+**              PR_UINT64
+** DESCRIPTION:
+**  The PR_INT64 and PR_UINT64 macros provide a portable way for
+**      specifying 64-bit integer constants. They can only be used if
+**      PRInt64 and PRUint64 are defined as compiler-supported 64-bit
+**      integer types (i.e., if HAVE_LONG_LONG is defined, which is true
+**      for all the supported compilers topday). If PRInt64 and PRUint64
+**      are defined as structs, the LL_INIT macro defined in prlong.h has
+**      to be used.
+**
+** MACROS:      PR_INT64_MAX
+**              PR_INT64_MIN
+**              PR_UINT64_MAX
+** DESCRIPTION:
+**  The maximum and minimum values of a PRInt64 or PRUint64.
+************************************************************************/
+#ifdef HAVE_LONG_LONG
+/* Keep this in sync with prlong.h. */
+#if PR_BYTES_PER_LONG == 8 && !defined(PR_ALTERNATE_INT64_TYPEDEF)
+typedef long PRInt64;
+typedef unsigned long PRUint64;
+#define PR_INT64(x)  x ## L
+#define PR_UINT64(x) x ## UL
+#elif defined(WIN32) && !defined(__GNUC__)
+typedef __int64  PRInt64;
+typedef unsigned __int64 PRUint64;
+#define PR_INT64(x)  x ## i64
+#define PR_UINT64(x) x ## ui64
+#else
+typedef long long PRInt64;
+typedef unsigned long long PRUint64;
+#define PR_INT64(x)  x ## LL
+#define PR_UINT64(x) x ## ULL
+#endif /* PR_BYTES_PER_LONG == 8 */
+
+#define PR_INT64_MAX PR_INT64(0x7fffffffffffffff)
+#define PR_INT64_MIN (-PR_INT64_MAX - 1)
+#define PR_UINT64_MAX PR_UINT64(-1)
+#else  /* !HAVE_LONG_LONG */
+typedef struct {
+#ifdef IS_LITTLE_ENDIAN
+    PRUint32 lo, hi;
+#else
+    PRUint32 hi, lo;
+#endif
+} PRInt64;
+typedef PRInt64 PRUint64;
+
+#define PR_INT64_MAX (PRInt64){0x7fffffff, 0xffffffff}
+#define PR_INT64_MIN (PRInt64){0xffffffff, 0xffffffff}
+#define PR_UINT64_MAX (PRUint64){0xffffffff, 0xffffffff}
+
+#endif /* !HAVE_LONG_LONG */
+
+/************************************************************************
+** TYPES:       PRUintn
+**              PRIntn
+** DESCRIPTION:
+**  The PRIntn types are most appropriate for automatic variables. They are
+**      guaranteed to be at least 16 bits, though various architectures may
+**      define them to be wider (e.g., 32 or even 64 bits). These types are
+**      never valid for fields of a structure.
+************************************************************************/
+#if PR_BYTES_PER_INT >= 2
+typedef int PRIntn;
+typedef unsigned int PRUintn;
+#else
+#error 'sizeof(int)' not sufficient for platform use
+#endif
+
+/************************************************************************
+** TYPES:       PRFloat64
+** DESCRIPTION:
+**  NSPR's floating point type is always 64 bits.
+************************************************************************/
+typedef double          PRFloat64;
+
+/************************************************************************
+** TYPES:       PRSize
+** DESCRIPTION:
+**  A type for representing the size of objects.
+************************************************************************/
+typedef size_t PRSize;
+
+
+/************************************************************************
+** TYPES:       PROffset32, PROffset64
+** DESCRIPTION:
+**  A type for representing byte offsets from some location.
+************************************************************************/
+typedef PRInt32 PROffset32;
+typedef PRInt64 PROffset64;
+
+/************************************************************************
+** TYPES:       PRPtrDiff
+** DESCRIPTION:
+**  A type for pointer difference. Variables of this type are suitable
+**      for storing a pointer or pointer subtraction.
+************************************************************************/
+typedef ptrdiff_t PRPtrdiff;
+
+/************************************************************************
+** TYPES:       PRUptrdiff
+** DESCRIPTION:
+**  A type for pointer difference. Variables of this type are suitable
+**      for storing a pointer or pointer sutraction.
+************************************************************************/
+#ifdef _WIN64
+typedef PRUint64 PRUptrdiff;
+#else
+typedef unsigned long PRUptrdiff;
+#endif
+
+/************************************************************************
+** TYPES:       PRBool
+** DESCRIPTION:
+**  Use PRBool for variables and parameter types. Use PR_FALSE and PR_TRUE
+**      for clarity of target type in assignments and actual arguments. Use
+**      'if (bool)', 'while (!bool)', '(bool) ? x : y' etc., to test booleans
+**      just as you would C int-valued conditions.
+************************************************************************/
+typedef PRIntn PRBool;
+#define PR_TRUE 1
+#define PR_FALSE 0
+
+/************************************************************************
+** TYPES:       PRPackedBool
+** DESCRIPTION:
+**  Use PRPackedBool within structs where bitfields are not desirable
+**      but minimum and consistant overhead matters.
+************************************************************************/
+typedef PRUint8 PRPackedBool;
+
+/*
+** Status code used by some routines that have a single point of failure or
+** special status return.
+*/
+typedef enum { PR_FAILURE = -1, PR_SUCCESS = 0 } PRStatus;
+
+#ifndef __PRUNICHAR__
+#define __PRUNICHAR__
+#ifdef WIN32
+typedef wchar_t PRUnichar;
+#else
+typedef PRUint16 PRUnichar;
+#endif
+#endif
+
+/*
+** WARNING: The undocumented data types PRWord and PRUword are
+** only used in the garbage collection and arena code.  Do not
+** use PRWord and PRUword in new code.
+**
+** A PRWord is an integer that is the same size as a void*.
+** It implements the notion of a "word" in the Java Virtual
+** Machine.  (See Sec. 3.4 "Words", The Java Virtual Machine
+** Specification, Addison-Wesley, September 1996.
+** http://java.sun.com/docs/books/vmspec/index.html.)
+*/
+#ifdef _WIN64
+typedef PRInt64 PRWord;
+typedef PRUint64 PRUword;
+#else
+typedef long PRWord;
+typedef unsigned long PRUword;
+#endif
+
+#if defined(NO_NSPR_10_SUPPORT)
+#else
+/********* ???????????????? FIX ME       ??????????????????????????? *****/
+/********************** Some old definitions until pr=>ds transition is done ***/
+/********************** Also, we are still using NSPR 1.0. GC ******************/
+/*
+** Fundamental NSPR macros, used nearly everywhere.
+*/
+
+#define PR_PUBLIC_API		PR_IMPLEMENT
+
+/*
+** Macro body brackets so that macros with compound statement definitions
+** behave syntactically more like functions when called.
+*/
+#define NSPR_BEGIN_MACRO        do {
+#define NSPR_END_MACRO          } while (0)
+
+/*
+** Macro shorthands for conditional C++ extern block delimiters.
+*/
+#ifdef NSPR_BEGIN_EXTERN_C
+#undef NSPR_BEGIN_EXTERN_C
+#endif
+#ifdef NSPR_END_EXTERN_C
+#undef NSPR_END_EXTERN_C
+#endif
+
+#ifdef __cplusplus
+#define NSPR_BEGIN_EXTERN_C     extern "C" {
+#define NSPR_END_EXTERN_C       }
+#else
+#define NSPR_BEGIN_EXTERN_C
+#define NSPR_END_EXTERN_C
+#endif
+
+#include "obsolete/protypes.h"
+
+/********* ????????????? End Fix me ?????????????????????????????? *****/
+#endif /* NO_NSPR_10_SUPPORT */
+
+/*
+** Compile-time assert. "condition" must be a constant expression.
+** The macro can be used only in places where an "extern" declaration is
+** allowed.
+*/
+#define PR_STATIC_ASSERT(condition) \
+    extern void pr_static_assert(int arg[(condition) ? 1 : -1])
+
+PR_END_EXTERN_C
+
+#endif /* prtypes_h___ */
+
diff --git a/js/src/prwin16.h b/js/src/prwin16.h
new file mode 100644
--- /dev/null
+++ b/js/src/prwin16.h
@@ -0,0 +1,164 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef prwin16_h___
+#define prwin16_h___
+
+/*
+** Condition use of this header on platform.
+*/
+#if (defined(XP_PC) && !defined(_WIN32) && !defined(XP_OS2) && defined(MOZILLA_CLIENT)) || defined(WIN16)
+#include <stdio.h>
+
+PR_BEGIN_EXTERN_C
+/* 
+** Win16 stdio special case.
+** To get stdio to work for Win16, all calls to printf() and related
+** things must be called from the environment of the .EXE; calls to
+** printf() from the .DLL send output to the bit-bucket.
+**
+** To make sure that PR_fprintf(), and related functions, work correctly,
+** the actual stream I/O to stdout, stderr, stdin must be done in the
+** .EXE. To do this, a hack is placed in _MD_Write() such that the
+** fd for stdio handles results in a call to the .EXE.
+**
+** file w16stdio.c contains the functions that get called from NSPR
+** to do the actual I/O. w16stdio.o must be statically linked with
+** any application needing stdio for Win16.
+**
+** The address of these functions must be made available to the .DLL
+** so he can call back to the .EXE. To do this, function 
+** PR_MD_RegisterW16StdioCallbacks() is called from the .EXE.
+** The arguments are the functions defined in w16stdio.c
+** At runtime, MD_Write() calls the registered functions, if any
+** were registered.
+**
+** prinit.h contains a macro PR_STDIO_INIT() that calls the registration
+** function for Win16; For other platforms, the macro is a No-Op.
+**
+** Note that stdio is not operational at all on Win16 GUI applications.
+** This special case exists to provide stdio capability from the NSPR
+** .DLL for command line applications only. NSPR's test cases are
+** almost exclusively command line applications.
+**
+** See also: w16io.c, w16stdio.c
+*/
+typedef PRInt32 (PR_CALLBACK *PRStdinRead)( void *buf, PRInt32 amount);
+typedef PRInt32 (PR_CALLBACK *PRStdoutWrite)( void *buf, PRInt32 amount);
+typedef PRInt32 (PR_CALLBACK *PRStderrWrite)( void *buf, PRInt32 amount);
+
+NSPR_API(PRStatus)
+PR_MD_RegisterW16StdioCallbacks( 
+    PRStdinRead inReadf,            /* i: function pointer for stdin read       */
+    PRStdoutWrite outWritef,        /* i: function pointer for stdout write     */
+    PRStderrWrite errWritef         /* i: function pointer for stderr write     */
+    );
+
+NSPR_API(PRInt32)
+_PL_W16StdioWrite( void *buf, PRInt32 amount );
+
+NSPR_API(PRInt32)
+_PL_W16StdioRead( void *buf, PRInt32 amount );
+
+#define PR_STDIO_INIT() PR_MD_RegisterW16StdioCallbacks( \
+    _PL_W16StdioRead, _PL_W16StdioWrite, _PL_W16StdioWrite ); \
+    PR_INIT_CALLBACKS();
+
+/*
+** Win16 hackery.
+**
+*/
+struct PRMethodCallbackStr {
+    int     (PR_CALLBACK *auxOutput)(const char *outputString);
+    size_t  (PR_CALLBACK *strftime)(char *s, size_t len, const char *fmt, const struct tm *p);
+    void *  (PR_CALLBACK *malloc)( size_t size );
+    void *  (PR_CALLBACK *calloc)(size_t n, size_t size );
+    void *  (PR_CALLBACK *realloc)( void* old_blk, size_t size );
+    void    (PR_CALLBACK *free)( void *ptr );
+    void *  (PR_CALLBACK *getenv)( const char *name);
+    int     (PR_CALLBACK *putenv)( const char *assoc);
+/*    void *  (PR_CALLBACK *perror)( const char *prefix ); */
+};
+
+NSPR_API(void) PR_MDRegisterCallbacks(struct PRMethodCallbackStr *);
+
+int PR_CALLBACK _PL_W16CallBackPuts( const char *outputString );
+size_t PR_CALLBACK _PL_W16CallBackStrftime( 
+    char *s, 
+    size_t len, 
+    const char *fmt,
+    const struct tm *p );
+void * PR_CALLBACK _PL_W16CallBackMalloc( size_t size );
+void * PR_CALLBACK _PL_W16CallBackCalloc( size_t n, size_t size );
+void * PR_CALLBACK _PL_W16CallBackRealloc( 
+    void *old_blk, 
+    size_t size );
+void   PR_CALLBACK _PL_W16CallBackFree( void *ptr );
+void * PR_CALLBACK _PL_W16CallBackGetenv( const char *name );
+int PR_CALLBACK _PL_W16CallBackPutenv( const char *assoc );
+
+/*
+** Hackery! 
+**
+** These functions are provided as static link points.
+** This is to satisfy the quick port of Gromit to NSPR 2.0
+** ... Don't do this! ... alas, It may never go away.
+** 
+*/
+NSPR_API(int)     PR_MD_printf(const char *, ...);
+NSPR_API(void)    PR_MD_exit(int);
+NSPR_API(size_t)  PR_MD_strftime(char *, size_t, const char *, const struct tm *); 
+NSPR_API(int)     PR_MD_sscanf(const char *, const char *, ...);
+NSPR_API(void*)   PR_MD_malloc( size_t size );
+NSPR_API(void*)   PR_MD_calloc( size_t n, size_t size );
+NSPR_API(void*)   PR_MD_realloc( void* old_blk, size_t size );
+NSPR_API(void)    PR_MD_free( void *ptr );
+NSPR_API(char*)   PR_MD_getenv( const char *name );
+NSPR_API(int)     PR_MD_putenv( const char *assoc );
+NSPR_API(int)     PR_MD_fprintf(FILE *fPtr, const char *fmt, ...);
+
+#define PR_INIT_CALLBACKS()                         \
+    {                                               \
+        static struct PRMethodCallbackStr cbf = {   \
+            _PL_W16CallBackPuts,                    \
+            _PL_W16CallBackStrftime,                \
+            _PL_W16CallBackMalloc,                  \
+            _PL_W16CallBackCalloc,                  \
+            _PL_W16CallBackRealloc,                 \
+            _PL_W16CallBackFree,                    \
+            _PL_W16CallBackGetenv,                  \
+            _PL_W16CallBackPutenv,                  \
+        };                                          \
+        PR_MDRegisterCallbacks( &cbf );             \
+    }
+
+
+/*
+** Get the exception context for Win16 MFC applications threads
+*/
+NSPR_API(void *) PR_W16GetExceptionContext(void);
+/*
+** Set the exception context for Win16 MFC applications threads
+*/
+NSPR_API(void) PR_W16SetExceptionContext(void *context);
+
+PR_END_EXTERN_C
+#else
+/*
+** For platforms other than Win16, define
+** PR_STDIO_INIT() as a No-Op.
+*/
+#define PR_STDIO_INIT()
+#endif /* WIN16 || MOZILLA_CLIENT */
+
+#endif /* prwin16_h___ */
+
+
+
+
+
+
+
+
